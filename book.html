<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>Mastering Bitcoin</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Mastering Bitcoin</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_preface">Preface</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_writing_the_bitcoin_book">Writing the Bitcoin Book</h3>
<div class="paragraph"><p>I first stumbled upon bitcoin in mid-2011. My immediate reaction was more or less "Pfft! Nerd money!" and I ignored it for another 6 months, failing to grasp its importance. This is a reaction which I have seen repeated among many of the smartest people I know, which gives me some consolation. The second time I came across bitcoin in a mailing list discussion, I decided to read the white paper written by Satoshi Nakamoto, to study the authoritative source and see what it was all about. I still remember the moment I finished reading those 9 pages, when I realized that bitcoin was not simply a digital currency, but a network of trust that could also provide the basis for so much more than just currencies. That realization: "This isn&#8217;t money, it&#8217;s a de-centralized trust network," started me on a four month journey to devour every scrap of information about bitcoin I could find. I became obsessed and enthralled, spending twelve or more hours each day glued to a screen, reading, writing, coding and learning as much as I could. I emerged from this state of fugue, more than 20 lbs lighter from lack of consistent meals, determined to dedicate myself to working on bitcoin.</p></div>
<div class="paragraph"><p>Two years later, after creating a number of small startups to explore various bitcoin-related services and products, I decided that it was time to write my first book. Bitcoin was the topic that had driven me into a frenzy of creativity, consumed my thoughts and was the most exciting technology I had encountered since the Internet. It was now time to share my passion about this amazing technology with a broader audience.</p></div>
</div>
<div class="sect2">
<h3 id="_intended_audience">Intended Audience</h3>
<div class="paragraph"><p>This book is mostly intended for coders. If you can use a programming language, this book will teach you how cryptographic currencies work, how to use them and how to develop software that works with them. The first few chapters are also suitable as an in-depth introduction to bitcoin for non-coders - those trying to understand the inner workings of bitcoin and crypto-currencies.</p></div>
</div>
<div class="sect2">
<h3 id="_why_are_there_bugs_on_the_cover">Why Are There Bugs On The Cover?</h3>
<div class="paragraph"><p>The Leafcutter Ant is a species that exhibits highly complex behavior in a colony super-organism, but each individual ant operates on a set of simple rules driven by social interaction and the exchange of chemical scents (pheromones). Per Wikipedia: "Next to humans, leafcutter ants form the largest and most complex animal societies on Earth." Leafcutter ants don&#8217;t actually eat leaves, but rather use them to farm a fungus, which is the central food source for the colony. Get that? These ants are farming!</p></div>
<div class="paragraph"><p>While ants form a caste-based society and have a queen for producing offspring, there is no central authority or leader in an ant colony. The highly intelligent and sophisticated behavior exhibited by a multi-million member colony is an emergent property from the interaction of the individuals in a social network.</p></div>
<div class="paragraph"><p>Nature demonstrates that de-centralized systems can be resilient and can produce emergent complexity and incredible sophistication without the need for a central authority, hierarchy or complex parts.</p></div>
<div class="paragraph"><p>Bitcoin is a highly sophisticated de-centralized trust network that can support a myriad of financial processes. Yet, each node in the bitcoin network follows a few simple mathematical rules. The interaction between many nodes is what leads to the emergence of the sophisticated behavior, not any inherent complexity or trust in any single node. Like an ant colony, the bitcoin network is a resilient network of simple nodes following simple rules that together can do amazing things without any central coordination.</p></div>
</div>
<div class="sect2">
<h3 id="_conventions_used_in_this_book">Conventions Used in This Book</h3>
<div class="paragraph"><p>The following typographical conventions are used in this book:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>Italic</em>
</dt>
<dd>
<p>
Indicates new terms, URLs, email addresses, filenames, and file extensions.
</p>
</dd>
<dt class="hdlist1">
<code>Constant width</code>
</dt>
<dd>
<p>
Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.
</p>
</dd>
<dt class="hdlist1">
<strong><code>Constant width bold</code></strong>
</dt>
<dd>
<p>
Shows commands or other text that should be typed literally by the user.
</p>
</dd>
<dt class="hdlist1">
<em><code>Constant width italic</code></em>
</dt>
<dd>
<p>
Shows text that should be replaced with user-supplied values or by values determined by context.
</p>
</dd>
</dl></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>This icon signifies a tip, suggestion, or general note.</p></div>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>This icon indicates a warning or caution.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_github_source_code">Github Source Code</h3>
<div class="paragraph"><p>This book is available on Github, as a repository that contains the text, images and code:</p></div>
<div class="paragraph"><p><a href="https://github.com/aantonop/bitcoinbook">https://github.com/aantonop/bitcoinbook</a></p></div>
<div class="paragraph"><p>Fork the book code, try the code examples, or submit corrections via Github.</p></div>
</div>
<div class="sect2">
<h3 id="_code_examples">Code Examples</h3>
<div class="paragraph"><p>The examples are illustrated in Python, C++ and using the command-line of a Unix-like operating system such as Linux or Mac OSX. All code snippets are available in the Github repository and can be accessed online at <a href="https://github.com/aantonop/bitcoinbook">https://github.com/aantonop/bitcoinbook</a> in the <code>code</code> subdirectory of the main repository.</p></div>
<div class="paragraph"><p>All the code snippets can be replicated on most operating systems with a minimal installation of compilers and interpreters for the corresponding languages. Where necessary, we provide basic installation instructions and step-by-step examples of the output of those instructions.</p></div>
<div class="paragraph"><p>Some of the code snippets and code output have been re-formatted for print. In all such cases, the lines have been split by a backslash "\" character, followed by a newline character. When transcribing the examples, remove those two characters and join the lines again and you should see identical results as shown in the example.</p></div>
<div class="paragraph"><p>All the code snippets use real values and calculations where possible, so that you can build from example to example and see the same results in any code you write to calculate the same values. For example, the private keys and corresponding public keys and addresses are all real. The sample transactions, blocks and blockchain references have all been introduced in the actual bitcoin blockchain and are part of the public ledger, so you can review them on any bitcoin system.</p></div>
</div>
<div class="sect2">
<h3 id="_using_code_examples">Using Code Examples</h3>
<div class="paragraph"><p>This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p></div>
<div class="paragraph"><p>We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<em>Mastering Bitcoin</em> by Andreas M. Antonopoulos (O’Reilly). Copyright 2014 Andreas M. Antonopoulos, 978-1449374044.”</p></div>
<div class="paragraph"><p>Some editions of this books are offered under an open source license, such as CC-BY-NC (creativecommons.org) in which case the terms of that licenses apply.</p></div>
<div class="paragraph"><p>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <email>permissions@oreilly.com</email>.</p></div>
</div>
<div class="sect2">
<h3 id="_safari_books_online">Safari® Books Online</h3>
<div class="admonitionblock safarienabled">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p><ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">Safari Books Online</ulink> is an on-demand digital library that delivers expert <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/content">content</ulink> in both book and video form from the world&#8217;s leading authors in technology and business.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Technology professionals, software developers, web designers, and business and creative professionals use Safari Books Online as their primary resource for research, problem solving, learning, and certification training.</p></div>
<div class="paragraph"><p>Safari Books Online offers a range of <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/subscriptions">product mixes</ulink> and pricing programs for <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/organizations-teams">organizations</ulink>, <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/government">government agencies</ulink>, and <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/individuals">individuals</ulink>. Subscribers have access to thousands of books, training videos, and prepublication manuscripts in one fully searchable database from publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/publishers">more</ulink>. For more information about Safari Books Online, please visit us <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/">online</ulink>.</p></div>
</div>
<div class="sect2">
<h3 id="_how_to_contact_us">How to Contact Us</h3>
<div class="paragraph"><p>Please address comments and questions concerning this book to the publisher:</p></div>
<simplelist>
<member>O’Reilly Media, Inc.</member>
<member>1005 Gravenstein Highway North</member>
<member>Sebastopol, CA 95472</member>
<member>800-998-9938 (in the United States or Canada)</member>
<member>707-829-0515 (international or local)</member>
<member>707-829-0104 (fax)</member>
</simplelist>
<div class="paragraph"><p>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a href="http://shop.oreilly.com/product/0636920032281.do">http://shop.oreilly.com/product/0636920032281.do</a>.</p></div>
<div class="paragraph"><p>To comment or ask technical questions about this book, send email to <email>bookquestions@oreilly.com</email>.</p></div>
<div class="paragraph"><p>For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com">http://www.oreilly.com</a>.</p></div>
<div class="paragraph"><p>Find us on Facebook: <a href="http://facebook.com/oreilly">http://facebook.com/oreilly</a></p></div>
<div class="paragraph"><p>Follow us on Twitter: <a href="http://twitter.com/oreillymedia">http://twitter.com/oreillymedia</a></p></div>
<div class="paragraph"><p>Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia">http://www.youtube.com/oreillymedia</a></p></div>
<?hard-pagebreak?>
</div>
<div class="sect2">
<h3 id="_acknowledgments">Acknowledgments</h3>
<div class="paragraph"><p>This book represents the efforts and contributions of many people. I am grateful for all the help I received from friends, colleagues and even complete strangers, who joined me in this effort to write the definitive technical book on crypto-currencies and bitcoin.</p></div>
<div class="paragraph"><p>It is impossible to make a distinction between the bitcoin technology and the bitcoin community, and this book is as much a product of that community as it is a book on the technology. My work on this book was encouraged, cheered on, supported and rewarded by the entire bitcoin community from the very beginning until the very end. More than anything, this book has allowed me to be part of a wonderful community for two years and I can&#8217;t thank you enough for accepting me in this community. There are far too many people to mention by name - people I&#8217;ve met at conferences, events, seminars, meetups, pizza gatherings and small private gatherings, as well as many who communicated with me by twitter, on reddit, on bitcointalk.org and on github who have had an impact on this book. Every idea, analogy, question, answer, and explanation you find in this book was at some point inspired, tested or improved through my interactions with the community. Thank you all for your support, without you this book would not have happened. I am forever grateful.</p></div>
<div class="paragraph"><p>The journey to becoming an author starts long before the first book, of course. My first language (and schooling) was Greek, so I had to take a remedial English Writing course in my first year of university. I owe thanks to Diana Kordas, my English Writing teacher, who helped me build confidence and skills that year. Later, as a professional, I developed my technical writing skills on the topic of data centers, writing for Network World magazine. I owe thanks to John Dix and John Gallant who gave me my first writing job as a columnist at Network World and to my editor Michael Cooney and my colleague Johna Till Johnson who edited my columns and made them fit for publication. Writing 500 words a week for four years gave me enough experience to eventually consider becoming an author. Thanks to Jean for her early encouragement to become an author and for always believing and insisting that I had a book in me.</p></div>
<div class="paragraph"><p>Thanks also to those who supported me when I submitted my book proposal to O&#8217;Reilly, by providing references and reviewing the proposal. Specifically, thanks to John Gallant, Gregory Ness, Richard Stiennon, Joel Snyder, Adam B. Levine, Sandra Gittlen, John Dix, Johna Till Johnson, Roger Ver and Jon Matonis. Special thanks to Richard Kagan and Tymon Mattoszko who reviewed early versions of the proposal and Matthew Owain Taylor who copy-edited the proposal.</p></div>
<div class="paragraph"><p>Thanks to Cricket Liu, author of O&#8217;Reilly title "DNS and BIND" who introduced me to O&#8217;Reilly. Thanks also to Michael Loukides and Allyson MacDonald at O&#8217;Reilly who worked for months to help make this book happen. Allyson was especially patient when deadlines were missed and deliverables delayed as life intervened in our planned schedule.</p></div>
<div class="paragraph"><p>The first few drafts of the first few chapters were the hardest, because bitcoin is a difficult subject to unravel. Every time I pulled on one thread of the bitcoin technology, I had to pull in the whole thing. I repeatedly got stuck and a bit despondent as I struggled to make the topic easy to understand and create a narrative around such a dense technical subject. Eventually, I decided to tell the story of bitcoin through the stories of the people using bitcoin and the whole book became a lot easier to write. I owe thanks to my friend and mentor, Richard Kagan, who helped me unravel the story and get past the moments of writer&#8217;s block, and Pamela Morgan who reviewed early drafts of each chapter and asked the hard questions to make them better. Also, thanks to the developers of the San Francisco Bitcoin Developers Meetup group and Taariq Lewis, the group&#8217;s co-founder, for helping to test the early material.</p></div>
<div class="paragraph"><p>During the development of the book, I made early drafts available on Github and invited public comments. More than a hundred comments, suggestions, corrections and contributions were submitted in response. Those contributions are explicitly acknowledged, with my thanks, in <a href="#github_contrib">[github_contrib]</a>. Special thanks to Minh T. Nguyen who volunteered to manage the Github contributions and added many significant contributions himself. Thanks also to Andrew Naugler for infographic design.</p></div>
<div class="paragraph"><p>Once the book was drafted, it went through several rounds of technical review. Thanks to Cricket Liu and Lorne Lantz for their thorough review, comments and support.</p></div>
<div class="paragraph"><p>Several bitcoin developers contributed code samples, reviews, comments and encouragement. Thanks to Amir Taaki for example code snippets and many great comments, Vitalik Buterin and Richard Kiss for help with elliptic curve math and code contributions, Gavin Andresen for corrections, comments and encouragement, Michalis Kargakis for comments, contributions and btcd writeup.</p></div>
<div class="paragraph"><p>I owe my love of words and books to my mother, Theresa, who raised me in a house with books lining every wall. My mother also bought me my first computer in 1982, despite being a self-described technophobe. My father, Menelaos, a civil engineer who just published his first book at 80 years old, was the one who taught me logical and analytical thinking and a love of science and engineering.</p></div>
<div class="paragraph"><p>Thank you all for supporting me throughout this journey.</p></div>
<div class="sect3">
<h4 id="github_contrib">Early Release Draft (Github Contributions)</h4>
<div class="paragraph"><p>Many contributors offered comments, corrections and additions to the early-release draft on Github. Thank you all for your contributions to this book. Notable contributors included the following:</p></div>
<div class="sect4">
<h5 id="_name_github_id">(Name - Github ID)</h5>
<div class="ulist"><ul>
<li>
<p>
<strong>Minh T. Nguyen - enderminh: Github contribution editor</strong>
</p>
</li>
<li>
<p>
Ed Eykholt - edeykholt
</p>
</li>
<li>
<p>
Michalis Kargakis - kargakis
</p>
</li>
<li>
<p>
Erik Wahlström - erikwam
</p>
</li>
<li>
<p>
Richard Kiss - richardkiss
</p>
</li>
<li>
<p>
Eric Winchell - winchell
</p>
</li>
<li>
<p>
Sergej Kotliar - ziggamon
</p>
</li>
<li>
<p>
Nagaraj Hubli - nagarajhubli
</p>
</li>
<li>
<p>
ethers
</p>
</li>
<li>
<p>
Alex Waters - alexwaters
</p>
</li>
<li>
<p>
Mihail Russu - MihailRussu
</p>
</li>
<li>
<p>
Ish Ot Jr. - ishotjr
</p>
</li>
<li>
<p>
James Addison - jayaddison
</p>
</li>
<li>
<p>
Nekomata - nekomata-3
</p>
</li>
<li>
<p>
Simon de la Rouviere - simondlr
</p>
</li>
<li>
<p>
Chapman Shoop - belovachap
</p>
</li>
<li>
<p>
Holger Schinzel - schinzelh
</p>
</li>
<li>
<p>
effectsToCause - vericoin
</p>
</li>
<li>
<p>
Stephan Oeste - Emzy
</p>
</li>
<li>
<p>
Joe Bauers - joebauers
</p>
</li>
<li>
<p>
Jason Bisterfeldt - jbisterfeldt
</p>
</li>
<li>
<p>
Ed Leafe - EdLeafe
</p>
</li>
</ul></div>
<?hard-pagebreak?>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_quick_glossary">Quick Glossary</h3>
<div class="paragraph"><p>This quick glossary contains many of the terms used in relation to bitcoin. These terms are used throughout the book, so bookmark this for a quick reference and clarification.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
address (aka public key)
</dt>
<dd>
<p>



    A bitcoin address looks like <code>1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV</code> - they consist of a string of letters and numbers starting with a "1" (number one). Just like you ask others to send an email to your email address, you would ask others to send you bitcoin to your bitcoin address.
</p>
</dd>
<dt class="hdlist1">
bip
</dt>
<dd>
<p>

    Bitcoin Improvement Proposals.  A set of proposals that members of the bitcoin community have submitted to improve bitcoin.  For example BIP0021 is a proposal to improve the bitcoin URI scheme.
</p>
</dd>
<dt class="hdlist1">
bitcoin
</dt>
<dd>
<p>

    The name of the currency unit (the coin), the network and the software
</p>
</dd>
<dt class="hdlist1">
block
</dt>
<dd>
<p>

        A grouping of transactions, marked with a timestamp, and a fingerprint of the previous block. The block header is hashed to find a proof-of-work, thereby validating the transactions. Valid blocks are added to the main blockchain by network consensus.
</p>
</dd>
<dt class="hdlist1">
blockchain
</dt>
<dd>
<p>

                A list of validated blocks, each linking to its predecessor all the way to the genesis block.
</p>
</dd>
<dt class="hdlist1">
confirmations
</dt>
<dd>
<p>

                Once a transaction is included in a block, it has "one confirmation". As soon as <em>another</em> block is mined on the same blockchain, the transaction has two confirmations etc. Six or more confirmations is considered sufficient proof that a transaction cannot be reversed.
</p>
</dd>
<dt class="hdlist1">
difficulty
</dt>
<dd>
<p>

        A network-wide setting that controls how much computation is required to find a proof-of-work.
</p>
</dd>
<dt class="hdlist1">
difficulty target
</dt>
<dd>
<p>

        A difficulty at which all the computation in the network will find blocks approximately every 10 minutes.
</p>
</dd>
<dt class="hdlist1">
difficulty re-targeting
</dt>
<dd>
<p>

        A network-wide re-calculation of the difficulty which occurs once every 2106 blocks and considers the hashing power of the previous 2106 blocks.
</p>
</dd>
<dt class="hdlist1">
fees
</dt>
<dd>
<p>

        The sender of a transaction often includes a fee to the network for processing their requested transaction.  Most transactions require a minimum fee of 0.5mBTC.
</p>
</dd>
<dt class="hdlist1">
hash
</dt>
<dd>
<p>

        A digital fingerprint of some binary input.
</p>
</dd>
<dt class="hdlist1">
genesis block
</dt>
<dd>
<p>

        The first block in the blockchain, used to initialize the crypto-currency
</p>
</dd>
<dt class="hdlist1">
miner
</dt>
<dd>
<p>

        A network node that finds valid proof-of-work for new blocks, by repeated hashing
</p>
</dd>
<dt class="hdlist1">
network
</dt>
<dd>
<p>

        A peer-to-peer network that propagates transactions and blocks to every bitcoin node on the network.
</p>
</dd>
<dt class="hdlist1">
proof-of-work
</dt>
<dd>
<p>

        A piece of data that requires significant computation to find. In bitcoin, miners must find a numeric solution to the SHA256 algorithm that meets a network wide target, the difficulty target.
</p>
</dd>
<dt class="hdlist1">
reward
</dt>
<dd>
<p>

        An amount included in each new block as a reward by the network to the miner who found the proof-of-work solution. It is currently 25BTC per block.
</p>
</dd>
<dt class="hdlist1">
secret key (aka private key)
</dt>
<dd>
<p>


        The secret number that unlocks bitcoins sent to the corresponding address.  A secret key looks like <code>5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh</code>
</p>
</dd>
<dt class="hdlist1">
transaction
</dt>
<dd>
<p>

        In simple terms, a transfer of bitcoins from one address to another. More precisely, a transaction is a signed data structure expressing a transfer of value. Transactions are transmitted over the bitcoin network, collected by miners and included into blocks, made permanent on the blockchain.
</p>
</dd>
<dt class="hdlist1">
wallet
</dt>
<dd>
<p>

        Software that holds all your bitcoin addresses and secret keys. Use it to send, receive and store your bitcoin.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch01_intro_what_is_bitcoin">Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_is_bitcoin">What is Bitcoin?</h3>
<div class="paragraph"><p>Bitcoin is a collection of concepts and technologies that form the basis of a digital money ecosystem.  Units of currency called bitcoins are used to store and transmit value among participants in the bitcoin network.  Bitcoin users communicate with each other using the bitcoin protocol primarily via the Internet, although other transport networks can also be used. The bitcoin protocol stack, available as open source software, can be run on a wide range of computing devices, including laptops and smartphones, making the technology easily accessible.</p></div>
<div class="paragraph"><p>Users can transfer bitcoin over the network to do just about anything that can be done with conventional currencies, such as buy and sell goods, send money to people or organizations, or extend credit.  Bitcoin technology includes features that are based on encryption and digital signatures to ensure the security of the bitcoin network. Bitcoins can be purchased, sold and exchanged for other currencies at specialized currency exchanges. Bitcoin in a sense is the perfect form of money for the Internet because it is fast, secure, and borderless.</p></div>
<div class="paragraph"><p>Unlike traditional currencies, bitcoins are entirely virtual. There are no physical coins or even digital coins per se. The coins are implied in transactions which transfer value from sender to recipient. Users of bitcoin own keys which allow them to prove ownership of transactions in the bitcoin network, unlocking the value to spend it and transfer it to a new recipient. Those keys are often stored in a digital wallet on each user’s computer. Possession of the key that unlocks a transaction is the only prerequisite to spending bitcoins, putting the control entirely in the hands of each user.</p></div>
<div class="paragraph"><p>Bitcoin is a fully-distributed, peer-to-peer system. As such there is no "central" server or point of control. Bitcoins are created through a process called "mining", which involves looking for a solution to a difficult problem. Any participant in the bitcoin network (i.e., any device running the full bitcoin protocol stack) may operate as a miner, using their computer&#8217;s processing power to attempt to find solutions to this problem. Every 10 minutes on average, a new solution is found by someone who then is able to validate the transactions of the past 10 minutes and is rewarded with brand new bitcoins. Essentially, bitcoin mining de-centralizes the currency-issuance and clearing functions of a central bank and replaces the need for any central bank with this global competition.</p></div>
<div class="paragraph"><p>The bitcoin protocol includes built-in algorithms that regulate the mining function across the network.  The difficulty of the problem that miners must solve is adjusted dynamically so that, on average, someone finds a correct answer every 10 minutes regardless of how many miners (and CPUs) are working on the problem at any moment.  The protocol also halves the rate at which new bitcoins are created every 4 years, and limits the total number of bitcoins that will be created to a fixed total of 21 million coins. The result is that the number of bitcoins in circulation closely follows an easily predictable curve that reaches 21 million by the year 2140.  Due to bitcoin&#8217;s diminishing rate of issuance, over the long term, the bitcoin currency is deflationary. Furthermore, bitcoin cannot be inflated by "printing" new money above and beyond the expected issuance rate.</p></div>
<div class="paragraph"><p>Behind the scenes, bitcoin is also the name of the protocol, a network and a distributed computing innovation. The bitcoin currency is really only the first application of this invention. As a developer, I see bitcoin as akin to the Internet of money, a network for propagating value and securing the ownership of digital assets via distributed computation. There&#8217;s a lot more to bitcoin than first meets the eye.</p></div>
<div class="paragraph"><p>In this chapter we&#8217;ll get started by explaining some of the main concepts and terms, getting the necessary software and using bitcoin for simple transactions. In following chapters we&#8217;ll start unwrapping the layers of technology that make bitcoin possible and examine the inner workings of the bitcoin network and protocol.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Digital Currencies Before Bitcoin</div>
<div class="paragraph"><p>The emergence of viable digital money is closely linked to developments in cryptography. This is not surprising when one considers the fundamental challenges involved with using bits to represent value that can be exchanged for goods and services. Two fundamental questions for anyone accepting digital money are:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Can I trust the money is authentic and not counterfeit?
</p>
</li>
<li>
<p>
Can I be sure that no one else can claim that this money belongs to them and not me? (aka the “double-spend” problem)
</p>
</li>
</ol></div>
<div class="paragraph"><p>Issuers of paper money are constantly battling the counterfeiting problem by using increasingly sophisticated papers and printing technology.  Physical money addresses the double-spend issue easily because the same paper note cannot be in two places at once. Of course, conventional money is also often stored and transmitted digitally. In this case the counterfeiting and double-spend issues are handled by clearing all electronic transactions through central authorities that have a global view of the currency in circulation. For digital money, which cannot take advantage of esoteric inks or holographic strips, cryptography provides the basis for trusting the legitimacy of a user’s claim to value.  Specifically, cryptographic digital signatures enable a user to sign a digital asset or transaction proving the ownership of that asset. With the appropriate architecture, digital signatures also can be used to address the double-spend issue.</p></div>
<div class="paragraph"><p>When cryptography started becoming more broadly available and understood in the late 1980s, many researchers began trying to use cryptography to build digital currencies. These early digital currency projects issued digital money, usually backed by a national currency or precious metal such as gold.</p></div>
<div class="paragraph"><p>While these earlier digital currencies worked, they were centralized and as a result they were easy to attack by governments and hackers. Early digital currencies used a central clearinghouse to settle all transactions at regular intervals, just like a traditional banking system. Unfortunately, in most cases these nascent digital currencies were targeted by worried governments and eventually litigated out of existence. Some failed in spectacular crashes when the parent company liquidated abruptly. To be robust against intervention by antagonists, whether legitimate governments or criminal elements, a de-centralized digital currency was needed to avoid a single point of attack. Bitcoin is such a system, completely de-centralized by design, and free of any central authority or point of control that can be attacked or corrupted.</p></div>
<div class="paragraph"><p>Bitcoin represents the culmination of decades of research in cryptography and distributed systems and includes four key innovations brought together in a unique and powerful combination. Bitcoin consists of:</p></div>
<div class="ulist"><ul>
<li>
<p>
A de-centralized peer-to-peer network (the bitcoin protocol);
</p>
</li>
<li>
<p>
A public transaction ledger (the blockchain);
</p>
</li>
<li>
<p>
A de-centralized mathematical and deterministic currency issuance (distributed mining), and;
</p>
</li>
<li>
<p>
A de-centralized transaction verification system (transaction script).
</p>
</li>
</ul></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_history_of_bitcoin">History of Bitcoin</h3>
<div class="paragraph"><p>Bitcoin was invented in 2008 by Satoshi Nakamoto with the publication of a paper titled "Bitcoin: A Peer-to-Peer Electronic Cash System". Satoshi Nakamoto combined several prior inventions such as b-money and HashCash to create a completely de-centralized electronic cash system that does not rely on a central authority for currency issuance or settlement and validation of transactions. The key innovation was to use a distributed computation system (called a "Proof-Of-Work" algorithm) to conduct a global "election" every 10 minutes, allowing the de-centralized network to arrive at <em>consensus</em> about the state of transactions. This elegantly solves the issue of double-spend where a single currency unit can be spent twice. Previously, the double-spend problem was a weakness of digital currency and was addressed by clearing all transactions through a central clearinghouse.</p></div>
<div class="paragraph"><p>The bitcoin network started in 2009, based on a reference implementation published by Nakamoto and since revised by many other programmers. The distributed computation that provides security and resilience for bitcoin has increased exponentially and now exceeds that combined processing capacity of the world&#8217;s top super-computers. Bitcoin&#8217;s total market value is estimated at between 5 and 10 billion US dollars, depending on the dollar/bitcoin exchange rate. The largest transaction processed so far by the network was $150 million US dollars, transmitted instantly and processed without any fees.</p></div>
<div class="paragraph"><p>Satoshi Nakamoto withdrew from the public in April of 2011, leaving the responsibility of developing the code and network to a thriving group of volunteers. The name Satoshi Nakamoto is an alias and the identity of the person or people behind this invention is currently unknown. However, neither Satoshi Nakamoto nor anyone else exerts control over the bitcoin system, which operates based on fully transparent mathematical principles. The invention itself is groundbreaking and has already spawned new science in the fields of distributed computing, economics and econometrics.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">A Solution To a Distributed Computing Problem</div>
<div class="paragraph"><p>Satoshi Nakamoto&#8217;s invention is also a practical solution to a previously unsolved problem in distributed computing, known as the Byzantine Generals' Problem. Briefly, the problem consists of trying to agree on a course of action by exchanging information over an unreliable and potentially compromised network. Satoshi Nakamoto&#8217;s solution, which uses the concept of Proof-of-Work to achieve consensus without a central trusted authority represents a breakthrough in distributed computing science and has wide applicability beyond currency. It can be used to achieve consensus on decentralized networks for provably-fair elections, lotteries, asset registries, digital notarization and more.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="user-stories">Bitcoin Uses, Users and Their Stories</h3>
<div class="paragraph"><p>Bitcoin is a technology, but it expresses money which is fundamentally a language for exchanging value between people. Let&#8217;s look at the people who are using bitcoin and some of the most common uses of the currency and protocol through their stories. We will re-use these stories throughout the book to illustrate the real-life uses of digital money and how they are made possible by the various technologies that are part of bitcoin.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
North American Low Value Retail
</dt>
<dd>
<p>
Alice lives in Northern California&#8217;s Bay Area. She has heard about bitcoin from her techie friends and wants to start using it. We will follow her story as she learns about bitcoin, acquires some and then spends some of her bitcoin to buy a cup of coffee at Bob&#8217;s Cafe in Palo Alto. This story will introduce us to the software, the exchanges and basic transactions from the perspective of a retail consumer.
</p>
</dd>
<dt class="hdlist1">
North American High Value Retail
</dt>
<dd>
<p>
Carol is an art gallery owner in San Francisco. She sells expensive paintings for bitcoin. This story will introduce the risks of a "51%" consensus attack for retailers of high-value items.
</p>
</dd>
<dt class="hdlist1">
Offshore Contract Services
</dt>
<dd>
<p>
Bob, the cafe owner in Palo Alto is building a new website. He has contracted with an Indian web developer, Gopesh, who lives in Bangalore, India. Gopesh has agreed to be paid in bitcoin. This story will examine the use of bitcoin for outsourcing, contract services and international wire transfers.
</p>
</dd>
<dt class="hdlist1">
Charitable Donations
</dt>
<dd>
<p>
Eugenia is the director of a children&#8217;s charity in the Philippines. Recently she has discovered bitcoin and wants to use it to reach a whole new group of foreign and domestic donors to fundraise for her charity. She&#8217;s also investigating ways to use bitcoin to distribute funds quickly to areas of need. This story will show the use of bitcoin for global fundraising across currencies and borders and the use of an open ledger for transparency in charitable organizations.
</p>
</dd>
<dt class="hdlist1">
Import/Export
</dt>
<dd>
<p>
Mohammed is an electronics importer in Dubai. He&#8217;s trying to use bitcoin to buy electronics from the USA and China for import into the U.A.E. to accelerate the process of payments for imports. This story will show how bitcoin can be used for large business-to-business international payments tied to physical goods.
</p>
</dd>
<dt class="hdlist1">
Mining for Bitcoin
</dt>
<dd>
<p>
Jing is a computer engineering student in Shanghai. He has built a "mining" rig to mine for bitcoins, using his engineering skills to supplement his income. This story will examine the "industrial" base of bitcoin, the specialized equipment used to secure the bitcoin network and issue new currency.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Each of the stories above is based on real people and real industries that are currently using bitcoin to create new markets, new industries and innovative solutions to global economic issues.</p></div>
</div>
<div class="sect2">
<h3 id="_getting_started">Getting Started</h3>
<div class="paragraph"><p>To join the bitcoin network and start using the currency, all a user has to do is download an application or use a web application. Since bitcoin is a standard, there are many implementations of the bitcoin client software. There is also a "reference implementation", also known as the Satoshi Client, which is managed as an open source project by a team of developers and is derived from the original implementation written by Satoshi Nakamoto.</p></div>
<div class="paragraph"><p>The three primary forms of bitcoin clients are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Full Client
</dt>
<dd>
<p>
A full client, or "full node" is a client that stores the entire history of bitcoin transactions (every transaction by every user, ever), manages the user&#8217;s wallets and can initiate transactions directly on the bitcoin network. This is similar to a standalone email server, in that it handles all aspects of the protocol without relying on any other servers or third party services.
</p>
</dd>
<dt class="hdlist1">
Light Client
</dt>
<dd>
<p>
A lightweight client stores the user&#8217;s wallet but relies on third-party owned servers for access to the bitcoin transactions and network. The light client does not store a full copy of all transactions and therefore must trust the third party servers for transaction validation. This is similar to a standalone email client that connects to a mail server for access to a mailbox, in that it relies on a third party for interactions with the network.
</p>
</dd>
<dt class="hdlist1">
Web Client
</dt>
<dd>
<p>
Web-clients are accessed through a web browser and store the user&#8217;s wallet on a server owned by a third party. This is similar to webmail in that it relies entirely on a third party server.
</p>
</dd>
</dl></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Mobile Bitcoin</div>
<div class="paragraph"><p>Mobile clients for smartphones, such as those based on the Android system, can either operate as full clients, light clients or web clients. Some mobile clients are synchronized with a web or desktop client, providing a multi-platform wallet across multiple devices but with a common source of funds.</p></div>
</div></div>
<div class="paragraph"><p>The choice of bitcoin client depends on how much control the user wants over funds. A full client will offer the highest level of control and independence for the user, but in turn puts the burden of backups and security on the user. On the other end of the range of choices, a web client is the easiest to set up and use, but the tradeoff with a web client is that counterparty risk is introduced because security and control is shared by the user and the owner of the web service. If a web-wallet service is compromised, as many have been, the users can lose all their funds. Conversely, if a user has a full client without adequate backups, they may lose their funds through a computer mishap.</p></div>
<div class="paragraph"><p>For the purposes of this book, we will be demonstrating the use of a variety of bitcoin clients, from the reference implementation (the Satoshi client) to web-wallets. Some of the examples will require the use of the reference client which exposes APIs to the wallet, network and transaction services. If you are planning to explore the programmatic interfaces into the bitcoin system, you will need the reference client.</p></div>
<div class="sect3">
<h4 id="_quick_start">Quick Start</h4>
<div class="paragraph"><p>Alice, who we introduced in <a href="#user-stories">[user-stories]</a>, is not a technical user and only recently heard about bitcoin from a friend. She starts her journey by visiting the official website bitcoin.org, where she finds a broad selection of bitcoin clients. Following the advice on the bitcoin.org site, she chooses the lightweight bitcoin client <em>Multibit</em>.</p></div>
<div class="paragraph"><p>Alice follows a link from the bitcoin.org site to download and install Multibit on her desktop. Multibit is available for Windows, Mac OS and Linux desktops.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>A bitcoin wallet must be protected by a password or passphrase. There are many bad actors attempting to break weak passwords, so take care to select one that cannot be easily broken. Use a combination of upper and lower-case characters, numbers and symbols. Avoid personal information such as birth-dates or names of sports teams. Avoid any words commonly found in dictionaries, in any language. If you can, use a password generator to create a completely random password that is at least 12 characters in length. Remember: bitcoin is money and can be instantly moved anywhere in the world. If it is not well protected, it can be easily stolen.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Once Alice has downloaded and installed the Multibit application, she runs it and is greeted by a "welcome" screen:</p></div>
<div class="imageblock" id="multibit-welcome">
<div class="content">
<img src="images/MultibitWelcome.png" alt="MultibitWelcome" />
</div>
<div class="title">Figure 1. The Multibit Bitcoin Client - Welcome Screen</div>
</div>
<div class="paragraph"><p>Multibit automatically creates a wallet and a new bitcoin address for Alice, which Alice can see by clicking on the "Request" tab:</p></div>
<div class="imageblock" id="multibit-request">
<div class="content">
<img src="images/MultibitReceive.png" alt="MultibitReceive" />
</div>
<div class="title">Figure 2. Alice&#8217;s new bitcoin address, in the "Request" tab of the Multibit client</div>
</div>
<div class="paragraph"><p>The most important part of this screen is Alice&#8217;s <em>bitcoin address</em>. Like an email address, Alice can share this address and anyone can use it to send money directly to her new wallet. On the screen it appears as a long string of letters and numbers: <code>1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</code>. Next to the wallet&#8217;s bitcoin address, there is a QR code, a form of barcode that contains the same information in a format that can be easily scanned by a smartphone&#8217;s camera. The QR code is the black and white square on the right side of the window. Alice can copy the bitcoin address or the QR code onto her clipboard by clicking on the copy button adjacent to each of them. Clicking on the QR code itself will magnify it, so that it can be easily scanned by a smartphone camera.</p></div>
<div class="paragraph"><p>Alice can also print the QR code as a way to easily give her address to others without them having to type the long string of letters and numbers.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Bitcoin addresses start with the digit "1" or "3". Like email addresses, they can be shared with other bitcoin users who can use them to send bitcoin directly to your wallet. Unlike email addresses, you can create new addresses as often as you like, all of which will direct funds to your wallet. A wallet is simply a collection of addresses and the keys that unlock the funds within. There is practically no limit to the number of addresses a user can create.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Alice is now ready to start using her new bitcoin wallet.</p></div>
</div>
<div class="sect3">
<h4 id="getting_first_bitcoin">Getting your first bitcoins</h4>
<div class="paragraph"><p>It is not possible to buy bitcoins at a bank or foreign exchange kiosks at this time. As of 2014, it is still quite difficult to acquire bitcoins in most countries. There are a number of specialized currency exchanges where you can buy and sell bitcoin in exchange for a local currency. These operate as web-based currency markets and include:</p></div>
<div class="ulist"><ul>
<li>
<p>
Bitstamp (bitstamp.net), a European currency market that supports several currencies including euros (EUR) and US dollars (USD) via wire transfer
</p>
</li>
<li>
<p>
Coinbase (coinbase.com), a US-based bitcoin wallet and platform where merchants and consumers can transact in bitcoin. Coinbase makes it easy to buy and sell bitcoin, allowing users to connect to US checking accounts via the ACH system.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Crypto-currency exchanges such as these operate at the intersection of national currencies and crypto-currencies. As such, they are subject to national and international regulations and are often specific to a single country or economic area and specialize in the national currencies of that area. Your choice of currency exchange will be specific to the national currency you use and limited to the exchanges that operate within the legal jurisdiction of your country.  Similar to opening a bank account, it takes several days or weeks to set up the necessary accounts with the above services because they require various forms of identification to comply with KYC (Know Your Customer) and AML (Anti-Money Laundering) banking regulations. Once you have an account on a bitcoin exchange, you can then buy or sell bitcoins quickly just as you could with foreign currency with a brokerage account.</p></div>
<div class="paragraph"><p>A more complete list can be found at <a href="http://bitcoincharts.com/markets/">http://bitcoincharts.com/markets/</a>, a site that offers price quotes and other market data across many dozens of currency exchanges.</p></div>
<div class="paragraph"><p>There are three other methods for getting bitcoins as a new user:</p></div>
<div class="ulist"><ul>
<li>
<p>
Find a friend who has bitcoins and buy some from them directly. Many bitcoin users started this way.
</p>
</li>
<li>
<p>
Use a classified service like localbitcoins.com to find a seller in your area to buy bitcoins for cash in an in-person transaction.
</p>
</li>
<li>
<p>
Sell a product or service for bitcoin. If you&#8217;re a programmer, sell your programming skills. If you have an online store, see <a href="#bitcoin-commerce">[bitcoin-commerce]</a> to sell in bitcoin.
</p>
</li>
<li>
<p>
Use a bitcoin ATM in your city.  A map of bitcoin ATMs can be found at <a href="http://www.coindesk.com/bitcoin-atm-map/">http://www.coindesk.com/bitcoin-atm-map/</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Alice was introduced to bitcoin by a friend and so she has an easy way of getting her first bitcoin while she waits for her account on a California currency market to be verified and activated.</p></div>
</div>
<div class="sect3">
<h4 id="sending_receiving">Sending and receiving bitcoins</h4>
<div class="paragraph"><p>Alice has created her bitcoin wallet and she is now ready to receive funds. Her wallet application randomly generated a private key (described in more detail in <a href="#private_keys">[private_keys]</a>) together with its corresponding bitcoin address. At this point, her bitcoin address is not known to the bitcoin network or "registered" with any part of the bitcoin system. Her bitcoin address is simply a number that corresponds to a key that she can use to control access to the funds. There is no account or association between that address and an account. Until the moment this address is referenced as the recipient of value in a transaction posted on the bitcoin ledger (the blockchain), it is simply part of the vast number of possible addresses that are "valid" in bitcoin. Once it has been associated with a transaction, it becomes part of the known addresses in the network and Alice can check its balance on the public ledger.</p></div>
<div class="paragraph"><p>Alice meets her friend Joe who introduced her to bitcoin at a local restaurant so they can exchange some US dollars and put some bitcoins into her account. She has brought a printout of her address and the QR code as displayed in her bitcoin wallet. There is nothing sensitive, from a security perspective, about the bitcoin address. It can be posted anywhere without risking the security of her account.</p></div>
<div class="paragraph"><p>Alice wants to convert just $10 US dollars into bitcoin, so as not to risk too much money on this new technology. She gives Joe a $10 bill and the printout of her address so that Joe can send her the equivalent amount of bitcoin.</p></div>
<div class="paragraph"><p>Next, Joe has to figure out the exchange rate so that he can give the correct amount of bitcoin to Alice. There are hundreds of applications and web sites that can provide the current market rate, here are some of the most popular:</p></div>
<div class="ulist"><ul>
<li>
<p>
bitcoincharts.com, a market data listing service that shows the market rate of bitcoin across many exchanges around the globe, denominated in different local currencies
</p>
</li>
<li>
<p>
bitcoinaverage.com, a site that provides a simple view of the volume-weighted-average for each currency
</p>
</li>
<li>
<p>
ZeroBlock, a free Android and iOS application that can display a bitcoin price from different exchanges
</p>
</li>
<li>
<p>
bitcoinwisdom.com, another market data listing service
</p>
</li>
</ul></div>
<div class="imageblock" id="zeroblock-android">
<div class="content">
<img src="images/zeroblock.png" alt="zeroblock screenshot" />
</div>
<div class="title">Figure 3. ZeroBlock - A bitcoin market-rate application for Android and iOS</div>
</div>
<div class="paragraph"><p>Using one of the applications or websites above, Joe determines the price of bitcoin to be approximately $100 US dollars per bitcoin. At that rate he should give Alice 0.10 bitcoin, also known as 100 milliBits, in return for the $10 US dollars she gave him.</p></div>
<div class="paragraph"><p>Once Joe has established a fair exchange price, he opens his mobile wallet application and selects to "send" bitcoin. He is presented with a screen requesting two inputs:</p></div>
<div class="ulist"><ul>
<li>
<p>
The destination bitcoin address for the transaction
</p>
</li>
<li>
<p>
The amount of bitcoin to send
</p>
</li>
</ul></div>
<div class="imageblock" id="blockchain-mobile-send">
<div class="content">
<img src="images/blockchain-mobile-send.png" alt="blockchain mobile send screen" />
</div>
<div class="title">Figure 4. Bitcoin mobile wallet - Send bitcoin screen</div>
</div>
<div class="paragraph"><p>In the input field for the bitcoin address, there is a small icon that looks like a QR code. This allows Joe to scan the barcode with his smartphone camera so that he doesn&#8217;t have to type in Alice&#8217;s bitcoin address (<code>1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</code>), which is quite long and difficult to type. Joe taps on the QR code icon and activates the smartphone camera, scanning the QR code from Alice&#8217;s printed wallet that she brought with her. The mobile wallet application fills in the bitcoin address and Joe can check that it scanned correctly by comparing a few digits from the address with the address printed by Alice.</p></div>
<div class="paragraph"><p>Joe then enters the bitcoin value for the transaction, 0.10 bitcoin. He carefully checks to make sure he has entered the correct amount, as he is about to transmit money and any mistake could be costly. Finally, he presses "Send" to transmit the transaction. Joe&#8217;s mobile bitcoin wallet constructs a transaction that assigns 0.10 bitcoin to the address provided by Alice, sourcing the funds from Joe&#8217;s wallet and signing the transaction with Joe&#8217;s private keys. This tells the bitcoin network that Joe has authorized a transfer of value from one of his addresses to Alice&#8217;s new address. As the transaction is transmitted via the peer-to-peer protocol, it quickly propagates across the bitcoin network. In less than a second, most of the well-connected nodes in the network receive the transaction and see Alice&#8217;s address for the first time.</p></div>
<div class="paragraph"><p>If Alice has a smartphone or laptop with her, she will also be able to see the transaction. The bitcoin ledger - a constantly growing file that records every bitcoin transaction that has ever occurred - is public, meaning that all she has to do is look up her own address and see if any funds have been sent to it. She can do this quite easily at the blockchain.info website by entering her address in the search box. The website will show her a page (<a href="https://blockchain.info/address/1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK">https://blockchain.info/address/1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</a>) listing all the transactions to and from that address. If Alice is watching that page, it will update to show a new transaction transferring 0.10 bitcoin to her balance soon after Joe hits "Send".</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Confirmations</div>
<div class="paragraph"><p>At first, Alice&#8217;s address will show the transaction from Joe as "Unconfirmed". This means that the transaction has been propagated to the network but has not yet been included in the bitcoin transaction ledger, known as the blockchain. To be included, the transaction must be "picked up" by a miner and included in a block of transactions. Once a new block is created, in approximately 10 minutes, the transactions within the block will be accepted as "confirmed" by the network and can be spent. The transaction is seen by all instantly, but it is only "trusted" by all when it is included in a newly mined block.</p></div>
</div></div>
<div class="paragraph"><p>Alice is now the proud owner of 0.10 bitcoin which she can spend. In the next chapter we will look at her first purchase with bitcoin and examine the underlying transaction and propagation technologies in more detail.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch02_bitcoin_overview">How Bitcoin Works</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_transactions_blocks_mining_and_the_blockchain">Transactions, Blocks, Mining, and the Blockchain</h3>
<div class="paragraph"><p>The bitcoin system, unlike traditional banking and payment systems, is based on de-centralized trust. Instead of a central trusted authority, in bitcoin, trust is achieved as an emergent property from the interactions of different participants in the bitcoin system. In this chapter we will examine bitcoin from a high-level by tracking a single transaction through the bitcoin system and watch as it becomes "trusted" and accepted by the bitcoin mechanism of distributed consensus and is finally recorded on the blockchain, the distributed ledger of all transactions.</p></div>
<div class="paragraph"><p>Each example below is based upon an actual transaction made on the bitcoin network, simulating the interactions between the users (Joe, Alice and Bob) by sending funds from one wallet to another. While tracking a transaction through the bitcoin network and blockchain, we will use a <em>blockchain explorer</em> site to visualize each step. A blockchain explorer is a web application that operates as a bitcoin search engine, in that it allows you to search for addresses, transactions and blocks and see the relationships and flows between them.</p></div>
<div class="paragraph"><p>Popular blockchain explorers include:</p></div>
<div class="ulist"><ul>
<li>
<p>
blockchain.info
</p>
</li>
<li>
<p>
blockexplorer.com
</p>
</li>
<li>
<p>
insight.bitpay.com
</p>
</li>
<li>
<p>
blockr.io
</p>
</li>
</ul></div>
<div class="paragraph"><p>Each of these has a search function that can take an address, transaction hash or block number and find the equivalent data on the bitcoin network and blockchain. With each example, we will provide a URL that takes you directly to the relevant entry, so you can study it in detail.</p></div>
<div class="sect3">
<h4 id="_bitcoin_overview">Bitcoin Overview</h4>
<div class="paragraph"><p>In the overview diagram below, we see that the bitcoin system consists of users with wallets containing keys, transactions which are propagated across the network and miners who produce (through competitive computation) the consensus blockchain, the authoritative ledger of all transactions. In this chapter, we will trace a single transaction as it travels across the network and examine the interactions between each part of the bitcoin system, at a high level. Subsequent chapters will delve into the technology behind wallets, mining and merchant systems.</p></div>
<div class="imageblock" id="bitcoin-overview">
<div class="content">
<img src="images/Bitcoin_Overview.png" alt="Bitcoin Overview" />
</div>
<div class="title">Figure 5. Bitcoin Overview</div>
</div>
</div>
<div class="sect3">
<h4 id="cup_of_coffee">Buying a cup of coffee</h4>
<div class="paragraph"><p>Alice, introduced in the previous chapter, is a new user who has just acquired her first bitcoin. In <a href="#getting_first_bitcoin">[getting_first_bitcoin]</a>, Alice met with her friend Joe to exchange some cash for bitcoin. The transaction created by Joe, funded Alice&#8217;s wallet with 0.10 BTC. Now Alice will make her first retail transaction, buying a cup of coffee at Bob&#8217;s coffee shop in Palo Alto, California. Bob&#8217;s coffee shop recently started accepting bitcoin payments, by adding a bitcoin option to his point-of-sale system. The prices at Bob&#8217;s Cafe are listed in the local currency (US dollars) but at the register, customers have the option of paying in either dollars or bitcoin. Alice places her order for a cup of coffee and Bob enters the transaction at the register. The point-of-sale system will convert the total price from US dollars to bitcoins at the prevailing market rate and display the prices in both currencies, as well as showing a QR code containing a <em>payment request</em> for this transaction:</p></div>
<div class="listingblock">
<div class="title">Displayed on Bob&#8217;s cash register</div>
<div class="content">
<pre><code>Total:
$1.50 USD
0.015 BTC</code></pre>
</div></div>
<div class="imageblock" id="payment-request-QR">
<div class="content">
<img src="images/payment-request-qr.png" alt="payment-request" />
</div>
<div class="title">Figure 6. Payment Request QR Code - Hint: Try to scan this!</div>
</div>
<div class="listingblock" id="payment-request-URL">
<div class="title">The payment request QR code above encodes the following URL, defined in BIP0021</div>
<div class="content">
<pre><code>bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?\
amount=0.015&amp;\
label=Bob%27s%20Cafe&amp;\
message=Purchase%20at%20Bob%27s%20Cafe

Components of the URL

A bitcoin address: "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"
The payment amount: "0.015"
A label for the recipient address: "Bob's Cafe"
A description for the payment: "Purchase at Bob's Cafe"</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Unlike a QR code that simply contains a destination bitcoin address, a "payment request" is a QR encoded URL that contains a destination address, a payment amount and a generic description such as "Bob&#8217;s Cafe". This allows a bitcoin wallet application to pre-fill the information used to send the payment while showing a human-readable description to the user. You can scan the QR code above with a bitcoin wallet application to see what Alice would see.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Bob says "That&#8217;s one-dollar-fifty, or fifteen milliBits".</p></div>
<div class="paragraph"><p>Alice uses her smartphone to scan the barcode on display. Her smartphone shows a payment of <code>0.0150 BTC</code> to <code>Bob&#8217;s Cafe</code> and she selects <code>Send</code> to authorize the payment. Within a few seconds (about the same time as a credit card authorization), Bob would see the transaction on the register, completing the transaction.</p></div>
<div class="paragraph"><p>In the following sections we will examine this transaction in more detail, see how Alice&#8217;s wallet constructed it, how it was propagated across the network, how it was verified and finally how Bob, the owner of the cafe, can spend that amount in subsequent transactions.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>The bitcoin network can transact in fractional values, e.g. from milli-bitcoins (1/1000th of a bitcoin) down to 1/100,000,000th of a bitcoin, which is known as a Satoshi.  Throughout this book we’ll use the term “bitcoins” to refer to any quantity of bitcoin currency, from the smallest unit (1 Satoshi) to the total number (21,000,000) of all bitcoins that will ever be mined.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_transactions">Bitcoin Transactions</h3>
<div class="paragraph"><p>In simple terms, a transaction tells the network that the owner of a number of bitcoins has authorized the transfer of some of those bitcoins to another owner. The new owner can now spend these bitcoins by creating another transaction that authorizes transfer to another owner, and so on, in a chain of ownership.</p></div>
<div class="paragraph"><p>Transactions are like lines in a double-entry bookkeeping ledger. In simple terms, each transaction contains one or more "inputs", which are debits against a bitcoin account. On the other side of the transaction, there are one or more "outputs", which are credits added to a bitcoin account. The inputs and outputs (debits and credits) do not necessarily add up to the same amount. Instead, outputs add up to slightly less than inputs and the difference represents an implied "transaction fee", a small payment collected by the miner who includes the transaction in the ledger.</p></div>
<div class="imageblock" id="transaction-double-entry">
<div class="content">
<img src="images/Transaction_Double_Entry.png" alt="Transaction Double-Entry" />
</div>
<div class="title">Figure 7. Transaction as Double-Entry Bookkeeping</div>
</div>
<div class="paragraph"><p>The transaction also contains proof of ownership for each amount of bitcoin (inputs) whose value is transferred, in the form of a digital signature from the owner, which can be independently validated by anyone. In bitcoin terms, "spending" is signing a transaction which transfers value from a previous transaction over to a new owner identified by a bitcoin address.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p><em>Transactions</em> move value <strong>from</strong> <em>transaction inputs</em> <strong>to</strong> <em>transaction outputs</em>. An input is where the coin value is coming from, usually a previous transaction&#8217;s output. A transaction output assigns a new owner to the value by associating it with a key. The destination key is called an <em>encumbrance</em>. It imposes a requirement for a signature for the funds to be redeemed in future transactions. Outputs from one transaction can be used as inputs in a new transaction, thus creating a chain of ownership as the value is moved from address to address.</p></div>
</td>
</tr></table>
</div>
<div class="imageblock" id="blockchain-mnemonic">
<div class="content">
<img src="images/Transaction_Chain.png" alt="Transaction chain" />
</div>
<div class="title">Figure 8. A chain of transactions, where the output of one transaction is the input of the next transaction</div>
</div>
<div class="paragraph"><p>Alice&#8217;s payment to Bob&#8217;s Cafe utilizes a previous transaction as its input. In the previous chapter Alice received bitcoin from her friend Joe in return for cash. That transaction has a number of bitcoins locked (encumbered) against Alice&#8217;s key. Her new transaction to Bob&#8217;s Cafe references the previous transaction as an input and creates new outputs to pay for the cup of coffee and receive change. The transactions form a chain, where the inputs from the latest transaction correspond to outputs from previous transactions. Alice&#8217;s key provides the signature which unlocks those previous transaction outputs, thereby proving to the bitcoin network that she owns the funds. She attaches the payment for coffee to Bob&#8217;s address, thereby "encumbering" that output with the requirement that Bob produces a signature in order to spend that amount. This represents a transfer of value between Alice and Bob.</p></div>
<div class="sect3">
<h4 id="_common_transaction_forms">Common Transaction Forms</h4>
<div class="paragraph"><p>The most common form of transaction is a simple payment from one address to another, which often includes some "change" returned to the original owner. This type of transaction has one input and two outputs and is shown below:</p></div>
<div class="imageblock" id="transaction-common">
<div class="content">
<img src="images/Bitcoin_Transaction_Structure_Common.png" alt="Common Transaction" />
</div>
<div class="title">Figure 9. Most Common Transaction</div>
</div>
<div class="paragraph"><p>Another common form of transaction is a transaction that aggregates several inputs into a single output. This represents the real-world equivalent of exchanging a pile of coins and currency notes for a single larger note. Transactions like these are sometimes generated by wallet applications to clean up lots of smaller amounts that were received as change for payments.</p></div>
<div class="imageblock" id="transaction-aggregating">
<div class="content">
<img src="images/Bitcoin_Transaction_Structure_Aggregating.png" alt="Aggregating Transaction" />
</div>
<div class="title">Figure 10. Transaction Aggregating Funds</div>
</div>
<div class="paragraph"><p>Finally, another transaction form that is seen often on the bitcoin ledger is a transaction that distributes one input to multiple outputs representing multiple recipients. This type of transaction is sometimes used by commercial entities to distribute funds, such as when processing payroll payments to multiple employees.</p></div>
<div class="imageblock" id="transaction-distributing">
<div class="content">
<img src="images/Bitcoin_Transaction_Structure_Distribution.png" alt="Distributing Transaction" />
</div>
<div class="title">Figure 11. Transaction Distributing Funds</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_a_transaction">Constructing a Transaction</h3>
<div class="paragraph"><p>Alice&#8217;s wallet application contains all the logic for selecting appropriate inputs and outputs to build a transaction to Alice&#8217;s specification. Alice only needs to specify a destination and an amount and the rest happens in the wallet application without her seeing the details. Importantly, a wallet application can construct transactions even if it is completely offline. Like writing a cheque at home and later sending it to the bank in an envelope, the transaction does not need to be constructed and signed while connected to the bitcoin network. It only has to be sent to the network eventually for it to be executed.</p></div>
<div class="sect3">
<h4 id="_getting_the_right_inputs">Getting the right inputs</h4>
<div class="paragraph"><p>Alice&#8217;s wallet application will first have to find inputs that can pay for the amount she wants to send to Bob. Most wallet applications keep a small database of "unspent transaction outputs" that are locked (encumbered) with the wallet&#8217;s own keys. Therefore, Alice&#8217;s wallet would contain a copy of the transaction output from Joe&#8217;s transaction which was created in exchange for cash (see <a href="#getting_first_bitcoin">[getting_first_bitcoin]</a>). A bitcoin wallet application that runs as a full-index client actually contains a copy of every unspent output from every transaction in the blockchain. This allows a wallet to construct transaction inputs as well as to quickly verify incoming transactions as having correct inputs. However, since a full-index client takes up a lot of disk space, most user wallets run "lightweight" clients that track only the user&#8217;s own unspent outputs.</p></div>
<div class="paragraph"><p>If the wallet application does not maintain a copy of unspent transaction outputs, it can query the bitcoin network to retrieve this information, using a variety of APIs available by different providers, or by asking a full-index node using the bitcoin JSON RPC API. Below we see an example of a RESTful API request, constructed as an HTTP GET command to a specific URL. This URL will return all the unspent transaction outputs for an address, giving any application the information it needs to construct transaction inputs for spending. We use the simple command-line HTTP client <em>cURL</em> to retrieve the response:</p></div>
<div class="listingblock">
<div class="title">Look up all the unspent outputs for Alice&#8217;s bitcoin address</div>
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The response above shows that the bitcoin network knows of one unspent output (one that has not been redeemed yet) under the ownership of Alice&#8217;s address <code>1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK</code>. The response includes the reference to the transaction in which this unspent output is contained (the payment from Joe) and its value in Satoshis, at 10 million, equivalent to 0.10 bitcoin. With this information, Alice&#8217;s wallet application can construct a transaction to transfer that value to new owner addresses.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Use the following link to look up the transaction from Joe to Alice:</p></div>
<div class="paragraph"><p><a href="https://blockchain.info/tx/7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18">https://blockchain.info/tx/7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18</a></p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>As you can see, Alice&#8217;s wallet contains enough bitcoins in a single unspent output to pay for the cup of coffee. Had this not been the case, Alice&#8217;s wallet application might have to "rummage" through a pile of smaller unspent outputs, like picking coins from a purse until it could find enough to pay for coffee. In both cases, there might be a need to get some change back, which we will see in the next section, as the wallet application creates the transaction outputs (payments).</p></div>
</div>
<div class="sect3">
<h4 id="_creating_the_outputs">Creating the outputs</h4>
<div class="paragraph"><p>A transaction output is created in the form of a script that creates an encumbrance on the value and can only be redeemed by the introduction of a solution to the script. In simpler terms, Alice&#8217;s transaction output will contain a script that says something like "This output is payable to whoever can present a signature from the key corresponding to Bob&#8217;s public address". Since only Bob has the wallet with the keys corresponding to that address, only Bob&#8217;s wallet can present such a signature to redeem this output. Alice will therefore "encumber" the output value with a demand for a signature from Bob.</p></div>
<div class="paragraph"><p>This transaction will also include a second output, because Alice&#8217;s funds are in the form of a 0.10 BTC output, too much money for the 0.015 BTC cup of coffee. Alice will need 0.085 BTC in change. Alice&#8217;s change payment is created <em>by Alice&#8217;s wallet</em> in the very same transaction as the payment to Bob. Essentially, Alice&#8217;s wallet breaks her funds into two payments: one to Bob, and one back to herself. She can then use the change output in a subsequent transaction, thus spending it later.</p></div>
<div class="paragraph"><p>Finally, for the transaction to be processed by the network in a timely fashion, Alice&#8217;s wallet application will add a small fee. This is not explicit in the transaction, it is implied by the difference between inputs and outputs. If instead of taking 0.085 in change, Alice creates only 0.0845 as the second output, there will be 0.0005 BTC (half a millibitcoin) left over. The input&#8217;s 0.10 BTC is not fully spent with the two outputs, as they will add up to less than 0.10. The resulting difference is the <em>transaction fee</em> which is collected by the miner as a fee for including the transaction in a block and putting it on the blockchain ledger.</p></div>
<div class="paragraph"><p>The resulting transaction can be seen using a blockchain explorer web application</p></div>
<div class="imageblock" id="transaction-alice">
<div class="content">
<img src="images/AliceCoffeeTransaction.png" alt="Alice Coffee Transaction" />
</div>
<div class="title">Figure 12. Alice&#8217;s transaction to Bob&#8217;s Cafe</div>
</div>
<div class="admonitionblock" id="transaction-alice-url">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Use the following link to look up the transaction from Alice to Bob&#8217;s Cafe:</p></div>
<div class="paragraph"><p><a href="https://blockchain.info/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2">https://blockchain.info/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2</a></p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_adding_the_transaction_to_the_ledger">Adding the transaction to the ledger</h4>
<div class="paragraph"><p>The transaction created by Alice&#8217;s wallet application is 258 bytes long and contains everything necessary to confirm ownership of the funds and assign new owners. Now, the transaction must be transmitted to the bitcoin network where it will become part of the distributed ledger, the blockchain. In the next section we will see how a transaction becomes part of a new block and how the block is "mined". Finally, we will see how the new block, once added to the blockchain is increasingly trusted by the network as more blocks are added.</p></div>
<div class="sect4">
<h5 id="_transmitting_the_transaction">Transmitting the transaction</h5>
<div class="paragraph"><p>Since the transaction contains all the information necessary to process, it does not matter how or where it is transmitted to the bitcoin network. The bitcoin network is a peer-to-peer network, with each bitcoin client participating by connecting to several other bitcoin clients. The purpose of the bitcoin network is to propagate transactions and blocks to all participants.</p></div>
</div>
<div class="sect4">
<h5 id="_how_it_propagates">How it propagates</h5>
<div class="paragraph"><p>Alice&#8217;s wallet application can send the new transaction to any of the other bitcoin clients it is connected to over any Internet connection: wired, WiFi, or mobile. Her bitcoin wallet does not have to be connected to Bob&#8217;s bitcoin wallet directly and she does not have to use the Internet connection offered by the cafe, though both those options are possible too. Any bitcoin network node (other client) that receives a valid transaction it has not seen before, will immediately forward it to other nodes to which it is connected. Thus, the transaction rapidly propagates out across the peer-to-peer network, reaching a large percentage of the nodes within a few seconds.</p></div>
</div>
<div class="sect4">
<h5 id="_bob_8217_s_view">Bob&#8217;s view</h5>
<div class="paragraph"><p>If Bob&#8217;s bitcoin wallet application is directly connected to Alice&#8217;s wallet application, Bob&#8217;s wallet application may be the first node to receive the transaction. However, even if Alice&#8217;s wallet sends the transaction through other nodes, it will reach Bob&#8217;s wallet within a few seconds. Bob&#8217;s wallet will immediately identify Alice&#8217;s transaction as an incoming payment because it contains outputs redeemable by Bob&#8217;s keys. Bob&#8217;s wallet application can also independently verify that the transaction is well-formed, uses previously-unspent inputs and contains sufficient transaction fees to be included in the next block. At this point Bob can assume, with little risk, that the transaction will shortly be included in a block and confirmed.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A common misconception about bitcoin transactions is that they must be "confirmed" by waiting 10 minutes for a new block, or up to sixty minutes for a full six confirmations. While confirmations ensure the transaction has been accepted by the whole network, such a delay is unnecessary for small value items like a cup of coffee. A merchant may accept a valid small-value transaction with no confirmations, with no more risk than a credit card payment made without ID or a signature, like merchants routinely accept today.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_mining">Bitcoin Mining</h3>
<div class="paragraph"><p>The transaction is now propagated on the bitcoin network. It does not become part of the shared ledger (the <em>blockchain</em>) until it is verified and included in a block by a process called <em>mining</em>. See <a href="#mining">[mining]</a> for a detailed explanation.</p></div>
<div class="paragraph"><p>The bitcoin system of trust is based on computation. Transactions are bundled into <em>blocks</em>, which require an enormous amount of computation to prove, but only a small amount of computation to verify as proven. This process is called <em>mining</em> and serves two purposes in bitcoin:</p></div>
<div class="ulist"><ul>
<li>
<p>
Mining creates new bitcoins in each block, almost like a central bank printing new money. The amount of bitcoin created per block is fixed and diminishes with time.
</p>
</li>
<li>
<p>
Mining creates trust by ensuring that transactions are only confirmed if enough computational power was devoted to the block that contains them. More blocks mean more computation which means more trust.
</p>
</li>
</ul></div>
<div class="paragraph"><p>A good way to describe mining is like a giant competitive game of sudoku that resets every time someone finds a solution and whose difficulty automatically adjusts so that it takes approximately 10 minutes to find a solution. Imagine a giant sudoku puzzle, several thousand rows and columns in size. If I show you a completed puzzle you can verify it quite quickly. However, if the puzzle has a few squares filled and the rest is empty, it takes a lot of work to solve! The difficulty of the sudoku can be adjusted by changing its size (more or fewer rows and columns), but it can still be verified quite easily even if it is very large. The "puzzle" used in bitcoin is based on a cryptographic hash and exhibits similar characteristics: it is asymmetrically hard to solve but easy to verify, and its difficulty can be adjusted.</p></div>
<div class="paragraph"><p>In <a href="#user-stories">[user-stories]</a> we introduced Jing, a computer engineering student in Shanghai. Jing is participating in the bitcoin network as a miner. Every 10 minutes or so, Jing joins thousands of other miners in a global race to find a solution to a block of transactions. Finding such a solution, the so-called "Proof-of-Work", requires quadrillions of hashing operations per second across the entire bitcoin network. The algorithm for "Proof-of-Work" involves repeatedly hashing the header of the block and a random number with the SHA256 cryptographic algorithm until a solution matching a pre-determined pattern emerges. The first miner to find such a solution wins the round of competition and publishes that block into the blockchain.</p></div>
<div class="paragraph"><p>Jing started mining in 2010 using a very fast desktop computer to find a suitable Proof-of-Work for new blocks. As more miners started joining the bitcoin network, the difficulty of the problem increased rapidly. Soon, Jing and other miners upgraded to more specialized hardware, such as Graphical Processing Units (GPUs), as used in gaming desktops or consoles. As this book is written, by 2014, the difficulty is so high that it is only profitable to mine with Application Specific Integrated Circuits (ASIC), essentially hundreds of mining algorithms printed in hardware, running in parallel on a single silicon chip. Jing also joined a "mining pool", which much like a lottery-pool allows several participants to share their efforts and the rewards. Jing now runs two USB-connected ASIC machines to mine for bitcoin 24 hours a day. He pays his electricity costs by selling the bitcoin he is able to generate from mining, creating some income from the profits. His computer runs a copy of bitcoind, the reference bitcoin client, as a back-end to his specialized mining software.</p></div>
</div>
<div class="sect2">
<h3 id="_mining_transactions_in_blocks">Mining transactions in blocks</h3>
<div class="paragraph"><p>A transaction transmitted across the network is not verified until it becomes part of the global distributed ledger, the blockchain. Every ten minutes on average, miners generate a new block that contains all the transactions since the last block. New transactions are constantly flowing into the network from user wallets and other applications. As these are seen by the bitcoin network nodes, they get added to a temporary "pool" of unverified transactions maintained by each node. As miners build a new block, they add unverified transactions from this pool to a new block and then attempt to solve a very hard problem (aka Proof-of-Work) to prove the validity of that new block. The process of mining is explained in detail in <a href="#mining">[mining]</a>.</p></div>
<div class="paragraph"><p>Transactions are added to the new block, prioritized by the highest-fee transactions first and a few other criteria. Each miner starts the process of mining a new block of transactions as soon as they receive the previous block from the network, knowing they have lost that previous round of competition. They immediately create a new block, fill it with transactions and the fingerprint of the previous block and start calculating the Proof-of-Work for the new block. Each miner includes a special transaction in their block, one that pays their own bitcoin address a reward of newly created bitcoins (currently 25 BTC per block). If they find a solution that makes that block valid, they "win" this reward because their successful block is added to the global blockchain and the reward transaction they included becomes spendable. Jing, who participates in a mining pool, has set up his software to create new blocks that assign the reward to a pool address. From there, a share of the reward is distributed to Jing and other miners in proportion to the amount of work they contributed in the last round.</p></div>
<div class="paragraph"><p>Alice&#8217;s transaction was picked up by the network and included in the pool of unverified transactions. Since it had sufficient fees, it was included in a new block generated by Jing&#8217;s mining pool. Approximately 5 minutes after the transaction was first transmitted by Alice&#8217;s wallet, Jing&#8217;s ASIC miner found a solution for the block and published it as block #277316, containing 419 other transactions. Jing&#8217;s ASIC miner published the new block on the bitcoin network, where other miners validated it and started the race to generate the next block.</p></div>
<div class="paragraph"><p>You can see the block that includes Alice&#8217;s transaction here:
<a href="https://blockchain.info/block-height/277316">https://blockchain.info/block-height/277316</a></p></div>
<div class="paragraph"><p>A few minutes later, a new block, #277317 is mined by another miner. As this new block is based on the previous block (#277316) that contained Alice&#8217;s transaction, it added even more computation on top of that block, thereby strengthening the trust in those transactions. One block mined on top of the one containing the transaction is called "one confirmation" for that transaction. As the blocks pile on top of each other, it becomes exponentially harder to reverse the transaction, thereby making it more and more trusted by the network.</p></div>
<div class="paragraph"><p>In the diagram below we can see block #277316, which contains Alice&#8217;s transaction. Below it are 277,316 blocks (including block #0), linked to each other in a chain of blocks (blockchain) all the way back to block #0, the genesis block. Over time, as the "height" in blocks increases, so does the computation difficulty for each block and the chain as a whole. The blocks mined after the one that contains Alice&#8217;s transaction act as further assurance, as they pile on more computation in a longer and longer chain. The blocks above count as "confirmations". By convention, any block with more than 6 confirmations is considered irrevocable, as it would require an immense amount of computation to invalidate and re-calculate six blocks. We will examine the process of mining and the way it builds trust in more detail in <a href="#mining">[mining]</a>.</p></div>
<div class="imageblock" id="block-alice">
<div class="content">
<img src="images/Blockchain_height_and_depth.png" alt="Alice's transaction included in a block" />
</div>
<div class="title">Figure 13. Alice&#8217;s transaction included in block #277,316</div>
</div>
</div>
<div class="sect2">
<h3 id="_spending_the_transaction">Spending the transaction</h3>
<div class="paragraph"><p>Now that Alice&#8217;s transaction has been embedded in the blockchain as part of a block, it is part of the distributed ledger of bitcoin and visible to all bitcoin applications. Each bitcoin client can independently verify the transaction as valid and spendable. Full-index clients can track the source of the funds from the moment the bitcoins were first generated in a block, incrementally from transaction to transaction, until they reach Bob&#8217;s address. Lightweight clients can do a Simplified Payment Verification (See <a href="#spv_nodes">[spv_nodes]</a>) by confirming that the transaction is in the blockchain and has several blocks mined after it, thus providing assurance that the network accepts it as valid.</p></div>
<div class="paragraph"><p>Bob can now spend the output from this and other transactions, by creating his own transactions that reference these outputs as their inputs and assign them new ownership. For example, Bob can pay a contractor or supplier by transferring value from Alice&#8217;s coffee cup payment to these new owners. Most likely, Bob&#8217;s bitcoin software will aggregate many small payments into a larger payment, perhaps concentrating all the day&#8217;s bitcoin revenue into a single transaction. This would move the various payments into a single address, utilized as the store&#8217;s general "checking" account. For a diagram of an aggregating transaction, see <a href="#transaction-aggregating">[transaction-aggregating]</a>.</p></div>
<div class="paragraph"><p>As Bob spends the payments received from Alice and other customers, he extends the chain of transactions which in turn are added to the global blockchain ledger for all to see and trust. Let&#8217;s assume that Bob pays his web designer Gopesh in Bangalore for a new web site page. Now the chain of transactions will look like this:</p></div>
<div class="imageblock" id="block-alice">
<div class="content">
<img src="images/Alices_Transaction_Chain.png" alt="Alice's transaction as part of a transaction chain" />
</div>
<div class="title">Figure 14. Alice&#8217;s transaction as part of a transaction chain from Joe to Gopesh</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch03_bitcoin_client">The Bitcoin Client</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bitcoin_core_the_reference_implementation">Bitcoin Core - The reference implementation</h3>
<div class="paragraph"><p>You can download the Reference Client <em>Bitcoin Core</em>, also known as the "Satoshi client", from bitcoin.org. The reference client implements all aspects of the bitcoin system, including wallets, a transaction verification engine with a full copy of the entire transaction ledger (blockchain) and a full network node in the peer-to-peer bitcoin network.</p></div>
<div class="paragraph"><p>Go to <a href="http://bitcoin.org/en/choose-your-wallet">http://bitcoin.org/en/choose-your-wallet</a> and select "Bitcoin Core" to download the reference client. Depending on your operating system, you will download an executable installer. For Windows, this is either a ZIP archive or an EXE executable. For Mac OS it is a DMG disk image. Linux versions include a PPA package for Ubuntu or a TAR.GZ archive.</p></div>
<div class="imageblock" id="bitcoin-choose-client">
<div class="content">
<img src="images/bitcoin-choose-client.png" alt="bitcoin choose client" />
</div>
<div class="title">Figure 15. Bitcoin - Choose A Bitcoin Client</div>
</div>
<div class="sect3">
<h4 id="_running_bitcoin_core_for_the_first_time">Running Bitcoin Core for the first time</h4>
<div class="paragraph"><p>If you download an installable package, such as an EXE, DMG or PPA, you can install it the same way as any application on your operating system. For Windows, run the EXE and follow the step-by-step instructions. For Mac OS, launch the DMG and drag the Bitcoin-QT icon into your Applications folder. For Ubuntu, double-click on the PPA in your File Explorer and it will open the package manager to install the package. Once you have completed installation you should have a new application "Bitcoin-Qt" in your application list. Double-click on the icon to start the bitcoin client.</p></div>
<div class="paragraph"><p>The first time you run Bitcoin Core it will start downloading the blockchain, a process that may take several days. Leave it running in the background until it displays "Synchronized" and no longer shows "Out of sync" next to the balance.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Bitcoin Core keeps a full copy of the transaction ledger (blockchain), with every transaction that has ever occurred on the bitcoin network since its inception in 2009. This dataset is several gigabytes in size (approximately 16GB in late 2013) and is downloaded incrementally over several days. The client will not be able to process transactions or update account balances until the full blockchain dataset is downloaded. During that time, the client will display "Out of sync" next to the account balances and show "Synchronizing" in the footer. Make sure you have enough disk space, bandwidth and time to complete the initial synchronization.</p></div>
</td>
</tr></table>
</div>
<div class="imageblock" id="bitcoin-qt-firstload">
<div class="content">
<img src="images/bitcoin-qt-firstload.png" alt="bitcoin-qt first run" />
</div>
<div class="title">Figure 16. Bitcoin Core - The Graphical User Interface, during the blockchain initialization</div>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_bitcoin_core_from_the_source_code">Compiling Bitcoin Core from the source code</h4>
<div class="paragraph"><p>For developers, there is also the option to download the full source code as a ZIP archive or by cloning the authoritative source repository from Github. Go to <a href="https://github.com/bitcoin/bitcoin">https://github.com/bitcoin/bitcoin</a> and select "Download ZIP" from the sidebar. Alternatively, use the git command line to create a local copy of the source code on your system. In the example below, we are cloning the source code from a unix-like command-line, in Linux or Mac OS:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The instructions and resulting output may vary from version to version. Follow the documentation that comes with the code even if it differs from the instructions you see here and don&#8217;t be surprised if the output displayed on your screen is slightly different from the examples here.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>When the git cloning operation has completed, you will have a complete local copy of the source code repository in the directory <em>bitcoin</em>. Change to this directory by typing <code>cd bitcoin</code> at the prompt:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>By default, the local copy will be synchronized with the most recent code, which may be an unstable or "beta" version of bitcoin. Before compiling the code, we want to select a specific version by checking out a release <em>tag</em>. This will synchronize the local copy with a specific snapshot of the code repository identified by a keyword tag. Tags are used by the developers to mark specific releases of the code by version number. First, to find the available tags, we use the <code>git tag</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The list of tags shows all the released versions of bitcoin. By convention, <em>release candidates</em>, which are intended for testing, have the suffix "rc". Stable releases that can be run on production systems have no suffix. From the list above, we select the highest version release, which at this time is v0.9.0rc1. To synchronize the local code with this version, we use the <code>git checkout</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The source code includes documentation, which can be found in a number of files. Review the main documentation located in README.md in the bitcoin directory by typing <code>more README.md</code> at the prompt and using the space bar to progress to the next page. In this chapter we will build the command-line bitcoin client, also known as <code>bitcoind</code> on Linux. Review the instructions for compiling the bitcoind command-line client on your platform by typing <code>more doc/build-unix.md</code>. Alternative instructions for Mac OSX and Windows can be found in the doc directory, as <code>build-os.md</code> or <code>build-msw.md</code> respectively.</p></div>
<div class="paragraph"><p>Carefully review the build pre-requisites which are in the first part of the build documentation. These are libraries that must be present on your system before you can begin to compile bitcoin. If these pre-requisites are missing the build process will fail with an error. If this happens because you missed a pre-requisite, you can install it and then resume the build process from where you left off. Assuming the pre-requisites are installed, we start the build process by generating a set of build scripts using the <code>autogen.sh</code> script.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The Bitcoin Core build process was changed to use the autogen/configure/make system starting with version 0.9. Older versions use a simple Makefile and work slightly differently from the example below. Follow the instructions for the version you want to compile. The autogen/configure/make introduced in 0.9 is likely to be the build system used for all future versions of the code and is the system demonstrated in the examples below.</p></div>
</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>autogen.sh</code> script creates a set of automatic configuration scripts that will interrogate your system to discover the correct settings and ensure you have all the necessary libraries to compile the code. The most important of these is the <code>configure</code> script that offers a number of different options to customize the build process. Type <code>./configure --help</code> to see the various options:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>configure</code> script allows you to enable or disable certain features of bitcoind through the use of the <code>--enable-FEATURE</code> and <code>--disable-FEATURE</code> flags, where <code>FEATURE</code> is replaced by the feature name, as listed in the help output above. In this chapter, we will build the bitcoind client with all the default features. We won&#8217;t be using the configuration flags, but you should review them to understand what optional features are part of the client. Next, we run the <code>configure</code> script to automatically discover all the necessary libraries and create a customized build script for our system:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>If all goes well, the <code>configure</code> command will end by creating the customized build scripts that will allow us to compile bitcoind. If there are any missing libraries or errors, the <code>configure</code> command will terminate with an error instead of creating the build scripts as shown above. If an error occurs, it is most likely a missing or incompatible library. Review the build documentation again and make sure you install the missing pre-requisites. Then run <code>configure</code> again and see if that fixes the error. Next, we will compile the source code, a process that can take up to an hour to complete. During the compilation process you should see output every few seconds or every few minutes, or an error if something goes wrong. The compilation process can be resumed at any time if interrupted. Type <code>make</code> to start compiling:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>If all goes well, bitcoind is now compiled. The final step is to install the bitcoind executable into the system path using the <code>make</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We can confirm that bitcoin is correctly installed, by asking the system for the path of the two executables, as follows:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The default installation of bitcoind puts it in <code>/usr/local/bin</code>. When we first run bitcoind it will remind us to create a configuration file with a strong password for the JSON-RPC interface. We run it by typing <code>bitcoind</code> into the terminal:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Edit the configuration file in your preferred editor and set the parameters, replacing the password with a strong password as recommended by bitcoind. Do <strong>not</strong> use the password shown below. Create a file inside the <code>.bitcoin</code> directory so that it is named <code>.bitcoin/bitcoin.conf</code> and enter a username and password:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>While you&#8217;re editing this configuration file, you may want to set a few other options, such as <code>txindex</code> (See <a href="#txindex">[txindex]</a>). For a full listing of the available options type <code>bitcoind --help</code>.</p></div>
<div class="paragraph"><p>Now, run the Bitcoin Core client. The first time you run it, it will rebuild the bitcoin blockchain by downloading all the blocks. This is a multi-gigabyte file and will take on average 2 days to download in full. You can shorten the blockchain initialization time by downloading a partial copy of the blockchain using a bittorrent client from <code>http://sourceforge.net/projects/bitcoin/files/Bitcoin/blockchain/</code>.</p></div>
<div class="paragraph"><p>Run bitcoind in the background with the option <code>-daemon</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
</div>
<div class="sect2">
<h3 id="_using_bitcoin_core_8217_s_json_rpc_api_from_the_command_line">Using Bitcoin Core&#8217;s JSON-RPC API from the command line</h3>
<div class="paragraph"><p>The Bitcoin Core client implements a JSON-RPC interface that can also be accessed using the command line helper <code>bitcoin-cli</code>. The command line allows us to experiment interactively with the capabilities that are also available programmatically via the API. To start, we can invoke the <code>help</code> command to see a list of the available bitcoin commands:</p></div>
<div class="listingblock">
<a id="bitcoind_commands"></a>
<div class="title">Bitcoin Core RPC commands</div>
<div class="content"></div></div>
<div class="sect3">
<h4 id="_getting_information_on_the_bitcoin_core_client_status">Getting information on the Bitcoin Core client status</h4>
<div class="paragraph"><p>Commands: getinfo</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s <code>getinfo</code> RPC command shows us basic information about the status of the bitcoin network node, the wallet and the blockchain database. We use bitcoin-cli to run it:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The data is returned in JavaScript Object Notation (JSON), a format which can easily be "consumed" by all programming languages but is also quite human-readable. Among this data we see the version numbers for the bitcoin software client (90000), protocol (70002) and wallet (60000). We see the current balance contained in the wallet, which is zero. We see the current block height, showing us how many blocks are known to this client, 286216. We also see various statistics about the bitcoin network and the settings related to this client. We will explore these settings in more detail in the rest of this chapter.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>It will take some time, perhaps more than a day, for the bitcoind client to "catch up" to the current blockchain height as it downloads blocks from other bitcoin clients. You can check its current progress using getinfo to see the number of known blocks.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_wallet_setup_and_encryption">Wallet setup and encryption</h4>
<div class="paragraph"><p>Commands: encryptwallet, walletpassphrase</p></div>
<div class="paragraph"><p>Before we proceed with creating keys and other commands, we will first encrypt the wallet with a password. For this example, we use the <code>encryptwallet</code> command with the password "foo". Obviously, replace "foo" with a strong and complex password!</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ bitcoin-cli encryptwallet foo
wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed, you need to make a new backup.
$</code></pre>
</div></div>
<div class="paragraph"><p>We can verify the wallet has been encrypted by running <code>getinfo</code> again. This time you will notice a new entry <code>unlocked_until</code> that is a counter showing how long the wallet decryption password will be stored in memory, keeping the wallet unlocked. At first this will be set to zero, meaning the wallet is locked:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>To unlock the wallet, we issue the <code>walletpassphrase</code> command that takes two parameters, the password and a number of seconds until the wallet is locked again automatically (a time counter):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ bitcoin-cli walletpassphrase foo 360
$</code></pre>
</div></div>
<div class="paragraph"><p>Confirm the wallet is unlocked and see the timeout by running <code>getinfo</code> again:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
<div class="sect3">
<h4 id="_wallet_backup_plain_text_dump_and_restore">Wallet backup, plain-text dump and restore</h4>
<div class="paragraph"><p>Commands: backupwallet, importwallet, dumpwallet</p></div>
<div class="paragraph"><p>Next, we will practice creating a wallet backup file and then restoring the wallet from the backup file. Use the <code>backupwallet</code> command to backup, providing the file name as the parameter. Here we backup the wallet to the file <code>wallet.backup</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Now, to restore the backup file, use the <code>importwallet</code> command. If your wallet is locked, you will need to unlock it first (see <code>walletpassphrase</code> above) in order to import the backup file:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>dumpwallet</code> command can be used to dump the wallet into a text file that is human-readable:</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
<div class="sect3">
<h4 id="_wallet_addresses_and_receiving_transactions">Wallet addresses and receiving transactions</h4>
<div class="paragraph"><p>Commands: getnewaddress, getreceivedbyaddress, listtransactions, getaddressesbyaccount, getbalance</p></div>
<div class="paragraph"><p>The bitcoin reference client maintains a pool of addresses, the size of which is displayed by <code>keypoolsize</code> when you use the command <code>getinfo</code>. These addresses are generated automatically and can then be used as public receiving addresses or change addresses. To get one of these addresses, you can use the <code>getnewaddress</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Now, we can use this address to send a small amount of bitcoin to our bitcoind wallet from an external wallet (assuming you have some bitcoin in an exchange, web wallet or other bitcoind wallet held elsewhere). For this example, we will send 50 milliBits (0.050 bitcoin) to the address returned above.</p></div>
<div class="paragraph"><p>We can now query the bitcoind client for the amount received by this address, and specify how many confirmations are required before an amount is counted in that balance. For this example, we will specify zero confirmations. A few seconds after sending the bitcoin from another wallet, we will see it reflected in the wallet. We use <code>getreceivedbyaddress</code> with the address and the number of confirmations set to zero (0):</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>If we omit the zero from the end of this command, we will only see the amounts that have at least <code>minconf</code> confirmations, where <code>minconf</code> is the setting for the minimum number of confirmations before a transaction is listed in the balance. The <code>minconf</code> setting is specified in the bitcoind configuration file. Since the transaction sending this bitcoin was only sent in the last few seconds, it has still not confirmed and therefore we will see it list a zero balance:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The transactions received by the entire wallet can also be displayed using the <code>listtransactions</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We can list all addresses in the entire wallet using the <code>getaddressesbyaccount</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Finally, the command <code>getbalance</code> will show the total balance of the wallet, adding up all transactions confirmed with at least <code>minconf</code> confirmations:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>If the transaction has not yet confirmed, the balance returned by getbalance will be zero. The configuration option "minconf" determines the minimum number of confirmations that are required before a transaction shows in the balance.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_exploring_and_decoding_transactions">Exploring and decoding transactions</h4>
<div class="paragraph"><p>Commands: gettransaction, getrawtransaction, decoderawtransaction</p></div>
<div class="paragraph"><p>We&#8217;ll now explore the incoming transaction that was listed above using the <code>gettransaction</code> command. We can retrieve a transaction by its transaction hash, shown at <code>txid</code>, above with the <code>gettransaction</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Transaction IDs are not authoritative until a transaction has been confirmed. Absence of a transaction hash in the blockchain does not mean the transaction was not processed. This is known as "transaction malleability", as transaction hashes can be modified prior to confirmation in a block. After confirmation, the txid is immutable and authoritative.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>The transaction form shown above with the command <code>gettransaction</code> is the simplified form. To retrieve the full transaction code and decode it we will use two commands, <code>getrawtransaction</code> and <code>decoderawtransaction</code>. First, <code>getrawtransaction</code> takes the <em>transaction hash (txid)</em> as a parameter and returns the full transaction as a "raw" hex string, exactly as it exists on the bitcoin network:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>To decode this hex string, we can use the <code>decoderawtransaction</code> command. Copy and paste the hex as the first parameter of <code>decoderawtransaction</code> to get the full contents interpreted as a JSON data structure (for formatting reasons the hex string is shortened in the example below):</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The transaction decode shows all the components of this transaction, including the transaction inputs and outputs. In this case we see that the transaction that credited our new address with 50 milliBits used one input and generated two outputs. The input to this transaction was the output from a previously confirmed transaction (shown as the vin txid starting with <code>d3c7</code> above). The two outputs correspond to the 50 millibit credit and an output with change back to the sender.</p></div>
<div class="paragraph"><p>We can further explore the blockchain by examining the previous transaction referenced by its txid in this transaction using the same commands (e.g., <code>gettransaction</code>). Jumping from transaction to transaction we can follow a chain of transactions back as the coins are transmitted from owner address to owner address.</p></div>
<div class="paragraph"><p>Once the transaction we received has been confirmed by inclusion in a block, the <code>gettransaction</code> command will return additional information, showing the <em>block hash (identifier)</em> in which the transaction was included:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Above, we see the new information in the entries <code>blockhash</code>, the hash of the block in which the transaction was included, and <code>blockindex</code> with value 18, indicating that our transaction was the 18th transaction in that block.</p></div>
<div class="sidebarblock" id="txindex">
<div class="content">
<div class="title">Transaction database index and txindex option</div>
<div class="paragraph"><p>By default, Bitcoin Core builds a database containing <em>only</em> the transactions related to the user&#8217;s wallet. If you want to be able to access <em>any</em> transaction with commands like <code>gettransaction</code>, you need to configure Bitcoin Core to build a complete transaction index, which can be achieved with the <code>txindex</code> option. Set <code>txindex=1</code> in the Bitcoin Core configuration file (usually found in your home directory under <code>.bitcoin/bitcoin.conf</code>). Once you change this parameter, you need to restart bitcoind and wait for it to rebuild the index.</p></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_exploring_blocks">Exploring blocks</h4>
<div class="paragraph"><p>Commands: getblock, getblockhash</p></div>
<div class="paragraph"><p>Now that we know which block our transaction was included in, we can query that block. We use the <code>getblock</code> command with the block hash as the parameter:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The block contains 367 transactions and as you see above, the 18th transaction listed (<code>9ca8f9&#8230;</code>) is the txid of the one crediting 50 milliBits to our address. The <code>height</code> entry tells us this is the 286384th block in the blockchain.</p></div>
<div class="paragraph"><p>We can also retrieve a block by its block height using the <code>getblockhash</code> command, which takes the block height as the parameter and returns the block hash for that block:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Above, we retrieve the block hash of the "genesis block", the first block mined by Satoshi Nakamoto, at height zero. Retrieving this block shows:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>getblock</code>, <code>getblockhash</code> and <code>gettransaction</code> commands can be used to explore the blockchain database, programmatically.</p></div>
</div>
<div class="sect3">
<h4 id="_creating_signing_and_submitting_transactions_based_on_unspent_outputs">Creating, signing and submitting transactions based on unspent outputs</h4>
<div class="paragraph"><p>Commands: listunspent, gettxout, createrawtransaction, decoderawtransaction, signrawtransaction, sendrawtransaction</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s transactions are based on the concept of spending "outputs", which are the result of previous transactions, to create a transaction chain that transfers ownership from address to address. Our wallet has now received a transaction that assigned one such output to our address. Once this is confirmed, we can now spend that output.</p></div>
<div class="paragraph"><p>First, we use the <code>listunspent</code> command to show all the unspent <strong>confirmed</strong> outputs in our wallet:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We see that the transaction <code>9ca8f9&#8230;</code> created an output (with vout index 0) assigned to the address <code>1hvzSo&#8230;</code> for the amount of 50 millibits, which at this point has received 7 confirmations. Transactions use previously created outputs as their inputs by referring to them by the previous txid and vout index. We will now create a transaction that will spend the 0th vout of the txid <code>9ca8f9&#8230;</code> as its input and assign it to a new output that sends value to a new address.</p></div>
<div class="paragraph"><p>First, let&#8217;s look at the specific output in more detail. We use the <code>gettxout</code> to get the details of this unspent output above. Transaction outputs are always referenced by txid and vout, and these are the parameters we pass to <code>gettxout</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>What we see above is the output that assigned 50 millibits to our address <code>1hvz&#8230;</code>. To spend this output we will create a new transaction. First, let&#8217;s make an address to which we will send the money:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We will send 25 millibits to the new address <code>1LnfTn&#8230;</code> we just created in our wallet. In our new transaction, we will spend the 50 millibit output and send 25 millibits to this new address. Because we have to spend the <strong>whole</strong> output from the previous transaction, we must also generate some change. We will generate change back to the <code>1hvz&#8230;</code> address, sending the change back to the address from which the value originated. Finally, we will also have to pay a fee for this transaction. To pay the fee, we will reduce the change output by 0.5 millibits, and return 24.5 millibits in change. The difference between the sum of the new outputs (25mBTC + 24.5mBTC = 49.5mBTC) and the input (50mBTC) will be collected as a transaction fee by the miners.</p></div>
<div class="paragraph"><p>We use the <code>createrawtransaction</code> to create the transaction described above. As parameters to <code>createrawtransaction</code> we provide the transaction input (the 50 millibit unspent output from our confirmed transaction) and the two transaction outputs (money sent to the new address and change sent back to the previous address):</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>createrawtransaction</code> command produces a raw hex string that encodes the transaction details we supplied. Let&#8217;s confirm everything is correct by decoding this raw string using the <code>decoderawtransaction</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>That looks correct! Our new transaction "consumes" the unspent output from our confirmed transaction and then spends it in two outputs, one for 25 millibits to our new address and one for 24.5 millibits as change back to the original address. The difference of 0.5 millibits represents the transaction fee and will be credited to the miner who finds the block that includes our transaction.</p></div>
<div class="paragraph"><p>As you may notice, the transaction contains an empty <code>scriptSig</code> because we haven&#8217;t signed it yet. Without a signature, this transaction is meaningless, we haven&#8217;t yet proven that we <strong>own</strong> the address from which the unspent output is sourced. By signing, we remove the encumbrance on the output and prove that we own this output and can spend it. We use the <code>signrawtransaction</code> command to sign the transaction. It takes the raw transaction hex string as the parameter.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>An encrypted wallet must be unlocked before a transaction is signed because signing requires access to the secret keys in the wallet.</p></div>
</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>signrawtransaction</code> command returns another hex encoded raw transaction. We decode it to see what changed, with <code>decoderawtransaction</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Now, the inputs used in the transaction contain a <code>scriptSig</code>, which is a digital signature proving ownership of address <code>1hvz&#8230;</code> and removing the encumbrance on the output so that it can be spent. The signature makes this transaction verifiable by any node in the bitcoin network.</p></div>
<div class="paragraph"><p>Now it&#8217;s time to submit the newly created transaction to the network. We do that with the command <code>sendrawtransaction</code> which takes the raw hex string produced by <code>signrawtransaction</code>. This is the same string we just decoded above:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The command <code>sendrawtransaction</code> returns a <em>transaction hash (txid)</em> as it submits the transaction on the network. We can now query that transaction id with <code>gettransaction</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>As before, we can also examine this in more detail using the <code>getrawtransaction</code> and <code>decodetransaction</code> commands. These commands will return the exact same hex string that we produced and decoded previously just before we sent it on the network.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="alt_libraries">Alternative clients, libraries and toolkits</h3>
<div class="paragraph"><p>Beyond the reference client, bitcoind, there are other clients and libraries that can be used to interact with the bitcoin network and data structures. These are implemented in a variety of programming languages, offering programmers native interfaces in their own language.</p></div>
<div class="paragraph"><p>Alternative implementations include:</p></div>
<div class="ulist"><ul>
<li>
<p>
libbitcoin and sx tools, a C++ multi-threaded full node client and library with command-line tools (<a href="https://libbitcoin.dyne.org/">https://libbitcoin.dyne.org/</a>)
</p>
</li>
<li>
<p>
bitcoinj, a Java full node client library (<a href="https://code.google.com/p/bitcoinj/">https://code.google.com/p/bitcoinj/</a>)
</p>
</li>
<li>
<p>
btcd, a Go language full node bitcoin client (<a href="https://opensource.conformal.com/wiki/btcd">https://opensource.conformal.com/wiki/btcd</a>)
</p>
</li>
<li>
<p>
Bits of Proof (BOP), a Java enterprise-class implementation of bitcoin (<a href="https://bitsofproof.com">https://bitsofproof.com</a>)
</p>
</li>
<li>
<p>
picocoin, a C implementation of a light-weight client library for bitcoin (<a href="https://github.com/jgarzik/picocoin">https://github.com/jgarzik/picocoin</a>)
</p>
</li>
<li>
<p>
pybitcointools, a Python bitcoin library (<a href="https://github.com/vbuterin/pybitcointools">https://github.com/vbuterin/pybitcointools</a>)
</p>
</li>
<li>
<p>
pycoin, another Python bitcoin library (<a href="https://github.com/richardkiss/pycoin">https://github.com/richardkiss/pycoin</a>)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Many more libraries exist in a variety of other programming languages and more are created all the time.</p></div>
<div class="sect3">
<h4 id="sx_tools">Libbitcoin and sx tools</h4>
<div class="paragraph"><p>The libbitcoin library is a C++ scalable multi-threaded and modular implementation that supports a full-node client and a command-line toolset named "sx", which offers many of the same capabilities as the bitcoind client commands we illustrated in this chapter. The sx tools also offer some key management and manipulation tools that are not offered by bitcoind, including type-2 deterministic keys and key mnemonics.</p></div>
<div class="sect4">
<h5 id="_installing_sx">Installing sx</h5>
<div class="paragraph"><p>To install sx and the supporting library libbitcoin, download and run the online installer on a Linux system:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>You should now have the sx tools installed. Type <code>sx</code> with no parameters to display the help text, which lists all the available commands (See <a href="#sx_cmds_">[sx_cmds_]</a>)</p></div>
</div>
<div class="sect4">
<h5 id="_generating_and_manipulating_keys_with_sx">Generating and manipulating keys with sx</h5>
<div class="paragraph"><p>Generate a new private key with the operating system&#8217;s random number generator by using the <code>newkey</code> command. We save the standard output into the file <code>private_key</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Now, generate the public key from that private key using the <code>pubkey</code> command. Pass the <code>private_key</code> file into the standard input and save the standard output of the command into a new file <code>public_key</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>We can re-format the public_key as an address using the <code>addr</code> command. We pass the <code>public_key</code> into standard input:</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
<div class="sect4">
<h5 id="_deterministic_keys_with_sx">Deterministic keys with sx</h5>
<div class="paragraph"><p>The keys generated above are so called type-0 non-deterministic keys. That means that each one is generated from a random number generator. The sx tools also support type-2 deterministic keys, where a "master" key is created and then extended to produce a chain or tree of subkeys.</p></div>
<div class="paragraph"><p>First, we generate a "seed" that will be used as the basis to derive a chain of keys, compatible with the Electrum wallet and other similar implementations. We use the <code>newseed</code> command to produce a seed value:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The seed value can also be exported as a word mnemonic that is human readable and easier to store and type than a hexadecimal string
 using the <code>mnemonic</code> command:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The mnemonic words can be used to reproduce the seed using the <code>mnemonic</code> command again:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>With the seed, we can now generate a sequence of private and public keys, a key chain. We use the <code>genpriv</code> command to generate a sequence of private keys from a seed and the <code>addr</code> command to generate the corresponding public key.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>With deterministic keys we can generate and re-generate thousands of keys, all derived from a single seed in a deterministic chain. This technique is used in many wallet applications to generate keys that can be backed up and restored with a simple multi-word mnemonic. This is easier than having to back up the wallet with all its randomly generated keys every time a new key is created.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The sx toolkit offers many useful commands for encoding and decoding addresses, converting to and from different formats and representations. Use them to explore the various formats such as base58, base58check, hex etc.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_btcd">btcd</h4>
<div class="paragraph"><p>btcd is a full node bitcoin implementation written in Go. It currently properly downloads, validates, and serves the block chain using the exact rules (including bugs) for block acceptance as the reference implementation, bitcoind. It also properly relays newly mined blocks, maintains a transaction pool, and relays individual transactions that have not yet made it into a block. It ensures all individual transactions admitted to the pool follow the rules required into the block chain and also includes the vast majority of the more strict checks which filter transactions based on miner requirements ("standard" transactions).</p></div>
<div class="paragraph"><p>One key difference between btcd and bitcoind is that btcd does not include wallet functionality and this was a very intentional design decision. This means you can&#8217;t actually make or receive payments directly with btcd. That functionality is provided by the btcwallet and btcgui projects which are both under active development. Other notable differences are btcd support for both HTTP POST requests (such as bitcoind) and the preferred Websockets, and btcd&#8217;s RPC connections are TLS-enabled by default.</p></div>
<div class="sect4">
<h5 id="_installing_btcd">Installing btcd</h5>
<div class="paragraph"><p>To install btcd, for Windows, download and run the msi available at <a href="https://github.com/conformal/btcd/releases">https://github.com/conformal/btcd/releases</a> or run the following command on Linux, assuming you already have installed the Go language:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>To update btcd to the latest version, just run:</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
<div class="sect4">
<h5 id="_controlling_btcd">Controlling btcd</h5>
<div class="paragraph"><p>btcd has a number of configuration options, which can be viewed by running:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>btcd comes prepacked with some goodies such as btcctl, a command line utility that can be used to both control and query btcd via RPC. btcd does not enable its RPC server by default; you must configure at minimum both an RPC username and password:</p></div>
<div class="ulist"><ul>
<li>
<p>
btcd.conf configuration file
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="ulist"><ul>
<li>
<p>
btcctl.conf configuration file
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Or if you want to override the configuration files from the command line:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>For a list of available options, run:</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch04_keys_addresses_wallets">Keys, Addresses, Wallets</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph"><p>Ownership of bitcoin is established through <em>digital keys</em>, <em>bitcoin addresses</em> and <em>digital signatures</em>. The digital keys are not actually stored in the network, but are instead created and stored by end-users in a file, or simple database, called a <em>wallet</em>. The digital keys in a user&#8217;s wallet are completely independent of the bitcoin protocol and can be generated and managed by the user&#8217;s wallet software without reference to the blockchain or access to the Internet. Keys enable many of the interesting properties of bitcoin, including de-centralized trust and control, ownership attestation and the cryptographic-proof security model.</p></div>
<div class="paragraph"><p>HNFUzKACoVNLnyx4PlW7hJg3dpko2UlDwttaxaUPan4afMmK9ZAtHMKB4PqJgYFe8VDIp0x7OpruTFugxA5hBTE=</p></div>
<div class="paragraph"><p>Every bitcoin transaction requires a valid signature to be included in the blockchain, which can only be generated with valid digital keys, therefore anyone with a copy of those keys has control of the bitcoin in that account. Keys come in pairs consisting of a private (secret) and public key. Think of the public key as similar to a bank account number and the private key as similar to the secret PIN number, or signature on a cheque that provides control over the account. These digital keys are very rarely seen by the users of bitcoin. For the most part, they are stored inside the wallet file and managed by the bitcoin wallet software.</p></div>
<div class="paragraph"><p>In the payment portion of a bitcoin transaction, the recipient&#8217;s public key is represented by its digital fingerprint, called a <em>bitcoin address</em>, which is used in the same way as the beneficiary name on a cheque (i.e. "Pay to the order of"). In most cases, a bitcoin address is generated from and corresponds to a public key. However, not all bitcoin addresses represent public keys; they can also represent other beneficiaries such as scripts, as we will see later in this chapter. This way, bitcoin addresses abstract the recipient of funds, making transaction destinations flexible, similar to paper cheques: a single payment instrument that can be used to pay into people&#8217;s accounts, company accounts, pay for bills or pay to cash. The bitcoin address is the only representation of the keys that users will routinely see, as this is the part they need to share with the world.</p></div>
<div class="paragraph"><p>In this chapter we will introduce wallets, which contain cryptographic keys. We will look at how keys are generated, stored and managed. We will review the various encoding formats used to represent private and public keys, addresses and script addresses. Finally we will look at special uses of keys: to sign messages, to prove ownership and to create vanity addresses and paper wallets.</p></div>
<div class="sect3">
<h4 id="_public_key_cryptography_and_crypto_currency">Public key cryptography and crypto-currency</h4>
<div class="paragraph"><p>Public key cryptography was invented in the 1970s and is a mathematical foundation for computer and information security.</p></div>
<div class="paragraph"><p>Since the invention of public key cryptography, several suitable mathematical functions, such as prime number exponentiation and elliptic curve multiplication, have been discovered. These mathematical functions are practically irreversible, meaning that they are easy to calculate in one direction and infeasible to calculate in the opposite direction. Based on these mathematical functions, cryptography enables the creation of digital secrets and unforgeable digital signatures. Bitcoin uses elliptic curve multiplication as the basis for its public key cryptography.</p></div>
<div class="paragraph"><p>In bitcoin, we use public key cryptography to create a key pair that controls access to bitcoins. The key pair consists of a private key and&#8201;&#8212;&#8201;derived from it&#8201;&#8212;&#8201;a unique public key. The public key is used to receive bitcoins, and the private key is used to sign transactions to spend those bitcoins.</p></div>
<div class="paragraph"><p>There is a mathematical relationship between the public and the private key that allows the private key to be used to generate signatures on messages. This signature can be validated against the public key without revealing the private key.</p></div>
<div class="paragraph"><p>When spending bitcoins, the current bitcoin owner presents their public key and a signature (different each time, but created from the same private key; see <a href="#signature">[signature]</a>) in a transaction to spend those bitcoins. Through the presentation of the public key and signature everyone in the bitcoin network can verify and accept the transaction as valid, confirming that the person transferring the bitcoins owned them at the time of the transfer.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>In most wallet implementations, the private and public keys are stored together as a <em>key pair</em> for convenience. However, the public key can be calculated from the private key, so storing only the private key is also possible.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_private_and_public_keys">Private and Public Keys</h4>
<div class="paragraph"><p>A bitcoin wallet contains a collection of key pairs, each consisting of a private key and a public key. The private key (k) is a number, usually picked at random. From the private key, we use elliptic curve multiplication, a one-way cryptographic function, to generate a public key (K). From the public key (K), we use a one-way cryptographic hash function to generate a bitcoin address (A). In this section we will start with generating the private key, look at the elliptic curve math that is used to turn that into a public key, and finally, generate a bitcoin address from the public key. The relationship between private key, public key and bitcoin address is shown below:</p></div>
<div class="imageblock" id="k_to_K_to_A">
<div class="content">
<img src="images/privk_to_pubK_to_addressA.png" alt="privk_to_pubK_to_addressA" />
</div>
<div class="title">Figure 17. Private Key, Public Key and Bitcoin Address</div>
</div>
</div>
<div class="sect3">
<h4 id="private_keys">Private Keys</h4>
<div class="paragraph"><p>A <code>private key</code> is simply a number, picked at random. Ownership and control over the private key is the root of user control over all funds associated with the corresponding bitcoin address. The private key is used to create signatures that are required to spend bitcoins by proving ownership of funds used in a transaction. The private key must remain secret at all times, as revealing it to a third party is equivalent to giving them control over the bitcoins secured by that key. The private key must also be backed up and protected from accidental loss, since if lost it cannot be recovered and the funds secured by it are forever lost too.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The bitcoin private key is just a number. You can pick your private keys randomly using just a coin, pencil and paper: Toss a coin 256 times and you have the binary digits of a random private key you can use in a bitcoin wallet. The public key can be then generated from the private key.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_generating_a_private_key_from_a_random_number">Generating a private key from a random number</h5>
<div class="paragraph"><p>The first and most important step in generating keys is to find a secure source of entropy, or randomness. Creating a bitcoin key is essentially the same as "Pick a number between 1 and 2<sup>256</sup>". The exact method you use to pick that number does not matter as long as it is not predictable or repeatable. Bitcoin software uses the underlying operating system&#8217;s random number generators to produce 256 bits of entropy (randomness). Usually, the OS random number generator is initialized by a human source of randomness, which is why you may be asked to wiggle your mouse around for a few seconds. For the truly paranoid, nothing beats dice, pencil and paper.</p></div>
<div class="paragraph"><p>More accurately, the private key can be any number between <code>1</code> and <code>n - 1</code>, where n is a constant (n = 1.158 * 10<sup>77</sup>, slightly less than 2<sup>256</sup>) defined as the order of the elliptic curve used in bitcoin (see <a href="#elliptic_curve">[elliptic_curve]</a>). To create such a key, we randomly pick a 256-bit number and check that it is less than <code>n - 1</code>. In programming terms, this is usually achieved by feeding a larger string of random bits, collected from a cryptographically-secure source of randomness, into the SHA-256 hash algorithm which will conveniently produce a 256-bit number. If the result is less than <code>n - 1</code>, we have a suitable private key. Otherwise, we simply try again with another random number.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Do not write your own code to create a random number or use a "simple" random number generator offered by your programming language. Use a cryptographically-secure pseudo-random number generator (CSPRNG) with a seed from a source of sufficient entropy. Study the documentation of the random number generator library you choose to make sure it is cryptographically secure. Correct implementation of the CSPRNG is critical to the security of the keys.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Below is a randomly generated private key shown in hexadecimal format (256 binary digits shown as 64 hexadecimal digits, each 4 bits):</p></div>
<div class="listingblock">
<div class="title">Randomly generated private key (k)</div>
<div class="content">
<pre><code>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The size of bitcoin&#8217;s private key space, 2<sup>256</sup> is an unfathomably large number. It is approximately 10<sup>77</sup> in decimal. The visible universe is estimated to contain 10<sup>80</sup> atoms.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>To generate a new key with the Bitcoin Core Client (see <a href="#ch03_bitcoin_client">[ch03_bitcoin_client]</a>), use the <code>getnewaddress</code> command. For security reasons it displays the public key only, not the private key. To ask bitcoin-cli to expose the private key, use the <code>dumpprivkey</code> command. The <code>dumpprivkey</code> shows the private key in a base-58 checksum encoded format called the Wallet Import Format (WIF), which we will examine in more detail in <a href="#priv_formats">[priv_formats]</a>. Here&#8217;s an example of generating and displaying a private key using these two commands:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ bitcoin-cli getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoin-cli dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</code></pre>
</div></div>
<div class="paragraph"><p>The <code>dumpprivkey</code> command opens the wallet and extracts the private key that was generated by the <code>getnewaddress</code> command. It is not otherwise possible for bitcoin-cli to know the private key from the public key, unless they are both stored in the wallet.</p></div>
<div class="paragraph"><p>You can also use the command-line <code>sx tools</code> (see <a href="#sx_tools">[sx_tools]</a>) to generate and display private keys:</p></div>
</div>
<div class="sect4">
<h5 id="_new_key_with_sx_tools">New key with sx tools</h5>
<div class="listingblock">
<div class="content">
<pre><code>$ sx newkey
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</code></pre>
</div></div>
</div>
</div>
<div class="sect3">
<h4 id="pubkey">Public Keys</h4>
<div class="paragraph"><p>The public key is calculated from the private key using elliptic curve multiplication, which is irreversible: \(K = k * G\) where <code>k</code> is the private key, <code>G</code> is a constant point called the <em>Generator Point</em> and <code>K</code> is the resulting public key. The reverse operation, known as "finding the discrete logarithm"&#8201;&#8212;&#8201;calculating <code>k</code> if you know <code>K</code>&#8201;&#8212;&#8201;is as difficult as trying all possible values of <code>k</code>, i.e., a brute-force search. Before we demonstrate how to generate a public key from a private key, let&#8217;s look at Elliptic Curve Cryptography in a bit more detail.</p></div>
</div>
<div class="sect3">
<h4 id="elliptic_curve">Elliptic Curve Cryptography Explained</h4>
<div class="paragraph"><p>Elliptic Curve Cryptography is a type of asymmetric or public-key cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.</p></div>
<div class="paragraph"><p>Below we see an example of an elliptic curve, similar to that used by bitcoin:</p></div>
<div class="imageblock" id="ecc-curve">
<div class="content">
<img src="images/ecc-curve.png" alt="ecc-curve" />
</div>
<div class="title">Figure 18. An Elliptic Curve</div>
</div>
<div class="paragraph"><p>Bitcoin uses a specific elliptic curve and set of mathematical constants, as defined in a standard called <code>secp256k1</code>, established by the National Institute of Standards and Technology (NIST). The <code>secp256k1</code> curve is defined by the following function, which produces an elliptic curve:</p></div>
<div class="paragraph"><p></p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 = (x^3 \+ 7)} \text{over} \(\mathbb{F}_p\)
\end{equation}</div></div>
<div class="paragraph"><p>or</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}</div></div>
<div class="paragraph"><p>The <code>mod p</code> (modulo prime number p) indicates that this curve is over a finite field of prime order <code>p</code>, also written as \(\mathbb{F}_p\), where p = 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> - 2<sup>8</sup> - 2<sup>7</sup> - 2<sup>6</sup> - 2<sup>4</sup> - 1, a very large prime number.</p></div>
<div class="paragraph"><p>Because this curve is defined over a finite field of prime order instead of over the real numbers it looks like a pattern of dots scattered in two dimensions, which makes it difficult to visualize. However, the math is identical as that of an elliptic curve over the real numbers shown above. As an example, below is the same elliptic curve over a much smaller finite field of prime order 17, showing a pattern of dots on a grid. The <code>secp256k1</code> bitcoin elliptic curve can be thought of as a much more complex pattern of dots on a unfathomably large grid.</p></div>
<div class="imageblock" id="ecc-over-F17-math">
<div class="content">
<img src="images/ecc-over-F17-math.png" alt="ecc-over-F17-math" />
</div>
<div class="title">Figure 19. Elliptic Curve Cryptography: Visualizing an elliptic curve over F(p), with p=17</div>
</div>
<div class="paragraph"><p>So for example, below is a point P with coordinates (x,y) that is a point on the secp256k1 curve. You can check this yourself using Python:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>P = (55066263022277343669578718895168534326250603453777594175500187360389116729240,\
     32670510020758816978083085130507043184471273380659243275938904335757337482424)</code></pre>
</div></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>In elliptic curve math, there is a point called the "point at infinity", which roughly corresponds to the role of 0 in addition. On computers, it&#8217;s sometimes represented by x = y = 0 (which doesn&#8217;t satisfy the elliptic curve equation&#8201;&#8212;&#8201;but it&#8217;s an easy separate case that can be checked).</p></div>
<div class="paragraph"><p>There is also an operator "+", called "addition" which has some properties similar to the traditional addition of real numbers that grade school children learn. Given two points P<sub>1</sub> and P<sub>2</sub> on the elliptic curve, there is a third point P<sub>3</sub> = P<sub>1</sub> + P<sub>2</sub>, also on the elliptic curve.</p></div>
<div class="paragraph"><p>Geometrically, this third point P<sub>3</sub> is calculated by drawing a line between P<sub>1</sub> and P<sub>2</sub>. This line will intersect the elliptic curve in exactly one additional place. Call this point P<sub>3</sub>' = (x, y). Then reflect in the X axis to get P<sub>3</sub> = (x, -y).</p></div>
<div class="paragraph"><p>There are a couple of special cases which explain the need for the "point at infinity".</p></div>
<div class="paragraph"><p>If P<sub>1</sub> and P<sub>2</sub> are the same point, the line "between" P<sub>1</sub> and P<sub>2</sub> should extend to be the tangent on the curve at this point P<sub>1</sub>. This tangent will intersect the curve in exactly one new point. You can use techniques from calculus to determine the slope of the tangent line. These techniques curiously work even though we are restricting our interest to points on the curve with two integer coordinates!</p></div>
<div class="paragraph"><p>In some cases (i.e., if P<sub>1</sub> and P<sub>2</sub> have the same x values but different y values), the tangent line will be exactly vertical, in which case P3 = "point at infinity".</p></div>
<div class="paragraph"><p>If P<sub>1</sub> is the "point at infinity", then the sum P<sub>1</sub> + P<sub>2</sub> = P<sub>2</sub>. Similary, if P<sub>2</sub> is the point at infinity, then P<sub>1</sub> + P<sub>2</sub> = P<sub>1</sub>. This shows how the point at infinity plays the roll of 0.</p></div>
<div class="paragraph"><p>It turns out that + is associative, which means that <code>(A+B)+C = A+(B+C)</code>. That means we can write A+B+C without parentheses without any ambiguity.</p></div>
<div class="paragraph"><p>Now that we have defined addition, we can define multiplication in the standard way that extends addition. For a point P on the elliptic curve, if k is a whole number, then kP = P + P + P + &#8230; + P (k times). Note that k is sometimes confusingly called an "exponent" in this case.</p></div>
</div>
<div class="sect3">
<h4 id="public_key_derivation">Generating a public key</h4>
<div class="paragraph"><p>Starting with a private key in the form of a randomly generated number <code>k</code>, we multiply it by a predetermined point on the curve called the <em>generator point</em> <code>G</code> to produce another point somewhere else on the curve, which is the corresponding public key <code>K</code>. The generator point is specified as part of the <code>secp256k1</code> standard and is always the same for all keys in bitcoin.</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{K = k * G}
\end{equation}</div></div>
<div class="paragraph"><p>where <code>k</code> is the private key, <code>G</code> is the generator point,  and <code>K</code> is the resulting public key, a point on the curve. Since the generator point is always the same for all bitcoin users, a private key k multiplied with G will always result in the same public key K. The relationship between k and K is fixed, but can only be calculated in one direction, from k to K. That&#8217;s why a bitcoin address (derived from K) can be shared with anyone and does not reveal the user&#8217;s private key (k).</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A private key can be converted into a public key, but a public key cannot be converted back into a private key because the math only works one way.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Implementing the elliptic curve multiplication above, we take the private key generated previously and multiply it by G:</p></div>
<div class="listingblock">
<div class="title">Multiply the private key k with the generator point G to find the public key K</div>
<div class="content">
<pre><code>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</code></pre>
</div></div>
<div class="listingblock">
<div class="title">Public Key K defined as a point <code>K = (x,y)</code></div>
<div class="content">
<pre><code>K = (x, y)
where,
x = F028892BAD...DC341A
y = 07CF33DA18...505BDB</code></pre>
</div></div>
<div class="paragraph"><p>To visualize multiplication of a point with an integer, we will use the simpler elliptic curve over the real numbers&#8201;&#8212;&#8201;remember, the math is the same. Our goal is to find the multiple kG of the generator point G. That is the same as adding G to itself, k times in a row. In elliptic curves, adding a point to itself is the equivalent of drawing a tangent line on the point and finding where it intersects the curve again, then reflecting that point on the x-axis.</p></div>
<div class="paragraph"><p>The diagram below shows the process for deriving G, 2G, 4G, as a geometric operation on the curve.</p></div>
<div class="imageblock" id="ecc_illustrated">
<div class="content">
<img src="images/ecc_illustrated.png" alt="ecc_illustrated" />
</div>
<div class="title">Figure 20. Elliptic Curve Cryptography: Visualizing the multiplication of a point G by an integer k on an elliptic curve</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Most bitcoin implementations use the OpenSSL cryptographic library to do the elliptic curve math. For example, to derive the public key, the function <code>EC_POINT_mul()</code> is used. See <a href="http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography">http://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography</a></p></div>
</td>
</tr></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_addresses">Bitcoin Addresses</h3>
<div class="paragraph"><p>A bitcoin address is a string of digits and characters that can be shared with anyone who wants to send you money. Addresses produced from public keys consist of a string of numbers and letters, beginning with the digit "1". Here&#8217;s an example of a bitcoin address:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>1thMirt546nngXqyPEz532S8fLwbozud8</code></pre>
</div></div>
<div class="paragraph"><p>The bitcoin address is what appears most commonly in a transaction as the "recipient" of the funds. If we were to compare a bitcoin transaction to a paper cheque, the bitcoin address is the beneficiary, which is what we write on the line after "Pay to the order of". On a paper cheque, that beneficiary can sometimes be the name of a bank account holder, but can also include corporations, institutions or even cash. Because paper cheques do not need to specify an account, but rather use an abstract name as the recipient of funds, that makes paper cheques very flexible as payment instruments. Bitcoin transactions use a similar abstraction, the bitcoin address, to make them very flexible. A bitcoin address can represent the owner of a private/public key pair, or it can represent something else, such as a payment script, as we will see in <a href="#p2sh">[p2sh]</a>. For now, let&#8217;s examine the simple case, a bitcoin address that represents, and is derived from, a public key.</p></div>
<div class="paragraph"><p>The bitcoin address is derived from the public key through the use of one-way cryptographic hashing; a "hashing algorithm" or simply "hash algorithm" is a one-way function that produces a fingerprint or "hash" of an arbitrary sized input. Cryptographic hash functions are used extensively in bitcoin: in bitcoin addresses, in script addresses and in the mining "Proof-of-Work" algorithm. The algorithms used to make a bitcoin address from a public key are the Secure Hash Algorithm (SHA) and the RACE Integrity Primitives Evaluation Message Digest (RIPEMD), specifically SHA256 and RIPEMD160.</p></div>
<div class="paragraph"><p>Starting with the public key K, we compute the SHA256 hash and then compute the RIPEMD160 hash of the result, producing a 160 bit (20 byte) number:</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}</div></div>
<div class="paragraph"><p>where K is the public key and A is the resulting bitcoin address.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A bitcoin address is <strong>not</strong> the same as a public key. Bitcoin addresses are derived from a public key using a one-way function.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Bitcoin addresses are almost always presented to users in an encoding called "Base58Check" (see <a href="#base58check">[base58check]</a> below), which uses 58 characters (a base-58 number system) and a checksum to help human readability, avoid ambiguity and protect against errors in address transcription and entry. Base58Check is also used in many other ways in bitcoin, whenever there is a need for a user to read and correctly transcribe a number, such as a bitcoin address, a private key, an encrypted key, or a script hash. In the next section we will examine the mechanics of Base58Check encoding and decoding, and the resulting representations.</p></div>
<div class="imageblock" id="pubkey_to_adddress">
<div class="content">
<img src="images/PubKey_to_Bitcoin_Address.png" alt="pubkey_to_address" />
</div>
<div class="title">Figure 21. Public Key to Bitcoin Address: Conversion of a public key into a bitcoin address</div>
</div>
<div class="sect3">
<h4 id="_base58_and_base58check_encoding">Base58 and Base58Check Encoding</h4>
<div class="sect4">
<h5 id="base58">Base-58 Encoding</h5>
<div class="paragraph"><p>In order to represent long numbers in a compact way, using fewer symbols, many computer systems use mixed-alphanumeric representations with a base (or radix) higher than 10. For example, whereas the traditional decimal system uses the ten numerals 0 through 9, the hexadecimal system uses sixteen, with the letters A through F as the six additional symbols. A number represented in hexadecimal format is shorter than the equivalent decimal representation. Even more compact, Base-64 representation uses 26 lower case letters, 26 capital letters, 10 numerals and two more characters such as "+" and "/" to transmit binary data over text-based media such as email. Base-64 is most commonly used to add binary attachments to email. Base-58 is a text-based binary-encoding format developed for use in bitcoin and used in many other crypto-currencies. It offers a balance between compact representation, readability and error detection and prevention. Base-58 is a subset of Base-64, using the upper and lower case letters and numbers but omitting some characters that are frequently mistaken for one another and can appear identical when displayed in certain fonts. Specifically, Base-58 is Base-64 without the 0 (number zero), O (capital o), l (lower L), I (capital i) and the symbols "\+" and "/". Or, more simply, it is a set of lower and capital letters and numbers without the four (0, O, l, I) mentioned above.</p></div>
<div class="listingblock" id="base58alphabet">
<div class="title">Bitcoin&#8217;s Base-58 Alphabet</div>
<div class="content">
<pre><code>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</code></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="base58check">Base58Check Encoding</h5>
<div class="paragraph"><p>To add extra security against typos or transcription errors, Base58Check is a Base-58 encoding format, frequently used in bitcoin, which has a built-in error-checking code. The checksum is an additional four bytes added to the end of the data that is being encoded. The checksum is derived from the hash of the encoded data and can therefore be used to detect and prevent transcription and typing errors. When presented with a Base58Check code, the decoding software will calculate the checksum of the data and compare it to the checksum included in the code. If the two do not match, that indicates that an error has been introduced and the Base58Check data is invalid. For example, this prevents a mistyped bitcoin address from being accepted by the wallet software as a valid destination, an error which would otherwise result in loss of funds.</p></div>
<div class="paragraph"><p>To convert data (a number) into a Base58Check format, we first add a prefix to the data, called the "version byte", which serves to easily identify the type of data that is encoded. For example, in the case of a bitcoin address the prefix is zero (0x00 in hex), whereas the prefix used when encoding a private key is 128 (0x80 in hex). A list of common version prefixes is shown below in <a href="#base58check_versions">[base58check_versions]</a>.</p></div>
<div class="paragraph"><p>Next compute the "double-SHA" checksum, meaning we apply the SHA256 hash-algorithm twice on the previous result (prefix and data):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>checksum = SHA256(SHA256(prefix+data))</code></pre>
</div></div>
<div class="paragraph"><p>From the resulting 32-byte hash (hash-of-a-hash), we take only the first four bytes. These four bytes serve as the error-checking code, or checksum. The checksum is concatenated (appended) to the end.</p></div>
<div class="paragraph"><p>The result of the above is now a prefix, the data and a checksum. This result is encoded using the base-58 alphabet described in the section above.</p></div>
<div class="imageblock" id="base58check_encoding">
<div class="content">
<img src="images/Base58CheckEncoding.png" alt="Base58CheckEncoding" />
</div>
<div class="title">Figure 22. Base58Check Encoding: A base-58, versioned and checksummed format for unambiguously encoding bitcoin data</div>
</div>
<div class="paragraph"><p>In bitcoin, most of the data presented to the user is Base58Check encoded to make it compact, easy to read and easy to detect errors. The version prefix in Base58Check encoding is used to create easily distinguishable formats, which when encoded in Base-58 contain specific characters at the beginning of the Base58Check encoded payload, making it easy for humans to identify the type of data that is encoded and how to use it. This is what differentiates, for example, a Base58Check encoded bitcoin address that starts with a "1" from a Base58Check encoded private key WIF format that starts with a "5". Some example version prefixes and the resulting Base-58 characters are shown below:</p></div>
<div class="tableblock" id="base58check_versions">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Base58Check Version Prefix and Encoded Result Examples</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Type</th>
<th align="left" valign="top"> Version prefix (hex)</th>
<th align="left" valign="top"> Base-58 result prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Bitcoin Address</p></td>
<td align="left" valign="top"><p class="table">0x00</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Pay-to-Script-Hash Address</p></td>
<td align="left" valign="top"><p class="table">0x05</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Bitcoin Testnet Address</p></td>
<td align="left" valign="top"><p class="table">0x6F</p></td>
<td align="left" valign="top"><p class="table">m or n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Private Key WIF</p></td>
<td align="left" valign="top"><p class="table">0x80</p></td>
<td align="left" valign="top"><p class="table">5, K or L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BIP38 Encrypted Private Key</p></td>
<td align="left" valign="top"><p class="table">0x0142</p></td>
<td align="left" valign="top"><p class="table">6P</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BIP32 Extended Public Key</p></td>
<td align="left" valign="top"><p class="table">0x0488B21E</p></td>
<td align="left" valign="top"><p class="table">xpub</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_creating_a_bitcoin_address_from_a_private_key">Creating a bitcoin address from a private key</h5>
<div class="paragraph"><p>Let&#8217;s look at the complete process of creating a bitcoin address, from a private key, to a public key (a point on the elliptic curve), to a double-hashed address and finally the Base58Check encoding. The C++ code in <a href="#addr_example">[addr_example]</a> shows the complete process, from private key, to Base58Check encoded bitcoin address, step-by-step. The code example uses the libbitcoin library introduced in <a href="#alt_libraries">[alt_libraries]</a> for some helper functions:</p></div>
<div class="exampleblock" id="addr_example">
<div class="title">Example 1. Creating a Base58Check encoded bitcoin address from a private key</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The code uses a pre-defined private key, so that it produces the same bitcoin address every time it is run:</p></div>
<div class="exampleblock" id="addr_example_run">
<div class="title">Example 2. Compiling and running the addr code</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
</div>
<div class="sect3">
<h4 id="_key_formats">Key Formats</h4>
<div class="sect4">
<h5 id="priv_formats">Private Key Formats</h5>
<div class="paragraph"><p>The private key can be represented in a number of different formats, all of which correspond to the same 256-bit number. These formats include:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Private Key Representations (Encoding Formats)</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Type</th>
<th align="left" valign="top">Prefix</th>
<th align="left" valign="top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hex</p></td>
<td align="left" valign="top"><p class="table">None</p></td>
<td align="left" valign="top"><p class="table">64 hexadecimal digits</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">Base58Check encoding: Base-58 with version prefix of 128 and 32-bit checksum</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF-compressed</p></td>
<td align="left" valign="top"><p class="table">K or L</p></td>
<td align="left" valign="top"><p class="table">As above, with added suffix 0x01 before encoding</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The private key we generated earlier can be represented as:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Example: Same Key, Different Formats</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Format </th>
<th align="left" valign="top"> Private Key</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hex</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF-compressed</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>All of the above representations are different ways of showing the same number, the same private key. They look different, but any one format can easily be converted to any other format.</p></div>
</div>
<div class="sect4">
<h5 id="_decode_from_base58check_to_hex">Decode from Base58Check to Hex</h5>
<div class="paragraph"><p>The sx-tools package (See <a href="#sx_tools">[sx_tools]</a>) makes it easy to write shell-scripts and command-line "pipes" that manipulate bitcoin keys, addresses, and transactions. You can use sx-tools to decode the Base58Check format on the command line:</p></div>
<div class="paragraph"><p>We use the base58check-decode command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128</code></pre>
</div></div>
<div class="paragraph"><p>The result is the hexadecimal key, followed by the Wallet Import Format (WIF) version prefix 128.</p></div>
</div>
<div class="sect4">
<h5 id="_encode_from_hex_to_base58check">Encode from Hex to Base58Check</h5>
<div class="paragraph"><p>To encode into Base58Check (the opposite of the previous command), we provide the hex private key, followed by the Wallet Import Format (WIF) version prefix 128:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</code></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_encode_from_hex_compressed_key_to_base58check_encoding">Encode from Hex (Compressed Key) to Base58Check encoding</h5>
<div class="paragraph"><p>To encode into Base58Check as a "compressed" private key (see <a href="#comp_priv">[comp_priv]</a>), we add the suffix <code>01</code> to the end of the hex key and then encode as above:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</code></pre>
</div></div>
<div class="paragraph"><p>The resulting WIF-compressed format, starts with a "K". This denotes that the private key within has a suffix of "01" and will be used to produce compressed public keys only (See <a href="#comp_pub">[comp_pub]</a> below).</p></div>
</div>
<div class="sect4">
<h5 id="_public_key_formats">Public Key Formats</h5>
<div class="paragraph"><p>Public keys are also presented in different ways, most importantly as either <em>compressed</em> or <em>uncompressed</em> public keys.</p></div>
<div class="paragraph"><p>As we saw previously, the public key is a point on the elliptic curve consisting of a pair of coordinates <code>(x,y)</code>. It is usually presented with the prefix <code>04</code> followed by two 256-bit numbers, one for the x-coordinate of the point, the other for the y-coordinate. The prefix <code>04</code> is used to distinguish uncompressed public keys from compressed public keys that begin with a <code>02</code> or a <code>03</code>.</p></div>
<div class="paragraph"><p>Here&#8217;s the public key generated by the private key we created above, shown as the coordinates <code>x</code> and <code>y</code>.</p></div>
<div class="listingblock">
<div class="title">Public Key K defined as a point <code>K = (x,y)</code></div>
<div class="content">
<pre><code>x = F028892BAD...DC341A
y = 07CF33DA18...505BDB</code></pre>
</div></div>
<div class="paragraph"><p>Here&#8217;s the same public key shown as a 520-bit number (130 hex digits) with the prefix <code>04</code> followed by <code>x</code> and then <code>y</code> coordinates, as <code>04 x y</code>:</p></div>
<div class="listingblock">
<div class="title">Uncompressed Public Key K shown in hex (130 hex digits) as <code>04xy</code></div>
<div class="content">
<pre><code>K = 04F028892BAD...505BDB</code></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="comp_pub">Compressed Public Keys</h5>
<div class="paragraph"><p>Compressed public keys were introduced to bitcoin to reduce the size of transactions and conserve disk space on nodes that store the bitcoin blockchain database. Most transactions include the public key, required to validate the owner&#8217;s credentials and spend the bitcoin. Each public key requires 520 bits (prefix \+ x \+ y), which when multiplied by several hundred transactions per block, or tens of thousands of transactions per day, adds a significant amount of data to the blockchain.</p></div>
<div class="paragraph"><p>As we saw in the section <a href="#pubkey">[pubkey]</a> above, a public key is a point (x,y) on an elliptic curve. Since the curve expresses a mathematical function, a point on the curve represents a solution to the equation and therefore if we know the x-coordinate we can calculate the y-coordinate by solving the equation y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p. That allows us to store only the x-coordinate of the public key point, omitting the y-coordinate and reducing the size of the key and the space required to store it by 256 bits. An almost 50% reduction in size in every transaction adds up to a lot of data saved over time!</p></div>
<div class="paragraph"><p>Whereas uncompressed public keys have a prefix of <code>04</code>, compressed public keys start with either a <code>02</code> or a <code>03</code> prefix. Let&#8217;s look at why there are two possible prefixes: since the left side of the equation is y<sup>2</sup>, that means the solution for y is a square root, which can have a positive or negative value. Visually, this means that the resulting y-coordinate can be above the x-axis or below the x-axis. As you can see from the graph of the elliptic curve, the curve is symmetric, meaning it is reflected like a mirror by the x-axis. So, while we can omit the y-coordinate we have to store the <em>sign</em> of y (positive or negative), or in other words we have to remember if it was above or below the x-axis, as each of those options represents a different point and a different public key. When calculating the elliptic curve in binary arithmetic on the finite field of prime order p, the y coordinate is either even or odd, which corresponds to the positive/negative sign as explained above. Therefore, to distinguish between the two possible values of y, we store a <code>compressed public key</code> with the prefix <code>02</code> if the <code>y</code> is even, and <code>03</code> if it is odd, allowing the software to correctly deduce the y-coordinate from the x-coordinate and uncompress the public key to the full coordinates of the point.</p></div>
<div class="imageblock" id="pubkey_compression">
<div class="content">
<img src="images/pubkey_compression.png" alt="pubkey_compression" />
</div>
<div class="title">Figure 23. Public Key Compression</div>
</div>
<div class="paragraph"><p>Here&#8217;s the same public key generated previously, shown as a <code>compressed public key</code> stored in 264-bits (66 hex digits) with the prefix <code>03</code> indicating the <code>y</code> coordinate is odd:</p></div>
<div class="listingblock">
<div class="title">Compressed Public Key K shown in hex (66 hex digits) as <code>K = {02 or 03} x</code></div>
<div class="content">
<pre><code>K = 03F028892BAD...DC341A</code></pre>
</div></div>
<div class="paragraph"><p>The compressed public key, above, corresponds to the same private key, meaning that it is generated from the same private key. However it looks different from the uncompressed public key. More importantly, if we convert this compressed public key to a bitcoin address using the double-hash function (RIPEMD160(SHA256(K))) it will produce a <em>different</em> bitcoin address. This can be confusing, because it means that a single private key can produce a public key expressed in two different formats (compressed and uncompressed) which produce two different bitcoin addresses. However, the private key is identical for both bitcoin addresses.</p></div>
<div class="paragraph"><p>Compressed public keys are gradually becoming the default across bitcoin clients, which is having a significant impact on reducing the size of transactions and therefore the blockchain. However, not all clients support compressed public keys yet. Newer clients that support compressed public keys have to account for transactions from older clients which do not support compressed public keys. This is especially important when a wallet application is importing private keys from another bitcoin wallet application, because the new wallet needs to scan the blockchain to find transactions corresponding to these imported keys. Which bitcoin addresses should the bitcoin wallet scan for? The bitcoin addresses produced by uncompressed public keys, or the bitcoin addresses produced by compressed public keys? Both are valid bitcoin addresses, and can be signed for by the private key, but they are different addresses!</p></div>
<div class="paragraph"><p>To resolve this issue, when private keys are exported from a wallet, the Wallet Import Format that is used to represent them is implemented differently in newer bitcoin wallets, to indicate that these private keys have been used to produce <em>compressed</em> public keys and therefore <em>compressed</em> bitcoin addresses. This allows the importing wallet to distinguish between private keys originating from older or newer wallets and search the blockchain for transactions with bitcoin addresses corresponding to the uncompressed, or the compressed public keys respectively. Let&#8217;s look at how this works in more detail, in the next section.</p></div>
</div>
<div class="sect4">
<h5 id="comp_priv">Compressed Private Keys</h5>
<div class="paragraph"><p>Ironically, the name "compressed private key" is misleading, because when a private key is exported as WIF-compressed it is actually one byte <em>longer</em> than an "uncompressed" private key. That is because it has the added 01 suffix which signifies it comes from a newer wallet and should only be used to produce compressed public keys. Private keys are not compressed and cannot be compressed. The term "compressed private key" really means "private key from which compressed public keys should be derived", whereas "uncompressed private key" really means "private key from which uncompressed public keys should be derived". You should only refer to the export format as "WIF-compressed" or "WIF" and not refer to the private key as "compressed" to avoid further confusion.</p></div>
<div class="paragraph"><p>Remember, these formats are <em>not</em> used interchangeably. In a newer wallet that implements compressed public keys, the private keys will only ever be exported as WIF-compressed (with a K or L prefix). If the wallet is an older implementation and does not use compressed public keys, the private keys will only ever be exported as WIF (5 prefix). The goal here is to signal to the wallet importing these private keys whether it must search the blockchain for compressed or uncompressed public keys and addresses.</p></div>
<div class="paragraph"><p>If a bitcoin wallet is able to implement compressed public keys, then it will use those in all transactions. The private keys in the wallet will be used to derive the public key points on the curve, which will be compressed. The compressed public keys will be used to produce bitcoin addresses and those will be used in transactions. When exporting private keys from a new wallet that implements compressed public keys, the Wallet Import Format is modified, with the addition of a one-byte suffix +01+to the private key. The resulting base58check encoded private key is called a "Compressed WIF" and starts with the letter K or L, instead of starting with "5" as is the case with WIF encoded (non-compressed) keys from older wallets.</p></div>
<div class="paragraph"><p>Here&#8217;s the same key, encoded in WIF and WIF-compressed formats</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 4. Example: Same Key, Different Formats</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Format </th>
<th align="left" valign="top"> Private Key</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hex</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Hex-compressed</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD_01_</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF-compressed</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>"Compressed private keys" is a misnomer! They are not compressed, rather the WIF-compressed format signifies that they should only be used to derive compressed public keys and their corresponding bitcoin addresses. Ironically, a "WIF-compressed" encoded private key is one byte longer because it has the added 01 suffix to distinguish it from an "uncompressed" one.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_keys_and_addresses_in_python">Implementing Keys and Addresses in Python</h3>
<div class="paragraph"><p>The most comprehensive bitcoin library in Python is "pybitcointools"by Vitalik Buterin (<a href="https://github.com/vbuterin/pybitcointools">https://github.com/vbuterin/pybitcointools</a>). In the following code example, we use the pybitcointools library (imported as "bitcoin") to generate and display keys and addresses in various formats:</p></div>
<div class="exampleblock" id="key-to-address_script">
<div class="title">Example 3. Key and Address generation and formatting with the pybitcointools library</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Here&#8217;s the output from running this code:</p></div>
<div class="exampleblock" id="key-to-address_script_run">
<div class="title">Example 4. Running key-to-address-ecc-example.py</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Here&#8217;s another example, using the Python ECDSA library for the Elliptic Curve math and without using any specialized bitcoin libraries:</p></div>
<div class="exampleblock" id="ec_math">
<div class="title">Example 5. A script demonstrating Elliptic Curve math used for bitcoin keys</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Running the script:</p></div>
<div class="exampleblock" id="ec_math_run">
<div class="title">Example 6. Installing the Python ECDSA library and running the ec_math.py script</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_wallets">Wallets</h3>
<div class="paragraph"><p>Wallets are containers for private keys, usually implemented as structured files or simple databases.
Another method for making keys is <em>deterministic key generation</em>. Here you derive each new private key, using a one-way hash function from a previous private key, linking them in a sequence. As long as you can re-create that sequence, you only need the first key (known as a <em>seed</em> or <em>master</em> key) to generate them all. In this section we will examine the different methods of key generation and the wallet structures that are built around them.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Wallets contain keys, not coins. The coins are stored on the blockchain in the form of transaction-outputs (often noted as <em>vout</em> or <em>txout</em>). Each user has a wallet containing keys. Wallets are really keychains containing pairs of private/public keys (See <a href="#public key">[public key]</a>). Users sign transactions with the keys, thereby proving they own the transaction outputs (their coins).</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="random_wallet">Non-Deterministic (Random) Wallets</h4>
<div class="paragraph"><p>In the first implementations of bitcoin clients, wallets were simply collections of randomly generated private keys. This type of wallet is called a <em>Type-0 Non-Deterministic Wallets</em>. For example, the Bitcoin Core Client pre-generates 100 random private keys when first started and generates more keys as needed, using each key only once. This type of wallet is nicknamed "Just a Bunch Of Keys", or JBOK, and such wallets are being replaced with deterministic wallets because they are cumbersome to manage, backup and import. The disadvantage of random keys is that if you generate many of them you must keep copies of all of them, meaning that the wallet must be backed-up frequently. Each key must be backed-up, or the funds it controls are irrevocably lost if the wallet becomes inaccessible. This conflicts directly with the principle of avoiding address re-use, by using each bitcoin address for only one transaction. Address re-use reduces privacy by associating multiple transactions and addresses with each other. A Type-0 non-deterministic wallet is a poor choice of wallet, especially if you want to avoid address re-use as that means managing many keys, which creates the need for frequent backups. While the Bitcoin Core Client includes a wallet that is implemented as a Type-0 wallet, the use of this wallet is actively discouraged by developers of the Bitcoin Core.</p></div>
<div class="imageblock" id="Type0_wallet">
<div class="content">
<img src="images/non-deterministic_wallet.png" alt="non-deterministic wallet" />
</div>
<div class="title">Figure 24. Type-0 Non-Deterministic (Random) Wallet: A Collection of Randomly Generated Keys</div>
</div>
</div>
<div class="sect3">
<h4 id="_deterministic_seeded_wallets">Deterministic (Seeded) Wallets</h4>
<div class="paragraph"><p>Deterministic, or "seeded" wallets are wallets that contain private keys which are all derived from a common seed, through the use of a one-way hash function. The seed is a randomly generated number which is combined with other data, such as an index number or "chain code" (see <a href="#hd_wallets">[hd_wallets]</a>) to derive the private keys. In a deterministic wallet, the seed is sufficient to recover all the derived keys and therefore a single backup at creation time is sufficient. The seed is also sufficient for a wallet export or import, allowing for easy migration of all the user&#8217;s keys between different wallet implementations.</p></div>
</div>
<div class="sect3">
<h4 id="mnemonic_code_words">Mnemonic Code Words</h4>
<div class="paragraph"><p>Mnemonic codes are English word sequences that represent (encode) a random number used as a seed to derive a deterministic wallet. The sequence of words is sufficient to re-create the seed and from there re-create the wallet and all the derived keys. A wallet application that implements deterministic wallets with mnemonic code will show the user a sequence of 12-24 words when first creating a wallet. That sequence of words is the wallet backup and can be used to recover and re-create all the keys in the same or any compatible wallet application. Mnemonic code words make it easier for users to back up wallets, as they are easy to read and correctly transcribe, as compared to a random sequence of numbers.</p></div>
<div class="paragraph"><p>Mnemonic codes are defined in Bitcoin Improvement Proposal 39 (see <a href="#bip0039">[bip0039]</a>), currently in Draft status. Note that BIP0039 is a draft proposal and not a standard. Specifically, there is a different standard, with a different set of words used by the Electrum wallet and <em>predating</em> BIP0039. BIP0039 is used by the Trezor wallet and a few other wallets but is incompatible with Electrum&#8217;s implementation.</p></div>
<div class="paragraph"><p>BIP0039 defines the creation of a mnemonic code and seed as a follows:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Create a random sequence (entropy) of 128 to 256 bits
</p>
</li>
<li>
<p>
Create a checksum of the random sequence by taking the first few bits of its SHA256 hash
</p>
</li>
<li>
<p>
Add the checksum to the end of the random sequence
</p>
</li>
<li>
<p>
Divide the sequence into sections of 11 bits, using those to index a dictionary of 2048 pre-defined words
</p>
</li>
<li>
<p>
Produce 12-24 words representing the mnemonic code
</p>
</li>
</ol></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 5. Mnemonic Codes: Entropy and Word Length</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top">Entropy (bits) </th>
<th align="left" valign="top"> Checksum (bits) </th>
<th align="left" valign="top"> Entropy+Checksum </th>
<th align="left" valign="top"> Word Length</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">128</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">132</p></td>
<td align="left" valign="top"><p class="table">12</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">160</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">165</p></td>
<td align="left" valign="top"><p class="table">15</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">192</p></td>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">198</p></td>
<td align="left" valign="top"><p class="table">18</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">224</p></td>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">231</p></td>
<td align="left" valign="top"><p class="table">21</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">256</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">264</p></td>
<td align="left" valign="top"><p class="table">24</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The mnemonic code represents 128 to 256 bits which are used to derive a longer (512 bit) seed through the use of the key-stretching function PBKDF2. The resulting seed is used to create a deterministic wallet and all of its derived keys.</p></div>
<div class="paragraph"><p>Here are some examples of mnemonic codes and the seeds they produce:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 6. 128-bit entropy mnemonic code and resulting seed</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">entropy input (128 bits)</p></td>
<td align="left" valign="top"><p class="table">0c1e24e5917779d297e14d45f14e1a1a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mnemonic (12 words)</p></td>
<td align="left" valign="top"><p class="table">army van defense carry jealous true garbage claim echo media make crunch</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">seed  (512 bits)</p></td>
<td align="left" valign="top"><p class="table">3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88\
8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 7. 256-bit entropy mnemonic code and resulting seed</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">entropy input (256 bits)</p></td>
<td align="left" valign="top"><p class="table">2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mnemonic (24 words)</p></td>
<td align="left" valign="top"><p class="table">cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">seed  (512 bits)</p></td>
<td align="left" valign="top"><p class="table">3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22\
fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="hd_wallets">Hierarchical Deterministic Wallets (BIP0032/BIP0044)</h4>
<div class="paragraph"><p>Deterministic wallets were developed to make it easy to derive many keys from a single "seed". The most advanced form of deterministic wallets is the <em>Hierarchical Deterministic Wallet</em> or <em>HD Wallet</em> defined by the BIP0032 standard. Hierarchical deterministic wallets contain keys derived in a tree structure, such that a parent key can derive a sequence of children keys, each of which can derive a sequence of grandchildren keys and so on to an infinite depth. This tree structure is illustrated below:</p></div>
<div class="imageblock" id="Type2_wallet">
<div class="content">
<img src="images/HD_wallet.png" alt="HD wallet" />
</div>
<div class="title">Figure 25. Type-2 Hierarchical Deterministic Wallet: A Tree of Keys Generated from a Seed</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>If you are implementing a bitcoin wallet, it should be built as an HD wallet following the BIP0032 and BIP0044 standards.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>HD wallets offer two major advantages over random (non-deterministic) keys. First, the tree structure can be used to express additional organizational meaning, such as when a specific branch of sub-keys is used to receive incoming payments and a different branch is used to receive change from outgoing payments. Branches of keys can also be used in a corporate setting, allocating different branches to departments, subsidiaries, specific functions or accounting categories.</p></div>
<div class="paragraph"><p>The second advantage of HD wallets is that users can create a sequence of public keys without having access to the corresponding private keys. This allows HD wallets to be used on an insecure server or in a receive-only capacity, issuing a different public key for each transaction. The public keys do not need to be pre-loaded or derived in advance, yet the server doesn&#8217;t have the private keys that can spend the funds.</p></div>
<div class="sect4">
<h5 id="_hd_wallet_creation_from_a_seed">HD wallet creation from a seed</h5>
<div class="paragraph"><p>HD wallets are created from a single <em>root seed</em>, which is a 128, 256 or 512 bit random number. Everything else in the HD wallet is deterministically derived from this root seed, which makes it possible to re-create the entire HD wallet from that seed in any compatible HD wallet. This makes it easy to backup, restore, export and import HD wallets containing thousands or even millions of keys by simply transferring only the root seed. The root seed is most often represented by a <em>mnemonic word sequence</em>, as described in the previous section <a href="#mnemonic_code_words">[mnemonic_code_words]</a>, to make it easier for people to transcribe and store it.</p></div>
<div class="paragraph"><p>The process of creating the master keys and master chain code for an HD wallet is shown below:</p></div>
<div class="imageblock" id="HDWalletFromSeed">
<div class="content">
<img src="images/HDWalletFromRootSeed.png" alt="HDWalletFromRootSeed" />
</div>
<div class="title">Figure 26. Creating master keys and chain code from a root seed</div>
</div>
<div class="paragraph"><p>The root seed is input into the HMAC-SHA512 algorithm and the resulting hash is used to create a <em>master private key</em> (m) and a <em>master chain code</em>. The master private key (m) then generates a corresponding master public key (M), using the normal elliptic curve multiplication process <code>m * G</code> that we saw previously in this chapter. The chain code is used to introduce entropy in the function that creates child keys from parent keys, as we will see in the next section.</p></div>
</div>
<div class="sect4">
<h5 id="_private_child_key_derivation">Private child key derivation</h5>
<div class="paragraph"><p>Hierarchical Deterministic wallets use a <em>child key derivation</em> (CKD) function to derive children keys from parent keys.</p></div>
<div class="paragraph"><p>The child key derivation functions are based on one-way hash functions that combines:</p></div>
<div class="ulist"><ul>
<li>
<p>
A parent private or public key (ECDSA uncompressed key)
</p>
</li>
<li>
<p>
A seed called a chain code (256 bits)
</p>
</li>
<li>
<p>
An index number (32 bits)
</p>
</li>
</ul></div>
<div class="paragraph"><p>The chain code is used to introduce seemingly random data to the process, so that the index is not sufficient to derive other child keys. Thus, having a child key does not make it possible to find its siblings, unless you also have the chain code. The initial chain code seed (at the root of the tree) is made from random data, while subsequent chain codes are derived from each parent chain code.</p></div>
<div class="paragraph"><p>These three items are combined and hashed to generate children keys, as follows:</p></div>
<div class="paragraph"><p>The parent public key, chain code and the index number are combined and hashed with the HMAC-SHA512 algorithm to produce a 512 bit hash. The resulting hash is split into two halfs. The right-half 256 bits of the hash output become the chain code for the child. The left-half 256 bits of the hash and the index number are added to the parent private key to produce the child private key. In the diagram below, we see this illustrated with the index set to 0 to produce the 0&#8217;th (first by index) child of the parent.</p></div>
<div class="imageblock" id="CKDpriv">
<div class="content">
<img src="images/ChildPrivateDerivation.png" alt="ChildPrivateDerivation" />
</div>
<div class="title">Figure 27. Extending a parent private key to create a child private key</div>
</div>
<div class="paragraph"><p>Changing the index allows us to extend the parent and create the other children in the sequence, e.g. Child 0, Child 1, Child 2 etc. Each parent key can have 2 billion children keys.</p></div>
<div class="paragraph"><p>Repeating the process one level down the tree, each child can in turn become a parent and create its own children, in an infinite number of generations.</p></div>
</div>
<div class="sect4">
<h5 id="_using_derived_child_keys">Using derived child keys</h5>
<div class="paragraph"><p>Child private keys are indistinguishable from non-deterministic (random) keys. Because the derivation function is a one way function, the child key cannot be used to find the parent key. The child key can also not be used to find any siblings. If you have the n<sub>th</sub> child, you cannot find its siblings, such as the n-1 child or the n+1 child, or any other children that are part of the sequence. Only the parent key and chain code can derive all the children. Without the child chain code, the child key cannot be used to derive any grandchildren either. You need both the child private key and the child chain code to start a new branch and derive grandchildren.</p></div>
<div class="paragraph"><p>So what can the child private key be used for on its own? It can be used to make a public key and a bitcoin address. Then, it can be used to sign transactions to spend anything paid to that address.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A child private key, the corresponding public key and the bitcoin address are all indistinguishable from keys and addresses created randomly. The fact that they are part of a sequence is not visible, outside of the HD wallet function that created them. Once created, they operate exactly as "normal" keys.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="_extended_keys">Extended keys</h5>
<div class="paragraph"><p>As we saw above, the key derivation function can be used to create children at any level of the tree, based on the three inputs: a key, a chain code and the index of the desired child. The two essential ingredients are the key and chain code and combined these are called an <em>extended key</em>. The term "extended key" could also be thought of as "extensible key" because such a key can be used to derive children.</p></div>
<div class="paragraph"><p>Extended keys are stored and represented simply as the concatenation of the 256 bit key and 256 bit chain code into a 512 bit sequence. There are two types of extended keys: An extended private key is the combination of a private key and chain code and can be used to derive child private keys (and from them, child public keys). An extended public key is a public key and chain code, which can be used to create child public keys, as described in <a href="#public_key_derivation">[public_key_derivation]</a>.</p></div>
<div class="paragraph"><p>Think of an extended key as the root of a branch in the tree structure of the HD wallet. With the root of the branch, you can derive the rest of the branch. The extended private key can create a complete branch, whereas the extended public key can only create a branch of public keys.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>An extended key consists of a private or public key and chain code. An extended key can create children generating its own branch in the tree structure. Sharing an extended key gives access to the entire branch.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Extended keys are encoded using Base58Check, to easily export and import between different BIP0032 compatible wallets. The Base58Check coding for extended keys uses a special version number that results in the prefix "xprv" and "xpub" when encoded in base 58 characters, to make them easily recognizable. Since the extended key is 512 or 513 bits, it is also much longer than other Base58Check encoded strings we have seen previously.</p></div>
<div class="paragraph"><p>Here&#8217;s an example of an extended private key, encoded in Base58Check:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</code></pre>
</div></div>
<div class="paragraph"><p>Here&#8217;s the corresponding extended public key, also encoded in Base58Check:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</code></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="public_key_derivation">Public child key derivation</h5>
<div class="paragraph"><p>As mentioned above, a very useful characteristic of hierarchical deterministic wallets is the ability to derive public child keys from public parent keys, <em>without</em> having the private keys. This gives us two ways to derive a child public key: either from the child private key, or directly from the parent public key.</p></div>
<div class="paragraph"><p>An extended public key can be used, therefore, to derive all of the <em>public</em> keys (and only the public keys) in that branch of the HD wallet structure.</p></div>
<div class="paragraph"><p>This shortcut can be used to create very secure public-key-only deployments where a server or application has a copy of an extended public key and no private keys whatsoever. That kind of deployment can produce an infinite number of public keys and bitcoin addresses but cannot spend any of the money sent to those addresses. Meanwhile, on another more secure server, the extended private key can derive all the corresponding private keys to sign transactions and spend the money.</p></div>
<div class="paragraph"><p>One common application of this solution is to install an extended public key on a web server that serves an e-commerce application. The web server can use the public key derivation function to create a new bitcoin address for every transaction (e.g. for a customer shopping cart). The web server will not have any private keys that would be vulnerable to theft. Without HD wallets, the only way to do this is to generate thousands of bitcoin addresses on a separate secure server and then pre-load them on the e-commerce server. That approach is cumbersome and requires constant maintenance to ensure that the e-commerce server doesn&#8217;t "run out" of keys.</p></div>
<div class="paragraph"><p>Another common application of this solution is for cold-storage or hardware wallets. In that scenario, the extended private key can be stored on a paper wallet or hardware device (such as a Trezor hardware wallet), while the extended public key can be kept online. The user can create "receive" addresses at will, while the private keys are safely stored offline. To spend the funds, they can use the extended private key on an offline signing bitcoin client or sign transactions on the hardware wallet device (e.g. Trezor).</p></div>
<div class="imageblock" id="CKDpub">
<div class="content">
<img src="images/ChildPublicDerivation.png" alt="ChildPublicDerivation" />
</div>
<div class="title">Figure 28. Extending a parent public key to create a child public key</div>
</div>
</div>
<div class="sect4">
<h5 id="_hardened_child_key_derivation">Hardened child key derivation</h5>
<div class="paragraph"><p>The ability to derive a branch of public keys from an extended public key is very useful, but it comes with a potential risk. Access to an extended public key does not give access to child private keys. However, because the extended public key contains the chain code, if a child private key is known, or somehow leaked, it can be used with the chain code to derive all the other child private keys. A single leaked child private key, together with a parent chain code, reveals all the private keys of all the children. Worse, the child private key together with a parent chain code can be used to deduce the parent private key.</p></div>
<div class="paragraph"><p>To counter this risk, HD wallets use an alternative derivation function called <em>hardened derivation</em>, which "breaks" the relationship between parent public key and child chain code. The hardened derivation function uses the parent private key to derive the child chain code, instead of the parent public key. This creates a "firewall" in the parent/child sequence, with a chain code that cannot be used to compromise a parent or sibling private key. The hardened derivation function looks almost identical to the normal child private key derivation, except that the parent private key is used as input to the hash function, instead of the parent public key, as shown in the diagram below:</p></div>
<div class="imageblock" id="CKDprime">
<div class="content">
<img src="images/ChildHardPrivateDerivation.png" alt="ChildHardPrivateDerivation" />
</div>
<div class="title">Figure 29. Hardened derivation of a child key, omits the parent public key</div>
</div>
<div class="paragraph"><p>When the hardened private derivation function is used, the resulting child private key and chain code are completely different from what would result from the normal derivation function. The resulting "branch" of keys can be used to produce extended public keys which are not vulnerable, since the chain code they contain cannot be exploited to reveal any private keys. Hardened derivation is therefore used to create a "gap" in the tree above the level where extended public keys are used.</p></div>
<div class="paragraph"><p>In simple terms, if you want to use the convenience of an extended public key to derive branches of public keys, without exposing yourself to the risk of a leaked chain code, you should derive it from a hardened parent, rather than a normal parent. As a best practice, the level-1 children of the master keys are always derived through the hardened derivation, to prevent compromise of the master keys.</p></div>
</div>
<div class="sect4">
<h5 id="_index_numbers_for_normal_and_hardened_derivation">Index numbers for normal and hardened derivation</h5>
<div class="paragraph"><p>The index number used in the derivation function is a 32-bit integer. To easily distinguish between keys derived through the normal derivation function versus keys derived through hardened derivation, this index number is split into two ranges. Index numbers between 0 and 2<sup>31</sup>-1 (0x0 to 0x7FFFFFFF) are used <em>only</em> for normal derivation. Index numbers between 2<sup>31</sup> and 2<sup>32</sup>-1 (0x80000000 to 0xFFFFFFFF) are used <em>only</em> for hardened derivation. Therefore, if the index number is less than 2<sup>31</sup>, that means the child is normal, whereas if the index number is equal or above 2<sup>31</sup>, the child is hardened.</p></div>
<div class="paragraph"><p>To make the index number easier to read and display, the index number for hardened children is displayed starting from zero, but with a prime symbol. The first normal child key is therefore displayed as 0, whereas the first hardened child (index 0x80000000) is displayed as 0'. In sequence then, the second hardened key would have index 0x80000001 and would be displayed as 1', and so on. When you see an HD wallet index i', that means 2<sup>31</sup>+i.</p></div>
</div>
<div class="sect4">
<h5 id="_hd_wallet_key_identifier_path">HD wallet key identifier (path)</h5>
<div class="paragraph"><p>Keys in an HD wallet are identified using a "path" naming convention, with each level of the tree separated by a slash (/) character. Private keys derived from the master private key start with "m". Public keys derived from the master public key start with "M". Therefore, the first child private key of the master private key is m/0. The first child public key is M/0. The second grandchild of the first child is m/0/1 and so on.</p></div>
<div class="paragraph"><p>The "ancestry" of a key is read from right to left, until you reach the master key from which it was derived. For example, identifier m/x/y/z describes the key which is the z-th child of key m/x/y, which is the y-th child of key m/x, which is the x-th child of m.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 8. HD wallet path examples</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">m/0</p></td>
<td align="left" valign="top"><p class="table">The first (0) child private key from the master private key (m)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0/0</p></td>
<td align="left" valign="top"><p class="table">The first grandchild private key of the first child (m/0)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0'/0</p></td>
<td align="left" valign="top"><p class="table">The first normal grandchild of the first <em>hardened</em> child (m/0')</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/1/0</p></td>
<td align="left" valign="top"><p class="table">The first grandchild private key of the second child (m/1)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/23/17/0/0</p></td>
<td align="left" valign="top"><p class="table">The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the 24th child</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_navigating_the_hd_wallet_tree_structure">Navigating the HD wallet tree structure</h5>
<div class="paragraph"><p>The HD wallet tree structure offers tremendous flexibility. Each parent extended key can have 4 billion children: 2 billion normal children and 2 billion hardened children. Each of those children can have another 4 billion children and so on. The tree can be as deep as you want, with an infinite number of generations. With all that flexibility, however, it becomes quite difficult to navigate this infinite tree. It is especially difficult to transfer HD wallets between implementations, because the possibilities for internal organization into branches and sub-branches are endless.</p></div>
<div class="paragraph"><p>Two Bitcoin Improvement Proposals (BIPs) offer a solution to this complexity, by creating some proposed standards for the structure of HD wallet trees. BIP0043 proposes the use of the first hardened child index as a special identifier that signifies the "purpose" of the tree structure. Based on BIP0043, an HD wallet should use only one level-1 branch of the tree, with the index number identifying the structure and namespace of the rest of the tree by defining its purpose. For example, an HD wallet using only branch m/i'/, is intended to signify a specific purpose and that purpose is identified by index number "i".</p></div>
<div class="paragraph"><p>Extending that specification, BIP0044 proposes a multi-account structure as "purpose" number <code>44'</code> under BIP0043. All HD wallets following the BIP0044 structure are identified by the fact that they only used one branch of the tree: m/44'/.</p></div>
<div class="paragraph"><p>BIP0044 specifies the structure as consisting of five pre-defined tree levels:</p></div>
<div class="paragraph"><p><code>m / purpose' / coin_type' / account' / change / address_index</code></p></div>
<div class="paragraph"><p>The first level "purpose" is always set to <code>44'</code>. The second level "coin_type" specifies the type of crypto-currency coin, allowing for multi-currency HD wallets where each currency has its own subtree under the second level. There are three currencies defined for now: Bitcoin is m/44'/0', Bitcoin Testnet is m/44'/1' and Litecoin is m/44'/2'.</p></div>
<div class="paragraph"><p>The third level of the tree is "account", which allows users to subdivide their wallets into separate logical sub-accounts, for accounting or organizational purposes. For example, an HD wallet might contain two bitcoin "accounts": m/44'/0'/0' and m/44'/0'/1'. Each account is the root of its own sub-tree.</p></div>
<div class="paragraph"><p>On the fourth level "change", an HD wallet has two sub-trees, one for creating receiving addresses and one for creating change addresses. Note that whereas the previous levels used hardened derivation, this level uses normal derivation. This is to allow this level of the tree to export extended public keys for use in an non-secured environment. Usable addresses are derived by the HD wallet as children of the fourth level, making the fifth level of the tree the "address_index". For example, the third receiving address for bitcoin payments in the primary account would be M/44'/0'/0'/0/2. Here are a few more examples:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 9. BIP0044 HD wallet structure examples</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/0'/0/2</p></td>
<td align="left" valign="top"><p class="table">The third receiving public key for the primary bitcoin account</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/3'/1/14</p></td>
<td align="left" valign="top"><p class="table">The fifteenth change-address public key for the fourth bitcoin account</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/44'/2'/0'/0/1</p></td>
<td align="left" valign="top"><p class="table">The second private key in the Litecoin main account, for signing transactions</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_experimenting_with_hd_wallets_using_sx_tools">Experimenting with HD wallets using sx-tools</h5>
<div class="paragraph"><p>Using the command line tool <code>sx</code>, introduced in chapter 3, you can experiment with generating and extending BIP0032 deterministic keys, as well as displaying them in different formats:</p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_keys_and_addresses">Advanced Keys and Addresses</h3>
<div class="sect3">
<h4 id="_encrypted_private_keys_bip0038">Encrypted Private Keys (BIP0038)</h4>
<div class="paragraph"><p>Private keys must remain secret. The need for <em>confidentiality</em> of the private keys is a truism which is quite difficult to achieve in practice, as it conflicts with the equally important security objective of <em>availability</em>. Keeping the private key private is much harder when you need to store backups of the private key to avoid losing it. A private key stored in a wallet that is encrypted by a password may be secure, but that wallet needs to be backed up. At times, users need to move keys from one wallet to another&#8201;&#8212;&#8201;to upgrade or replace the wallet software, for example. Private key backups might also be stored on paper (see <a href="#paper_wallets">[paper_wallets]</a>) or on external storage media, such as a USB flash drive. But what if the backup itself is stolen or lost? These conflicting security goals led to the introduction of a portable and convenient standard for encrypting private keys in a way that can be understood by many different wallets and bitcoin clients, standardized by Bitcoin Improvement Proposal 38  or BIP0038 (see <a href="#bip0038">[bip0038]</a>).</p></div>
<div class="paragraph"><p>BIP0038 proposes a common standard for encrypting private keys with a passphrase and encoding them with Base58Check so that they can be stored securely on backup media, transported securely between wallets or in any other conditions where the key might be exposed. The standard for encryption uses the Advanced Encryption Standard (AES), a standard established by the National Institute of Standards and Technology (NIST) and used broadly in data encryption implementations for commercial and military applications.</p></div>
<div class="paragraph"><p>A BIP0038 encryption scheme takes as input a bitcoin private key, usually encoded in the Wallet Import Format (WIF), as a Base58Check string with a prefix of "5".  Additionally, the BIP0038 encryption scheme takes a passphrase&#8201;&#8212;&#8201;a long password&#8201;&#8212;&#8201;usually composed of several words or a complex string of alphanumeric characters. The result of the BIP0038 encryption scheme is a Base58Check encoded encrypted private key that begins with the prefix <code>6P</code>. If you see a key that starts with <code>6P</code> that means it is encrypted and requires a passphrase in order to convert (decrypt) it back into a WIF-formatted private key (prefix <code>5</code>) that can be used in any wallet. Many wallet applications now recognize BIP0038 encrypted private keys and will prompt the user for a passphrase to decrypt and import the key. Third party applications, such as the incredibly useful browser-based bitaddress.org (Wallet Details tab), can be used to decrypt BIP0038 keys.</p></div>
<div class="paragraph"><p>The most common use case for BIP0038 encrypted keys is for paper wallets that can be used to backup private keys on a piece of paper. As long as the user selects a strong passphrase, a paper wallet with BIP0038 encrypted private keys is incredibly secure and a great way to create offline bitcoin storage (also known as "cold storage").</p></div>
<div class="paragraph"><p>Test the following encrypted keys using bitaddress.org to see how you can get the decrypted key by entering the passphrase:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 10. Example of BIP0038 Encrypted Private Key</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Private Key (WIF)</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Passphrase</p></td>
<td align="left" valign="top"><p class="table">MyTestPassphrase</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Encrypted Key (BIP0038)</p></td>
<td align="left" valign="top"><p class="table">6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="p2sh_addresses">Pay To Script Hash (P2SH) and Multi-Sig Addresses</h4>
<div class="paragraph"><p>As we know, traditional bitcoin addresses begin with the number “1” and are derived from the public key, which is derived from the private key.  While anyone can send bitcoin to a “1” address, that bitcoin can only be spent by presenting the corresponding private key signature and public key hash.</p></div>
<div class="paragraph"><p>Bitcoin addresses that begin with the number “3” are pay-to-script-hash (P2SH) addresses, sometimes erroneously called multi-signature or multi-sig addresses. They designate the beneficiary of a bitcoin transaction as the hash of a script, instead of the owner of a public key. The feature was introduced in January 2012 with Bitcoin Improvement Proposal 16 or BIP0016 (see <a href="#bip0016">[bip0016]</a>) and is being widely adopted because it provides the opportunity to add functionality to the address itself. Unlike transactions that "send" funds to traditional “1” bitcoin addresses, also known as pay-to-public-key-hash (P2PKH), funds sent to “3” addresses require something more than the presentation of one public key hash and one private key signature as proof of ownership. The requirements are designated at the time the address is created, within the script, and all inputs to this address will be encumbered with the same requirements.</p></div>
<div class="paragraph"><p>A pay-to-script-hash address is created from a transaction script, which defines who can spend a transaction output (for more detail, see <a href="#p2sh">[p2sh]</a>). Encoding a pay-to-script hash address involves using the same double-hash function as used during creation of a bitcoin address, only applied on the script instead of the public key.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>script hash = RIPEMD160(SHA256(script))</code></pre>
</div></div>
<div class="paragraph"><p>The resulting "script hash" is encoded with Base58Check with a version prefix of 5, which results in an encoded address starting with a <code>3</code>. An example of a P2SH address is <code>32M8ednmuyZ2zVbes4puqe44NZumgG92sM</code></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>P2SH is not necessarily the same as a multi-signature standard transaction. A P2SH address <em>most often</em> represents a multi-signature script, but it might also represent a script encoding other types of transactions.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_multi_signature_addresses_and_p2sh">Multi-signature addresses and P2SH</h5>
<div class="paragraph"><p>Currently, the most common implementation of the P2SH function is the multi-signature address script. As the name implies, the underlying script requires more than one signature to prove ownership and therefore spend funds. The bitcoin multi-signature feature is designed to require M signatures (also known as the “threshold”) from a total of N keys, known as an M-of-N multi-sig, where M is equal to or less than N. For example, Bob the coffee shop owner from chapter 1 could use a multi-signature address requiring 1-of-2 signatures from a key belonging to him and a key belonging to his spouse, ensuring either of them could sign to spend a transaction output locked to this address. This would be similar to a “joint account” as implemented in traditional banking where either spouse can spend with a single signature. Or Gopesh, the web designer paid by Bob to create a website might have a 2-of-3 multi-signature address for his business that ensures that no funds can be spent unless at least two of the business partners sign a transaction.</p></div>
<div class="paragraph"><p>We will explore how to create transactions that spend funds from P2SH (and multi-signature) addresses in <a href="#transactions">[transactions]</a>.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_vanity_addresses">Vanity Addresses</h4>
<div class="paragraph"><p>Vanity addresses are valid bitcoin addresses that contain human-readable messages, for example 1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33 is a valid address that contains the letters forming the word "Love" as the first four Base-58 letters. Vanity addresses require generating and testing billions of candidate private keys, until one derives a bitcoin address with the desired pattern. While there are some optimizations in the vanity generation algorithm, the process essentially involves picking a private key at random, deriving the public key, deriving the bitcoin address and checking to see if it matches the desired vanity pattern, repeating billions of times until a match is found.</p></div>
<div class="paragraph"><p>Once a vanity address matching the desired pattern is found, the private key from which it was derived can be used by the owner to spend bitcoins in exactly the same way as any other address. Vanity addresses are no less or more secure than any other address. They depend on the same Elliptic Curve Cryptography (ECC) and Secure Hash Algorithm (SHA) as any other address. You can no easier find the private key of an address starting with a vanity pattern than you can any other address.</p></div>
<div class="paragraph"><p>In our first chapter, we introduced Eugenia, a children&#8217;s charity director operating in the Philippines. Let&#8217;s say that Eugenia is organizing a bitcoin fundraising drive and wants to use a vanity bitcoin address to publicize the fundraising. Eugenia will create a vanity address that starts with "1Kids", to promote the children&#8217;s charity fundraiser. Let&#8217;s see how this vanity address will be created and what it means for the security of Eugenia&#8217;s charity.</p></div>
<div class="sect4">
<h5 id="_generating_vanity_addresses">Generating Vanity Addresses</h5>
<div class="paragraph"><p>It&#8217;s important to realize that a bitcoin address is simply a number represented by symbols in the Base-58 alphabet. The search for a pattern like "1Kids" can be seen as searching for an address in the range from "1Kids11111111111111111111111111111" to "1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz". There are approximately 58<sup>29</sup> (approximately 1.4 * 10<sup>51</sup>) addresses in that range, all starting with "1Kids".</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 11. The range of vanity addresses starting with "1Kids"</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">From</p></td>
<td align="left" valign="top"><p class="table">1Kids11111111111111111111111111111</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">To</p></td>
<td align="left" valign="top"><p class="table">1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Let&#8217;s look at the pattern "1Kids" as a number and see how frequently we might find this pattern in a bitcoin address. An average desktop computer PC, without any specialized hardware, can search approximately 100,000 keys per second.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 12. The frequency of a vanity pattern (1KidsCharity) and average time-to-find on a desktop PC</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top"> Length </th>
<th align="left" valign="top"> Pattern </th>
<th align="left" valign="top"> Frequency </th>
<th align="left" valign="top"> Average Search Time</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table">1K</p></td>
<td align="left" valign="top"><p class="table">1 in 58 keys</p></td>
<td align="left" valign="top"><p class="table">&lt; 1 milliseconds</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table">1Ki</p></td>
<td align="left" valign="top"><p class="table">1 in 3,364</p></td>
<td align="left" valign="top"><p class="table">50 milliseconds</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table">1Kid</p></td>
<td align="left" valign="top"><p class="table">1 in 195,000</p></td>
<td align="left" valign="top"><p class="table">&lt; 2 seconds</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">1Kids</p></td>
<td align="left" valign="top"><p class="table">1 in 11 million</p></td>
<td align="left" valign="top"><p class="table">1 minute</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">1KidsC</p></td>
<td align="left" valign="top"><p class="table">1 in 656 million</p></td>
<td align="left" valign="top"><p class="table">1 hour</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">1KidsCh</p></td>
<td align="left" valign="top"><p class="table">1 in 38 billion</p></td>
<td align="left" valign="top"><p class="table">2 days</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">1KidsCha</p></td>
<td align="left" valign="top"><p class="table">1 in 2.2 trillion</p></td>
<td align="left" valign="top"><p class="table">3-4 months</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">1KidsChar</p></td>
<td align="left" valign="top"><p class="table">1 in 128 trillion</p></td>
<td align="left" valign="top"><p class="table">13-18 years</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">9</p></td>
<td align="left" valign="top"><p class="table">1KidsChari</p></td>
<td align="left" valign="top"><p class="table">1 in 7 quadrillion</p></td>
<td align="left" valign="top"><p class="table">800 years</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">10</p></td>
<td align="left" valign="top"><p class="table">1KidsCharit</p></td>
<td align="left" valign="top"><p class="table">1 in 400 quadrillion</p></td>
<td align="left" valign="top"><p class="table">46,000 years</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">11</p></td>
<td align="left" valign="top"><p class="table">1KidsCharity</p></td>
<td align="left" valign="top"><p class="table">1 in 23 quintillion</p></td>
<td align="left" valign="top"><p class="table">2.5 million years</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>As you can see, Eugenia won&#8217;t be creating the vanity address "1KidsCharity" any time soon, even if she had access to several thousand computers. Each additional character increases the difficulty by a factor of 58. Patterns with more than seven characters are usually found by specialized hardware, such as custom-built desktops with multiple Graphical Processing Units (GPUs). These are often re-purposed bitcoin mining "rigs" that are no longer profitable for bitcoin mining but can be used effectively to find vanity addresses. Vanity searches on GPU systems are many orders of magnitude faster than on a general-purpose CPU.</p></div>
<div class="paragraph"><p>Another way to find a vanity address is to outsource the work to a pool of vanity-miners, such as the pool at vanitypool.appspot.com. A pool is a service that allows those with GPU hardware to earn bitcoin searching for vanity addresses for others. For a small payment (0.01 bitcoin or approximately $5 when this was written), Eugenia can outsource the search for a 7-character pattern vanity address and get results in a few hours instead of having to run a CPU search for months.</p></div>
<div class="paragraph"><p>Generating a vanity address is a brute-force exercise: try a random key, check the resulting address to see if it matches the desired pattern, repeat until successful. Here&#8217;s an example of a "vanity miner", a program designed to find vanity addresses, written in C++. The example uses the libbitcoin library, which we introduced in <a href="#alt_libraries">[alt_libraries]</a>.</p></div>
<div class="exampleblock" id="vanity_miner_code">
<div class="title">Example 7. Vanity Address Miner</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The example code must be compiled using a C++ compiler and linked against the libbitcoin library (which must be first installed on that system). To run the example, run the <code>vanity-minder</code> executable with no parameters and it will attempt to find a vanity address starting with "1kid":</p></div>
<div class="exampleblock" id="vanity_miner_run">
<div class="title">Example 8. Compiling and running the vanity-miner example</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The example code will take a few seconds to find a match for the three-character pattern "kid", as we can see when we use the <code>time</code> Unix command to measure the execution time. Change the <code>search</code> pattern in the source code and see how much longer it takes for four- or five-character patterns!</p></div>
</div>
<div class="sect4">
<h5 id="_vanity_address_security">Vanity Address Security</h5>
<div class="paragraph"><p>Vanity addresses can be used to enhance <em>and</em> to defeat security measures, they are truly a double-edged sword. Used to improve security, a distinctive address makes it harder for adversaries to substitute their own address and fool your customers into paying them instead of you. Unfortunately, vanity addresses also make it possible for anyone to create an address that <em>resembles</em> any random address, or even another vanity address, thereby fooling your customers.</p></div>
<div class="paragraph"><p>Eugenia could advertise a randomly generated address (e.g. 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy) to which people can send their donations. Or, she could generate a vanity address that starts with 1Kids, to make it more distinctive.</p></div>
<div class="paragraph"><p>In both cases, one of the risks of using a single fixed address (rather than a separate dynamic address per donor) is that a thief might be able to infiltrate your website and replace it with their own address, thereby diverting donations to themselves. If you have advertised your donation address in a number of different places, your users may visually inspect the address before making a payment to ensure it is the same one they saw on your website, on your email, and on your flyer. In the case of a random address like "1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy", the average user will inspect the first few characters "1J7mdg" perhaps and be satisfied that the address matches. Using a vanity address generator, someone with the intent to steal by substituting a similar-looking address can quickly generate addresses that match the first few characters:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 13. Generating vanity addresses to match a random address</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Original Random Address</p></td>
<td align="left" valign="top"><p class="table">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vanity (4 character match)</p></td>
<td align="left" valign="top"><p class="table">1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vanity (5 character match)</p></td>
<td align="left" valign="top"><p class="table">1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vanity (6 character match)</p></td>
<td align="left" valign="top"><p class="table">1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>So does a vanity address increase security? If Eugenia generates the vanity address "1Kids33q44erFfpeXrmDSz7zEqG2FesZEN",
users are likely to look at the vanity pattern word <em>and a few characters beyond</em>, for example noticing the "1Kids33" part of the address. That would force an attacker to generate a vanity address matching at least 6 characters (2 more), expending an effort that is 3,364 times (58 x 58) higher than the effort Eugenia expended for her 4 character vanity. Essentially, the effort Eugenia expends (or pays a vanity pool for) "pushes" the attacker into having to produce a longer pattern vanity. If Eugenia pays a pool to generate an 8 character vanity address, the attacker would be pushed into the realm of 10 characters which is infeasible on a personal computer and expensive even with a custom vanity-mining rig or vanity pool. What is affordable for Eugenia becomes unaffordable for the attacker, especially if the potential reward of fraud is not high enough to cover the cost of the vanity address generation.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="paper_wallets">Paper Wallets</h4>
<div class="paragraph"><p>Paper wallets are bitcoin private keys printed on paper. Often the paper wallet also includes the corresponding bitcoin address, for convenience, but this is not necessary since it can be derived from the private key. Paper wallets are a very effective way to create backups or offline bitcoin storage, also known as "cold storage". As a backup mechanism, a paper wallet can provide security against the loss of key due to a computer mishap such as a hard drive failure, theft, or accidental deletion. As a "cold storage" mechanism, if the paper wallet keys are generated offline and never stored on a computer system, they are much more secure against hackers, key-loggers and other online computer threats.</p></div>
<div class="paragraph"><p>Paper wallets come in many shapes, sizes and designs, but at a very basic level are just a key and an address printed on paper. Here&#8217;s the simplest form of a paper wallet:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 14. A very simple paper wallet - a printout of the bitcoin address and private key</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Public Address</p></td>
<td align="left" valign="top"><p class="table">1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Private Key (WIF)</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Paper wallets can be generated easily using a tool such as the client-side Javascript generator at bitaddress.org. This page contains all the code necessary to generate keys and paper wallets, even while completely disconnected from the Internet. To use it, save the HTML page on your local drive or on an external USB flash drive. Disconnect from the Internet and open the file in a browser. Even better, boot your computer using a pristine operating system, such as a CDROM bootable Linux OS. Any keys generated with this tool while offline can be printed on a local printer over a USB cable (not wirelessly), thereby creating paper wallets whose keys exist only on the paper and have never been stored on any online system. Put these paper wallets in a fire-proof safe and "send" bitcoin to their bitcoin address, to implement a simple yet highly effective "cold storage" solution.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/paper_wallet_simple.png" alt="paper_wallet_simple" />
</div>
<div class="title">Figure 30. An example of a simple paper wallet from bitaddress.org</div>
</div>
<div class="paragraph"><p>The disadvantage of the simple paper wallet system is that the printed keys are vulnerable to theft. A thief who is able to gain access to the paper can either steal it or photograph the keys and take control of the bitcoins locked with those keys. A more sophisticated paper wallet storage system uses BIP0038 encrypted private keys. The keys printed on the paper wallet are protected by a passphrase that the owner has memorized. Without the passphrase, the encrypted keys are useless. Yet, they still are superior to a passphrase protected wallet because the keys have never been online and must be physically retrieved from a safe or other physically secured storage.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/paper_wallet_encrypted.png" alt="paper_wallet_encrypted" />
</div>
<div class="title">Figure 31. An example of an encrypted paper wallet from bitaddress.org. The passphrase is "test"</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>While you can deposit funds into a paper wallet several times, you should withdraw all funds only once, spending everything. This is because in the process of unlocking and spending funds you expose the private key and because some wallets may generate a change address if you spend less than the whole amount. One way to do this is to withdraw the entire balance stored in the paper wallet and send any remaining funds to a new paper wallet.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Paper wallets come in many designs and sizes, with many different features. Some are intended to be given as gifts and have seasonal themes, such as Christmas and New Year&#8217;s themes. Others are designed for storage in a bank vault or safe with the private key hidden in some way, either with opaque scratch-off stickers, or folded and sealed with tamper-proof adhesive foil.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/paper_wallet_bpw.png" alt="paper_wallet_bpw" />
</div>
<div class="title">Figure 32. An example of a paper wallet from bitcoinpaperwallet.com with the private key on a folding flap.</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/paper_wallet_bpw_folded.jpg" alt="paper_wallet_bpw_folded" />
</div>
<div class="title">Figure 33. The bitcoinpaperwallet.com paper wallet with the private key concealed.</div>
</div>
<div class="paragraph"><p>Other designs feature additional copies of the key and address, in the form of detachable stubs similar to ticket stubs, allowing you to store multiple copies to protect against fire, flood or other natural disasters.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/paper_wallet_spw.png" alt="paper_wallet_spw" />
</div>
<div class="title">Figure 34. An example of a paper wallet with additional copies of the keys on a backup "stub"</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transactions">Transactions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ch5_intro">Introduction</h3>
<div class="paragraph"><p>Transactions are the most important part of the bitcoin system. Everything else in bitcoin is designed to ensure that transactions can be created, propagated on the network, validated, and finally added to the global ledger of transactions, the blockchain. Transactions are data structures that encode the transfer of value between participants in the bitcoin system. Each transaction is a public entry in bitcoin&#8217;s global double-entry bookkeeping ledger, the blockchain.</p></div>
<div class="paragraph"><p>In this chapter we will examine all the various forms of transactions, what they contain, how to create them, how they are verified, and how they become part of the permanent record of all transactions.</p></div>
</div>
<div class="sect2">
<h3 id="tx_lifecycle">Transaction Lifecycle</h3>
<div class="paragraph"><p>A transaction&#8217;s lifecycle starts with the transaction&#8217;s creation, also known as origination. The transaction is then signed, with one or more signatures indicating the authorization to spend the funds referenced by the transaction. The transaction is then broadcast on the bitcoin network, where each network node (participant) validates and propagates the transaction until it reaches (almost) every node in the network. Finally, the transaction is verified by a mining node and included in a block of transactions that is recorded on the blockchain.</p></div>
<div class="paragraph"><p>Once recorded on the blockchain and confirmed by sufficient subsequent blocks (confirmations), the transaction is a permanent part of the bitcoin ledger and is accepted as valid by all participants. The funds allocated to a new owner by the transaction can then be spent in a new transaction, extending the chain of ownership and beginning the lifecycle of a transaction again.</p></div>
<div class="sect3">
<h4 id="tx_origination">Creating Transactions</h4>
<div class="paragraph"><p>In some ways it helps to think of a transaction in the same way as a paper cheque. Like a cheque, a transaction is an instrument that expresses the intent to transfer money and is not visible to the financial system until it is submitted for execution. Like a cheque, the originator of the transaction does not have to be the one signing the transaction.</p></div>
<div class="paragraph"><p>Transactions can be created online or offline by anyone, even if the person creating the transaction is not an authorized signer on the account. For example an accounts payable clerk might process payable cheques for signature by the CEO. Similarly, an accounts payable clerk can create bitcoin transactions and then have the CEO apply digital signatures to make them valid. While a cheque references a specific account as the source of the funds, a bitcoin transaction references a specific previous transaction as its source, rather than an account.</p></div>
<div class="paragraph"><p>Once a transaction has been created, it is signed by the owner (or owners) of the source funds. If it was properly formed and signed, the signed transaction is now valid and contains all the information needed to execute the transfer of funds. Finally, the valid transaction has to reach the bitcoin network so that it can be propagated until it reaches a miner for inclusion in the pubic ledger, the blockchain.</p></div>
</div>
<div class="sect3">
<h4 id="tx_bcast">Broadcasting Transactions to the Bitcoin Network</h4>
<div class="paragraph"><p>First, a transaction needs to be delivered to the bitcoin network so that it can be propagated and be included in the blockchain. In essence, a bitcoin transaction is just 300-400 bytes of data and has to reach any one of tens of thousands of bitcoin nodes. The sender does not need to trust the nodes they use to broadcast the transaction, as long as they use more than one to ensure that it propagates. The nodes don&#8217;t need to trust the sender or establish the sender&#8217;s "identity". Since the transaction is signed and contains no confidential information, private keys or credentials, it can be publicly broadcast using any underlying network transport that is convenient. Unlike credit card transactions, for example, which contain sensitive information and can only be transmitted on encrypted networks, a bitcoin transaction can be sent over any network. As long as the transaction can reach a bitcoin node that will propagate it into the bitcoin network, it doesn&#8217;t matter how it is transported to the first node.</p></div>
<div class="paragraph"><p>Bitcoin transactions can therefore be transmitted to the bitcoin network over insecure networks such as Wifi, Bluetooth, NFC, Chirp, barcodes or by copying and pasting into a web form. In extreme cases, a bitcoin transaction could be transmitted over packet radio, satellite relay or shortwave using burst transmission, spread spectrum or frequency hopping to evade detection and jamming. A bitcoin transaction could even be encoded as smileys (emoticons) and posted in a public forum or sent as a text message or Skype chat message. Bitcoin has turned money into a data structure, making it virtually impossible to stop anyone from creating and executing a bitcoin transaction.</p></div>
</div>
<div class="sect3">
<h4 id="tx_propagation">Propagating Transactions on the Bitcoin Network</h4>
<div class="paragraph"><p>Once a bitcoin transaction is sent to any node connected to the bitcoin network, the transaction will be validated by that node. If valid, that node will propagate it to the other nodes to which it is connected and a success message will be returned synchronously to the originator. If the transaction is invalid, the node will reject it and synchronously return a rejection message to the originator.</p></div>
<div class="paragraph"><p>The bitcoin network is a peer-to-peer network meaning that each bitcoin node is connected to a few other bitcoin nodes that it discovers during startup through the peer-to-peer protocol. The entire network forms a loosely connected mesh without a fixed topology or any structure making all nodes equal peers. Messages, including transactions and blocks, are propagated from each node to the peers to which it is connected. A new validated transaction injected into any node on the network will be sent to 3 to 4 of the neighboring nodes, each of which will send it to 3 to 4 more nodes and so on. In this way, within a few seconds a valid transaction will propagate in an exponentially expanding ripple across the network until all connected nodes have received it.</p></div>
<div class="paragraph"><p>The bitcoin network is designed to propagate transactions and blocks to all nodes in an efficient and resilient manner that is resistant to attacks. To prevent spamming, denial of service attacks, or other nuisance attacks against the bitcoin system, every node will independently validate every transaction before propagating it further. A malformed transaction will not get beyond one node. The rules by which transactions are validated are explained in more detail in <a href="#tx_verification">[tx_verification]</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="tx_structure">Transaction Structure</h3>
<div class="paragraph"><p>A transaction is a <em>data structure</em> that encodes a transfer of value from a source of funds, called an <em>input</em>, to a destination, called an <em>output</em>. Transaction inputs and outputs are not related to accounts or identities. Instead you should think of them as bitcoin amounts, chunks of bitcoin, being locked with a specific secret which only the owner, or person who knows the secret, can unlock.</p></div>
<div class="paragraph"><p>A transaction contains a number of fields, as follows:</p></div>
<div class="tableblock" id="tx_data_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 15. The structure of a transaction</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Version</p></td>
<td align="left" valign="top"><p class="table">Specifies which rules this transaction follows</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Input Counter</p></td>
<td align="left" valign="top"><p class="table">How many inputs are included</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Inputs</p></td>
<td align="left" valign="top"><p class="table">One or more Transaction Inputs</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Output Counter</p></td>
<td align="left" valign="top"><p class="table">How many outputs are included</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Outputs</p></td>
<td align="left" valign="top"><p class="table">One or more Transaction Outputs</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Locktime</p></td>
<td align="left" valign="top"><p class="table">A unix timestamp or block number</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Transaction Locktime</div>
<div class="paragraph"><p>Locktime defines the earliest time that a transaction can be added to the blockchain. It is set to zero in most transactions to indicate immediate execution. If locktime is non-zero and below 500 million, it is interpreted as a block height, meaning the transaction is not included in the blockchain prior to the specified block height. If it is above 500 million, it is interpreted as a Unix Epoch timestamp (seconds since Jan-1-1970) and the transaction is not included in the blockchain prior to the specified time. The use of locktime is equivalent to post-dating a paper cheque.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="tx_inputs_outputs">Transaction Outputs and Inputs</h3>
<div class="paragraph"><p>The fundamental building block of a bitcoin transaction is an <em>unspent transaction output</em> or UTXO. UTXO are indivisible chunks of bitcoin currency locked to a specific owner, recorded on the blockchain, and recognized as currency units by the entire network. The bitcoin network tracks all available (unspent) UTXO currently numbering in the millions. Whenever a user receives bitcoin, that amount is recorded within the blockchain as a UTXO. Thus, a user&#8217;s bitcoin may be scattered as UTXO amongst hundreds of transactions and hundreds of blocks. In effect, there is no such thing as a stored balance of a bitcoin address or account; there are only scattered UTXO, locked to specific owners. The concept of a user&#8217;s bitcoin balance is a derived construct created by the wallet application. The wallet calculates the user&#8217;s balance by scanning the blockchain and aggregating all UTXO belonging to that user.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>There are no accounts or balances in bitcoin, there are only <em>unspent transaction outputs</em> (UTXO) scattered in the blockchain.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>A UTXO can have an arbitrary value denominated as a multiple of satoshis.  Just like dollars can be divided down to two decimal places as cents, bitcoins can be divided down to eight decimal places as satoshis. While UTXO can be any arbitrary value, once created it is indivisible just like a coin that cannot be cut in half. If a UTXO is larger than the desired value of a transaction, it must still be consumed in its entirety and change must be generated in the transaction. In other words, if you have a 20 bitcoin UTXO and want to pay 1 bitcoin, your transaction must consume the entire 20 bitcoin UTXO and produce two outputs: one paying 1 bitcoin to your desired recipient and another paying 19 bitcoin in change back to your wallet. As a result, most bitcoin transactions will generate change.</p></div>
<div class="paragraph"><p>Imagine a shopper buying a $1.50 beverage, reaching into their wallet and trying to find a combination of coins and bank notes to cover the $1.50 cost. The shopper will choose exact change if available (a dollar bill and two quarters), or a combination of smaller denominations (six quarters), or if necessary, a larger unit such as a five dollar bank note. If they hand too much money, say $5, to the shop owner they will expect $3.50 change, which they will return to their wallet and have available for future transactions.</p></div>
<div class="paragraph"><p>Similarly, a bitcoin transaction must be created from a user&#8217;s UTXO in whatever denominations that user has available. They cannot cut a UTXO in half any more than they can cut a dollar bill in half and use it as currency. The user&#8217;s wallet application will typically select from the user&#8217;s available UTXO various units to compose an amount greater than or equal to the desired transaction amount.</p></div>
<div class="paragraph"><p>As with real life, the bitcoin application can use several strategies to satisfy the purchase amount: combining several smaller units, finding exact change, or using a single unit larger than the transaction value and making change. All of this complex assembly of spendable UTXO is done by the user&#8217;s wallet automatically and is invisible to users. It is only relevant if you are programmatically constructing raw transactions from UTXO.</p></div>
<div class="paragraph"><p>The UTXO consumed by a transaction are called transaction inputs, while the UTXO created by a transaction are called transaction outputs. This way, chunks of bitcoin value move forward from owner to owner in a chain of transactions consuming and creating UTXO. Transactions consume UTXO unlocking it with the signature of the current owner and create UTXO locking it to the bitcoin address of the new owner.</p></div>
<div class="paragraph"><p>The exception to the output and input chain is a special type of transaction called the <em>coinbase</em> transaction, which is the first transaction in each block. This transaction is placed there by the "winning" miner and creates brand-new bitcoin payable to that miner as a reward for mining. This is how bitcoin&#8217;s money supply is created during the mining process as we will see in <a href="#mining">[mining]</a>.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>What comes first? Inputs or outputs, the chicken or the egg? Strictly speaking, outputs come first because coinbase transactions, which generate new bitcoin, have no inputs and create outputs from nothing.</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="tx_outs">Transaction Outputs</h4>
<div class="paragraph"><p>Every bitcoin transaction creates outputs, which are recorded on the bitcoin ledger. Almost all of these outputs, with one exception (see <a href="#op_return">[op_return]</a>) create spendable chunks of bitcoin called <em>unspent transaction outputs</em> or UTXO, which are then recognized by the whole network and available for the owner to spend in a future transaction. Sending someone bitcoin is creating an unspent transaction output (UTXO) registered to their address and available for them to spend.</p></div>
<div class="paragraph"><p>UTXO are tracked by every full node bitcoin client in a database held in memory, called the <em>UTXO set</em> or <em>UTXO pool</em>. New transactions consume (spend) one or more of these outputs from the UTXO set.</p></div>
<div class="paragraph"><p>Transaction outputs consist of two parts:</p></div>
<div class="ulist"><ul>
<li>
<p>
An amount of bitcoin, denominated in <em>satoshis</em>, the smallest bitcoin unit
</p>
</li>
<li>
<p>
A <em>locking script</em>, also known as an "encumbrance" that "locks" this amount by specifying the conditions that must be met to spend the output
</p>
</li>
</ul></div>
<div class="paragraph"><p>The transaction scripting language, used in the locking script mentioned above, is discussed in detail in <a href="#tx_script">[tx_script]</a></p></div>
<div class="tableblock" id="tx_out_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 16. The structure of a transaction output</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">8 bytes</p></td>
<td align="left" valign="top"><p class="table">Amount</p></td>
<td align="left" valign="top"><p class="table">Bitcoin Value in Satoshis (10<sup>-8</sup> bitcoin)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Locking-Script Size</p></td>
<td align="left" valign="top"><p class="table">Locking-Script length in bytes, to follow</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Locking-Script</p></td>
<td align="left" valign="top"><p class="table">A script defining the conditions needed to spend the output</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>In the example below, we use the blockchain.info API to find the unspent outputs (UTXO) of a specific address:</p></div>
<div class="exampleblock" id="get_utxo">
<div class="title">Example 9. A script that calls the blockchain.info API to find the UTXO related to an address</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Running the script, we see a list of transaction IDs, a colon, the index number of the specific unspent transaction output (UTXO), and the value of that UTXO in Satoshis. The locking script is not shown in this output:</p></div>
<div class="exampleblock" id="get_utxo_run">
<div class="title">Example 10. Running the get-utxo.py script</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="sect4">
<h5 id="_spending_conditions_encumbrances">Spending Conditions (Encumbrances)</h5>
<div class="paragraph"><p>Transaction outputs associate a specific amount (in satoshis) to a specific <em>encumbrance</em> or locking-script that defines the condition that must be met to spend that amount. In most cases the locking script will lock the output to a specific bitcoin address, thereby transferring ownership of that amount to the new owner. When Alice paid Bob&#8217;s Cafe for a cup of coffee, her transaction created a 0.015 bitcoin output <em>encumbered</em> or locked to the Cafe&#8217;s bitcoin address. That 0.015 bitcoin output was recorded on the blockchain and became part of the Unspent Transaction Output set, meaning it showed in Bob&#8217;s wallet as part of the available balance. When Bob chooses to spend that amount, his transaction will release the encumbrance, unlocking the output by providing an unlocking script containing a signature from Bob&#8217;s private key.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="tx_inputs">Transaction Inputs</h4>
<div class="paragraph"><p>In simple terms, transaction inputs are pointers to UTXO. They point to a specific UTXO by reference to the transaction hash and sequence number where the UTXO is recorded in the blockchain. To spend UTXO, a transaction input also includes unlocking-scripts that satisfy the spending conditions set by the UTXO. The unlocking script is usually a signature proving ownership of the bitcoin address that is in the locking script.</p></div>
<div class="paragraph"><p>When a user makes a payment, their wallet constructs a transaction by selecting from the available UTXO. For example, to make a 0.015 bitcoin payment, the wallet app may select a 0.01 UTXO and a 0.005 UTXO, using them both to add up to the desired payment amount.</p></div>
<div class="paragraph"><p>In the example below, we show the use of a "greedy" algorithm to select from available UTXO in order to make a specific payment amount. In the example, the available UTXO are provided as a constant array, but in reality, the available UTXO would be retrieved with an RPC call to Bitcoin Core, or to a third-party API as shown in <a href="#get_utxo">[get_utxo]</a>.</p></div>
<div class="exampleblock" id="select_utxo">
<div class="title">Example 11. A script for calculating how much total bitcoin will be issued</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>If we run the select-utxo.py script without a parameter it will attempt to construct a set of UTXO (and change) for a payment of 55000000 Satoshis (0.55 bitcoin). If you provide a target payment amount as a parameter, the script will select UTXO to make that target payment amount. Below, we run the script trying to make a payment of 0.5 bitcoin or 50000000 Satoshis:</p></div>
<div class="exampleblock" id="select_utxo_run">
<div class="title">Example 12. Running the select-utxo.py script</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Once the UTXO is selected, the wallet then produces unlocking scripts containing signatures for each of the UTXO, thereby making them spendable by satisfying their locking script conditions. The wallet adds these UTXO references and unlocking scripts as inputs to the transaction.</p></div>
<div class="tableblock" id="tx_in_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 17. The structure of a transaction input</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Transaction Hash</p></td>
<td align="left" valign="top"><p class="table">Pointer to the transaction containing the UTXO to be spent</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Output Index</p></td>
<td align="left" valign="top"><p class="table">The index number of the UTXO to be spent, first one is 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script Size</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script length in bytes, to follow</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script</p></td>
<td align="left" valign="top"><p class="table">A script that fulfills the conditions of the UTXO locking-script.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Sequence Number</p></td>
<td align="left" valign="top"><p class="table">Currently-disabled Tx-replacement feature, set to 0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Note: The sequence number is used to override a transaction prior to the expiration of the transaction locktime, which is a feature that is currently disabled in bitcoin. Most transactions set this value to the maximum integer value (0xFFFFFFFF) and it is ignored by the bitcoin network. If the transaction has a non-zero locktime, at least one of its inputs must have a sequence number below 0xFFFFFFFF in order to enable locktime.</p></div>
</div>
<div class="sect3">
<h4 id="tx_fees">Transaction Fees</h4>
<div class="paragraph"><p>Most transactions include transaction fees, which compensate the bitcoin miners for securing the network. Mining and the fees and rewards collected by miners are discussed in more detail in <a href="#mining">[mining]</a>. This section examines how transaction fees are included in a typical transaction. Most wallets calculate and include transaction fees automatically. However, if you are constructing transactions programmatically, or using a command line interface, you must manually account for and include these fees.</p></div>
<div class="paragraph"><p>Transaction fees serve as an incentive to include (mine) a transaction into the next block and also as a disincentive against "spam" transactions or any kind of abuse of the system, by imposing a small cost on every transaction. Transaction fees are collected by the miner who mines the block that records the transaction on the blockchain.</p></div>
<div class="paragraph"><p>Transaction fees are calculated based on the size of the transaction in kilobytes, not the value of the transaction in bitcoin. Overall, transaction fees are set based on market forces within the bitcoin network. Miners prioritize transactions based on many different criteria, including fees and may even process transactions for free under certain circumstances. Transaction fees affect the processing priority, meaning that a transaction with sufficient fees is likely to be included in the next-most mined block, while a transaction with insufficient or no fees may be delayed, on a best-effort basis and processed after a few blocks or not at all. Transaction fees are not mandatory and transactions without fees may be processed eventually; however, including transaction fees encourages priority processing.</p></div>
<div class="paragraph"><p>Over time, the way transaction fees are calculated and the effect they have on transaction prioritization has been evolving. At first, transaction fees were fixed and constant across the network. Gradually, the fee structure has been relaxed so that it may be influenced by market forces, based on network capacity and transaction volume. The current minimum transaction fee is fixed at 0.0001 bitcoin or a tenth of a milli-bitcoin per kilobyte, recently decreased from one milli-bitcoin. Most transactions are less than one kilobyte; however, those with multiple inputs or outputs can be larger. In future revisions of the bitcoin protocol it is expected that wallet applications will use statistical analysis to calculate the most appropriate fee to attach to a transaction based on the average fees of recent transactions.</p></div>
<div class="paragraph"><p>The current algorithm used by miners to prioritize transactions for inclusion in a block based on their fees will be examined in detail in <a href="#mining">[mining]</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_adding_fees_to_transactions">Adding Fees to Transactions</h4>
<div class="paragraph"><p>The data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs is the fee that is collected by the miners.</p></div>
<div class="listingblock" id="tx_fee_equation">
<div class="title">Transaction fees are implied, as the excess of inputs minus outputs</div>
<div class="content">
<pre><code>Fees = Sum(Inputs) - Sum(Outputs)</code></pre>
</div></div>
<div class="paragraph"><p>This is a somewhat confusing element of transactions and an important point to understand, because if you are constructing your own transactions you must ensure you do not inadvertently include a very large fee by underspending the inputs. That means that you must account for all inputs, if necessary by creating change, or you will end up giving the miners a very big tip!</p></div>
<div class="paragraph"><p>For example, if you consume a 20 bitcoin UTXO to make a 1 bitcoin payment, you must include a 19 bitcoin change output back to your wallet. Otherwise, the 19 bitcoin "leftover" will be counted as a transaction fee and will be collected by the miner who mines your transaction in a block. While you will receive priority processing and make a miner very happy, this is probably not what you intended.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>If you forget to add a change output in a manually constructed transaction you will be paying the change as a transaction fee. "Keep the change!" may not be what you intended.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Let&#8217;s see how this works in practice, by looking at Alice&#8217;s coffee purchase again. Alice wants to spend 0.015 bitcoin to pay for coffee. To ensure this transaction is processed promptly, she will want to include a transaction fee, say 0.001. That will mean that the total cost of the transaction will be 0.016. Her wallet must therefore source a set of UTXO that adds up to 0.016 bitcoin or more and if necessary create change. Let&#8217;s say her wallet has a 0.2 bitcoin UTXO available. It will therefore need to consume this UTXO, create one output to Bob&#8217;s Cafe for 0.015, and a second output with 0.184 bitcoin in change back to her own wallet, leaving 0.001 bitcoin unallocated, as an implicit fee for the transaction.</p></div>
<div class="paragraph"><p>Now let&#8217;s look at a different scenario. Eugenia, our children&#8217;s charity director in the Philippines has completed a fundraiser to purchase school books for the children. She received several thousand small donations from people all around the world, totaling 50 bitcoin. Now she wants to purchase hundreds of school books from a local publisher, paying in bitcoin. The charity received thousands of small donations from all around the world, so her wallet is full of very small payments (UTXO).</p></div>
<div class="paragraph"><p>As Eugenia&#8217;s wallet application tries to construct a single larger payment transaction, it must source from the available UTXO set which is composed of many smaller amounts. That means that the resulting transaction will source from more than a hundred small-value UTXO as inputs and only one output, paying the book publisher. A transaction with that many inputs will be larger than one kilobyte, perhaps 2-3 kilobytes in size. As a result, it will require a higher fee than the minimal network fee of 0.0001 bitcoin.</p></div>
<div class="paragraph"><p>Eugenia&#8217;s wallet application will calculate the appropriate fee by measuring the size of the transaction and multiplying that by the per-kilobyte fee. Many wallets will overpay fees for larger transactions to ensure the transaction is processed promptly. The higher fee is not because Eugenia is spending more money, but because her transaction is more complex and larger in size - the fee is independent of the transaction&#8217;s bitcoin value.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="tx_chains">Transaction Chaining and Orphan Transactions</h3>
<div class="paragraph"><p>As we have seen above, transactions form a chain, whereby one transaction spends the outputs of the previous transaction (known as the parent) and creates outputs for a subsequent transaction (known as the child). Sometimes an entire chain of transactions depending on each other, say a parent, child and grandchild transaction are created at the same time, to fulfill a complex transactional workflow that requires valid children be signed before the parent is signed. For example, this is a technique used in a CoinJoin transactions where multiple parties join transactions together to protect their privacy.</p></div>
<div class="paragraph"><p>When a chain of transactions is transmitted across the network, they don&#8217;t always arrive in the same order. Sometimes, the child might arrive before the parent. In that case, the nodes which see a child first can see that it references a parent transaction that is not yet known. Rather than reject the child, they put it in a temporary pool to await the arrival of its parent and propagate it to every other node. The pool of transactions without parents is known as the orphan transaction pool. Once the parent arrives, any orphans that reference the UTXO created by the parent are released from the pool, revalidated recursively and then the entire chain of transactions can be included in the transaction pool, ready to be mined in block. Transaction chains can be arbitrarily long, with any number of generations transmitted simultaneously. The mechanism of holding orphans in the orphan pool ensures that otherwise valid transactions will not be rejected just because their parent has been delayed and that eventually the chain they belong to is reconstructed in the correct order, regardless of the order of arrival.</p></div>
<div class="paragraph"><p>There is a limit to the number of orphan transactions stored in memory, to prevent a Denial-of-Service attack against bitcoin nodes. The limit is defined as MAX_ORPHAN_TRANSACTIONS in the source code of the bitcoin reference client. If the number of orphan transactions in the pool exceeds MAX_ORPHAN_TRANSACTIONS, one or more randomly selected orphan transactions are evicted from the pool, until the pool size is back within limits.</p></div>
</div>
<div class="sect2">
<h3 id="tx_script">Transaction Scripts and Script Language</h3>
<div class="paragraph"><p>Bitcoin clients validate transactions by executing a script, written in a Forth-like scripting language. Both the locking script (encumbrance) placed on a UTXO and the unlocking script that usually contains a signature are written in this scripting language. When a transaction is validated, the unlocking script in each input is executed alongside the corresponding locking script to see if it satisfies the spending condition.</p></div>
<div class="paragraph"><p>Today most transactions processed through the bitcoin network have the form "Alice pays Bob" and are based on the same script called a Pay-to-Public-Key-Hash script. However, the use of scripts to lock outputs and unlock inputs means that through use of the programming language, transactions can contain an infinite number of conditions. Bitcoin transactions are not limited to the "Alice pays Bob" form and pattern.</p></div>
<div class="paragraph"><p>This is only the tip of the iceberg of possibilities that can be expressed with this scripting language. In this section we will demonstrate the components of bitcoins transaction scripting language and show how it can be used to express complex conditions for spending and how those conditions can be satisfied by unlocking scripts.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Bitcoin transaction validation is not based on a static pattern, but instead is achieved through the execution of a scripting language. This language allows for a nearly infinite variety of conditions to be expressed. This is how bitcoin gets the power of "programmable money".</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_script_construction_lock_unlock">Script Construction (Lock + Unlock)</h4>
<div class="paragraph"><p>Bitcoin&#8217;s transaction validation engine relies on two types of scripts to validate transactions&#8201;&#8212;&#8201;a locking script and an unlocking script.</p></div>
<div class="paragraph"><p>A locking script is an encumbrance placed on an output, and it specifies the conditions that must be met to spend the output in the future. Historically, the locking script was called a <em>scriptPubKey</em>, because it usually contained a public key or bitcoin address. In this book we refer to it as a "locking script" to acknowledge the much broader range of possibilities of this scripting technology. In most bitcoin applications, what we refer to as a locking script will appear in the source code as "scriptPubKey".</p></div>
<div class="paragraph"><p>An unlocking script is a script that "solves", or satisfies, the conditions placed on an output by a locking script and allows the output to be spent. Unlocking scripts are part of every transaction input and most of the time they contain a digital signature produced by the user&#8217;s wallet from their private key. Historically, the unlocking script is called <em>scriptSig</em>, because it usually contained a digital signature. In this book we refer to it as an "unlocking script" to acknowledge the much broader range of locking script requirements, as not all unlocking scripts must contain signatures. As mentioned above, in most bitcoin applications the source code will refer to the unlocking script as "scriptSig".</p></div>
<div class="paragraph"><p>Every bitcoin client will validate transactions by executing the locking and unlocking scripts together. For each input in the transaction, the validation software will first retrieve the UTXO referenced by the input. That UTXO contains a locking script defining the conditions required to spend it. The validation software will then take the unlocking script contained in the input that is attempting to spend this UTXO and execute the two scripts.</p></div>
<div class="paragraph"><p>In the original bitcoin client, the unlocking and locking scripts were concatenated and executed in sequence. For security reasons, this was changed in 2010, because of a vulnerability that allowed a malformed unlocking script to push data onto the stack and corrupt the locking script. In the current implementation the scripts are executed separately with the stack transferred between the two executions, as described below.</p></div>
<div class="paragraph"><p>First, the unlocking script is executed, using the stack execution engine. If the unlocking script executed without errors (e.g it has no "dangling" operators leftover), the main stack (not the alternate stack) is copied and the locking script is executed. If the result of executing the locking script with the stack data copied from the unlocking script is "TRUE", the unlocking script has succeeded in resolving the conditions imposed by the locking script and therefore the input is a valid authorization to spend the UTXO. If any result other than "TRUE" remains after execution of the combined script, the input is invalid as it has failed to satisfy the spending conditions placed on the UTXO. Note that the UTXO is permanently recorded in the blockchain, and therefore is invariable and is unaffected by failed attempts to spend it by reference in a new transaction. Only a valid transaction that correctly satisfies the conditions of the UTXO results in the UTXO being marked as "spent" and removed from the set of available (unspent) UTXO.</p></div>
<div class="paragraph"><p>Below is an example of the unlocking and locking scripts for the most common type of bitcoin transaction (a payment to a public key hash), showing the combined script resulting from the concatenation of the unlocking and locking scripts prior to script validation:</p></div>
<div class="imageblock">
<div class="content">
<img src="images/scriptSig_and_scriptPubKey.png" alt="scriptSig_and_scriptPubKey" />
</div>
<div class="title">Figure 35. Combining scriptSig and scriptPubKey to evaluate a transaction script</div>
</div>
</div>
<div class="sect3">
<h4 id="tx_script_language">Scripting Language</h4>
<div class="paragraph"><p>The bitcoin transaction script language, also named confusingly <em>Script</em>, is a Forth-like reverse-polish notation stack-based execution language. If that sounds like gibberish, you probably haven&#8217;t studied 1960&#8217;s programming languages. Script is a very simple, lightweight language that was designed to be limited in scope and executable on a range of hardware, perhaps as simple as an embedded device, like a handheld calculator. It requires minimal processing and cannot do many of the fancy things modern programming languages can do. In the case of programmable money, that is a deliberate security feature.</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s scripting language is called a stack-based language because it uses a data structure called a <em>stack</em>. A stack is a very simple data structure, which can be visualized as a stack of cards. A stack allows two operations: push and pop. Push adds an item on top of the stack. Pop removes the top item from the stack.</p></div>
<div class="paragraph"><p>The scripting language executes the script by processing each item from left to right. Numbers (data constants) are pushed onto the stack. Operators push or pop one or more parameters from the stack, act on them, and may push a result onto the stack. For example, OP_ADD will pop two items from the stack, add them and push the resulting sum onto the stack.</p></div>
<div class="paragraph"><p>Conditional operators evaluate a condition producing a boolean result of TRUE or FALSE. For example, OP_EQUAL pops two items from the stack and pushes TRUE (TRUE is represented by the number 1) if they are equal or FALSE (represented by zero) if they are not equal. Bitcoin transaction scripts usually contain a conditional operator, so that they can produce the result TRUE that signifies a valid transaction.</p></div>
<div class="paragraph"><p>In the following example, the script <code>2 3 OP_ADD 5 OP_EQUAL</code> demonstrates the arithmetic addition operator <em>OP_ADD</em>, adding two numbers and putting the result on the stack, followed by the conditional operator OP_EQUAL which checks the resulting sum is equal to <code>5</code>. For brevity, the OP_ prefix is omitted in the step-by-step example.</p></div>
<div class="imageblock" id="simplemath_script">
<div class="content">
<img src="images/TxScriptSimpleMathExample.png" alt="TxScriptSimpleMathExample" />
</div>
<div class="title">Figure 36. Bitcoin&#8217;s script validation doing simple math</div>
</div>
<div class="paragraph"><p>Below is a slightly more complex script, which calculates <code>((2 + 3) * 2) + 1</code>. Notice that when the script contains several operators in a row, the stack allows the results of one operator to be acted upon by the next operator:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 3 OP_ADD 2 OP_MUL 1 OP_ADD 11 OP_EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>Try validating the script above yourself, using pencil and paper. When the script execution ends, you should be left with the value TRUE on the stack.</p></div>
<div class="paragraph"><p>While most locking scripts refer to a bitcoin address or public key, thereby requiring proof of ownership to spend the funds, the script does not have to be that complex. Any combination of locking and unlocking scripts that results in a TRUE value is valid. The simple arithmetic we used as an example of the scripting language above is also a valid locking script that can be used to lock a transaction output.</p></div>
<div class="paragraph"><p>Use part of the arithmetic example script as the locking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>3 OP_ADD 5 OP_EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>which can be satisfied by transaction containing an input with the unlocking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2</code></pre>
</div></div>
<div class="paragraph"><p>The validation software combines the locking and unlocking scripts and the resulting script is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 3 OP_ADD 5 OP_EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>As we saw in the step-by-step example above, when this script is executed the result is OP_TRUE, making the transaction valid. Not only is this a valid transaction output locking script, but the resulting UTXO could be spent by anyone with the arithmetic skills to know that the number 2 satisfies the script.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p></p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_turing_incompleteness">Turing Incompleteness</h4>
<div class="paragraph"><p>The bitcoin transaction script language contains many operators but is deliberately limited in one important way&#8201;&#8212;&#8201;there are no loops or complex flow control capabilities other than conditional flow control. This ensures that the language is not Turing Complete, meaning that scripts have limited complexity and predictable execution times. Script is not a general-purpose language. These limitations ensure that the language cannot be used to create an infinite loop or other form of "logic bomb" that could be embedded in a transaction in a way that causes a Denial-of-Service attack against the bitcoin network. Remember, every transaction is validated by every full node on the bitcoin network. A limited language prevents the transaction validation mechanism from being used as a vulnerability.</p></div>
</div>
<div class="sect3">
<h4 id="_stateless_verification">Stateless Verification</h4>
<div class="paragraph"><p>The bitcoin transaction script language is stateless, in that there is no state prior to execution of the script, or state saved after execution of the script. Therefore, all the information needed to execute a script is contained within the script. A script will predictably execute the same way on any system. If your system verifies a script, you can be sure that every other system in the bitcoin network will also verify the script, meaning that a valid transaction is valid for everyone and everyone knows this. This predictability of outcomes is an essential benefit of the bitcoin system.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="std_tx">Standard Transactions</h3>
<div class="paragraph"><p>In the first few years of bitcoin&#8217;s development, the developers introduced some limitations in the types of scripts that could be processed by the reference client. These limitations are encoded in a function called <code>isStandard()</code> which defines five types of "standard" transactions. These limitations are temporary and may be lifted by the time you read this. Until then, the five standard types of transaction scripts are the only ones that will be accepted by the reference client and most miners who run the reference client. While it is possible to create a non-standard transaction containing a script that is not one of the standard types, you must find a miner who does not follow these limitations, to mine that transaction into a block.</p></div>
<div class="paragraph"><p>Check the source code of the bitcoin core client (the reference implementation) to see what is currently allowed as a valid transaction script.</p></div>
<div class="paragraph"><p>The five standard types of transaction scripts are Pay-to-Public-Key-Hash (P2PKH), Public-Key, Multi-Signature (limited to 15 keys), Pay-to-Script-Hash (P2SH) and Data Output (OP_RETURN), which are described in more detail below.</p></div>
<div class="sect3">
<h4 id="p2pkh">Pay to Public Key Hash (P2PKH)</h4>
<div class="paragraph"><p>The vast majority of transactions processed on the bitcoin network are Pay-to-Public-Key-Hash, also known as P2PKH transactions. These contain a locking script that encumbers the output with a public key hash, more commonly known as a bitcoin address. Transactions that pay a bitcoin address contain P2PKH scripts. An output locked by a P2PKH script can be unlocked (spent) by presenting a public key and a digital signature created by the corresponding private key.</p></div>
<div class="paragraph"><p>For example, let&#8217;s look at Alice&#8217;s payment to Bob&#8217;s Cafe again. Alice made a payment of 0.015 bitcoin to the Cafe&#8217;s bitcoin address. That transaction output would have a locking script of the form:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>The <code>Cafe Public Key Hash</code> is equivalent to the bitcoin address of the Cafe, without the Base58Check encoding. Most applications would show the Public Key Hash in hexadecimal encoding and not the familiar bitcoin address Base58Check format that begins with a "1".</p></div>
<div class="paragraph"><p>The locking script above can be satisfied with an unlocking script of the form:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The two scripts together would form the combined validation script below:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160 \
&lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In other words, the result will be TRUE if the unlocking script has a valid signature from the Cafe&#8217;s private key which corresponds to the public key hash set as an encumbrance.</p></div>
<div class="paragraph"><p>Here&#8217;s a step-by-step execution of the combined script, which will prove this is a valid transaction:</p></div>
<div class="imageblock" id="P2PubKHash1">
<div class="content">
<img src="images/Tx_Script_P2PubKeyHash_1.png" alt="Tx_Script_P2PubKeyHash_1" />
</div>
<div class="title">Figure 37. Evaluating a script for a Pay-to-Public-Key-Hash transaction (Part 1 of 2)</div>
</div>
<div class="imageblock" id="P2PubKHash2">
<div class="content">
<img src="images/Tx_Script_P2PubKeyHash_2.png" alt="Tx_Script_P2PubKeyHash_2" />
</div>
<div class="title">Figure 38. Evaluating a script for a Pay-to-Public-Key-Hash transaction (Part 2 of 2)</div>
</div>
</div>
<div class="sect3">
<h4 id="p2pk">Pay-to-Public-Key</h4>
<div class="paragraph"><p>Pay-to-Public-Key is a simpler form of a bitcoin payment than Pay-to-Public-Key-Hash. With this script form, the public key itself is stored in the locking script, rather than a public-key-hash as with P2PKH above, which is much shorter. Pay-to-Public-Key-Hash was invented by Satoshi to make bitcoin addresses shorter, for ease of use. Pay-to-Public-Key is now most often seen in coinbase transactions, generated by older mining software that has not been updated to use P2PKH.</p></div>
<div class="paragraph"><p>A Pay-to-Public-Key locking script looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Public Key A&gt; OP_CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>The corresponding unlocking script that must be presented to unlock this type of output is a simple signature, like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature from Private Key A&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The combined script, which is validated by the transaction validation software is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Signature from Private Key A&gt; &lt;Public Key A&gt; OP_CHECKSIG</code></pre>
</div></div>
<div class="paragraph"><p>The script above is a simple invocation of the CHECKSIG operator which validates the signature as belonging to the correct key and returns TRUE on the stack.</p></div>
</div>
<div class="sect3">
<h4 id="multisig">Multi-Signature</h4>
<div class="paragraph"><p>Multi-signature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to release the encumbrance. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation. For example, a 2-of-3 multi-signature is one where 3 public keys are listed as potential signers and at least 2 of those must be used to create signatures for a valid transaction to spend the funds. At this time, standard multi-signature scripts are limited to at most 15 listed public keys, meaning you can do anything from a 1-of-1 to a 15-of-15 multi-signature or any combination within that range. The limitation to 15 listed keys may be lifted by the time of publication of this book, so check the <code>isStandard()</code> function to see what is currently accepted by the network.</p></div>
<div class="paragraph"><p>The general form of a locking script setting an M-of-N multi-signature condition is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>where N is the total number of listed public keys and M is the threshold of required signatures to spend the output.</p></div>
<div class="paragraph"><p>A locking script setting a 2-of-3 multi-signature condition looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>The locking script above can be satisfied with an unlocking script containing pairs of signatures and public keys:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>OP_0 &lt;Signature B&gt; &lt;Signature C&gt;</code></pre>
</div></div>
<div class="paragraph"><p>or any combination of two signatures from the private keys corresponding to the three listed public keys.</p></div>
<div class="paragraph"><p><em>Note: The prefix OP_0 is required because of a bug in the original implementation of CHECKMULTISIG where one item too many is popped off the stack. It is ignored by CHECKMULTISIG and is simply a placeholder.</em></p></div>
<div class="paragraph"><p>The two scripts together would form the combined validation script below:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>OP_0 &lt;Signature B&gt; &lt;Signature C&gt;\
2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In this case, the condition is whether the unlocking script has a valid signature from the two private keys that correspond to two of the three public keys set as an encumbrance.</p></div>
</div>
<div class="sect3">
<h4 id="op_return">Data Output (OP_RETURN)</h4>
<div class="paragraph"><p>Bitcoin&#8217;s distributed and timestamped ledger, the blockchain, has potential uses far beyond payments. Many developers have tried to use the transaction scripting language to take advantage of the security and resilience of the system for applications such as digital notary services, stock certificates, and smart contracts. Early attempts to use bitcoin&#8217;s script language for these purposes involved creating transaction outputs that recorded data on the blockchain, for example to record a digital fingerprint of a file in such a way that anyone could establish proof-of-existence of that file on a specific date by reference to that transaction.</p></div>
<div class="paragraph"><p>The use of bitcoin&#8217;s blockchain to store data unrelated to bitcoin payments is a controversial subject. Many developers consider such use abusive and want to discourage it. Others view it as a demonstration of the powerful capabilities of blockchain technology and want to encourage such experimentation. Those who object to the inclusion of non-payment data argue that it causes "blockchain bloat", burdening those running full bitcoin nodes with carrying the cost of disk storage for data that the blockchain was not intended to carry. Moreover, such transactions create UTXO that cannot be spent, using the destination bitcoin address as a free-form 20-byte field. Since the address is used for data, it doesn&#8217;t correspond to a private key and the resulting UTXO can <em>never</em> be spent, it&#8217;s a fake payment. This practice causes the size of the in-memory UTXO set to increase and these transactions which can never be spent are therefore never removed, forcing bitcoin nodes to carry these forever in RAM which is far more expensive.</p></div>
<div class="paragraph"><p>In version 0.9 of the bitcoin core client, a compromise was reached, with the introduction of the OP_RETURN operator. OP_RETURN allows developers to add 40 bytes of non-payment data to a transaction output. However, unlike the use of "fake" UTXO, the OP_RETURN operator creates an explicitly <em>provably un-spendable</em> output, which does not need to be stored in the UTXO set. OP_RETURN outputs are recorded on the blockchain, so they consume disk space and contribute to the increase in the blockchain&#8217;s size, but they are not stored in the UTXO set and therefore do not bloat the UTXO memory pool and burden full nodes with the cost of more expensive RAM.</p></div>
<div class="paragraph"><p>OP_RETURN scripts look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>OP_RETURN &lt;data&gt;</code></pre>
</div></div>
<div class="paragraph"><p>where the data portion is limited to 40 bytes and most often represents a hash, such as the output from the SHA256 algorithm (32 bytes). Many applications put a prefix in front of the data to help identify the application. For example, the proofofexistence.com digital notarization service uses the 8-byte prefix "DOCPROOF" which is ASCII encoded as 44f4350524f4f46 in hexadecimal.</p></div>
<div class="paragraph"><p>Keep in mind that there is no "unlocking script" that corresponds to OP_RETURN that could possibly be used to "spend" an OP_RETURN output. The whole point of OP_RETURN is that you can&#8217;t spend the money locked in that output and therefore it does not need to be held in the UTXO set as potentially spendable - OP_RETURN is <em>provably un-spendable</em>. OP_RETURN is usually an output with a zero bitcoin amount, since any bitcoin assigned to such an output is effectively lost forever. If an OP_RETURN is encountered by the script validation software, it results immediately in halting the execution of the validation script and marking the transaction as invalid. Thus, if you accidentally reference an OP_RETURN output as an input in a transaction, that transaction is invalid.</p></div>
<div class="paragraph"><p>A standard transaction (one that conforms to the <code>isStandard()</code> checks) can have only one OP_RETURN output. However, a single OP_RETURN output can be combined in a transaction with outputs of any other type.</p></div>
</div>
<div class="sect3">
<h4 id="p2sh">Pay to Script Hash (P2SH)</h4>
<div class="paragraph"><p>Pay-to-Script-Hash (P2SH) was introduced in the winter of 2012 as a powerful new type of transaction that greatly simplifies the use of complex transaction scripts. To explain the need for P2SH, let&#8217;s look at a practical example.</p></div>
<div class="paragraph"><p>In chapter 1 we introduced Mohammed, an electronics importer based in Dubai. Mohammed&#8217;s company uses bitcoin&#8217;s multi-signature feature extensively for its corporate accounts. Multi-signature scripts are one of the most common uses of bitcoin&#8217;s advanced scripting capabilities and are a very powerful feature. Mohammed&#8217;s company uses a multi-signature script for all customer payments, known in accounting terms as "accounts receivable" or AR. With the multi-signature scheme, any payments made by customers are locked in such a way that they require at least two signatures to release, from Mohammed and one of his partners or from his attorney who has a backup key. A multi-signature scheme like that offers corporate governance controls and protects against theft, embezzlement or loss.</p></div>
<div class="paragraph"><p>The resulting script is quite long and looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; \
&lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>While multi-signature scripts are a powerful feature, they are cumbersome to use. Given the script above, Mohammed would have to communicate this script to every customer prior to payment. Each customer would have to use special bitcoin wallet software with the ability to create custom transaction scripts and each customer would have to understand how to create a transaction using custom scripts. Furthermore, the resulting transaction would be about five times larger than a simple payment transaction, as this script contains very long public keys. The burden of that extra-large transaction would be borne by the customer in the form of fees. Finally, a large transaction script like this would be carried in the UTXO set in RAM in every full node, until it was spent. All of these issues make using complex output scripts difficult in practice.</p></div>
<div class="paragraph"><p>Pay-to-Script-Hash (P2SH) was developed to resolve these practical difficulties and to make the use of complex scripts as easy as a payment to a bitcoin address. With P2SH payments, the complex locking script is replaced with its digital fingerprint, a cryptographic hash. When a transaction attempting to spend the UTXO is presented later, it must contain the script that matches the hash, in addition to the unlocking script. In simple terms, P2SH means "pay to a script matching this hash, a script which will be presented later when this output is spent".</p></div>
<div class="paragraph"><p>In P2SH transactions, the locking script that is replaced by a hash is referred to as the <em>redeem script</em> because it is presented to the system at redemption time rather than as a locking script.</p></div>
<div class="tableblock" id="without_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 18. Complex Script without P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">Sig1 Sig2</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="with_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 19. Complex Script as P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Redeem Script</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">Sig1 Sig2 redeem script</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>As you can see from the tables above, with P2SH the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, only a hash of it is in the locking script and the redeem script itself is presented later, as part of the unlocking script when the output is spent. This shifts the burden in fees and complexity from the sender to the recipient (spender) of the transaction.</p></div>
<div class="paragraph"><p>Let&#8217;s look at Mohammed&#8217;s company, their complex multi-signature script and the resulting P2SH scripts.</p></div>
<div class="paragraph"><p>First, the multi-signature script that Mohammed&#8217;s company uses for all incoming payments from customers:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; \
&lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>If the placeholders above are replaced by actual public keys (shown below as 520 bit numbers starting with 04) you can see that this script becomes very long:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>2
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370\
D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD\
4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495\
E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B\
1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8\
CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1\
A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CB\
D7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4\
AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2\
AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0\
AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AA\
B59E0B000EB7ED238F4D800 5 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="paragraph"><p>The entire script above can instead be represented by a 20-byte cryptographic hash, by first applying the SHA256 hashing algorithm and then applying the RIPEMD160 algorithm on the result. The 20-byte hash of the above script is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>54c557e07dde5bb6cb791c7a540e0a4796f5e97e</code></pre>
</div></div>
<div class="paragraph"><p>A P2SH transaction locks the output to this hash instead of the longer script, using the locking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>which, as you can see is much shorter. Instead of "pay to this 5-key multi-signature script", the P2SH equivalent transaction is "pay to a script with this hash". A customer making a payment to Mohammed&#8217;s company need only include this much shorter locking script in their payment. When Mohammed wants to spend this UTXO, they must present the original redeem script (the one whose hash locked the UTXO) and the signatures necessary to unlock it, like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;</code></pre>
</div></div>
<div class="paragraph"><p>The two scripts are combined in two stages. First, the redeem script is checked against the locking script to make sure the hash matches:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; OP_HASH160 &lt;redeem scriptHash&gt; OP_EQUAL</code></pre>
</div></div>
<div class="paragraph"><p>If the redeem script hash matches, then the unlocking script is executed on its own, to unlock the redeem script:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</code></pre>
</div></div>
<div class="sect4">
<h5 id="_pay_to_script_hash_addresses">Pay-to-Script-Hash Addresses</h5>
<div class="paragraph"><p>Another important part of the P2SH feature is the ability to encode a script hash as an address, as defined in BIP0013. P2SH addresses are Base58Check encodings of the 20-byte hash of a script, just like bitcoin addresses are Base58Check encodings of the 20-byte hash of a public key. P2SH addresses use the version prefix "5", which results in Base58Check encoded addresses that start with a "3". For example, Mohammed&#8217;s complex script, hashed and Base58Check encoded as P2SH address becomes <code>39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</code>. Now, Mohammed can give this "address" to his customers and they can use almost any bitcoin wallet to make a simple payment, as if it were a bitcoin address. The 3 prefix gives them a hint that this is a special type of address, one corresponding to a script instead of a public key, but otherwise it works in exactly the same way as a payment to a bitcoin address.</p></div>
<div class="paragraph"><p>P2SH addresses hide all of the complexity, so that the person making a payment does not see the script.</p></div>
</div>
<div class="sect4">
<h5 id="_benefits_of_pay_to_script_hash">Benefits of Pay-to-Script-Hash</h5>
<div class="paragraph"><p>The Pay-to-Script-Hash feature offers the following benefits compared to the direct use of complex scripts in locking outputs:</p></div>
<div class="ulist"><ul>
<li>
<p>
Complex scripts are replaced by shorter fingerprint in the transaction output, making the transaction smaller
</p>
</li>
<li>
<p>
Scripts can be coded as an address, so the sender and the sender&#8217;s wallet don&#8217;t need complex engineering to implement P2SH
</p>
</li>
<li>
<p>
P2SH shifts the burden of constructing the script to the recipient not the sender
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the output (which is in the UTXO set and therefore impacts memory) to the input (only stored on the blockchain)
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the present time (payment) to a future time (when it is spent)
</p>
</li>
<li>
<p>
P2SH shifts the transaction fee cost of a long script from the sender to the recipient who has to include the long redeem script to spend it
</p>
</li>
</ul></div>
</div>
<div class="sect4">
<h5 id="_redeem_script_and_isstandard_validation">Redeem Script and isStandard Validation</h5>
<div class="paragraph"><p>Prior to version 0.9.2 of the Bitcoin Core client, Pay-to-Script-Hash was limited to the standard types of bitcoin transaction scripts, by the <code>isStandard()</code> function. That means that the redeem script presented in the spending transaction could only be one of the standard types: P2PK, P2PKH or Multi-Sig, excluding OP_RETURN and P2SH itself.</p></div>
<div class="paragraph"><p>As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can contain any valid script, making the P2SH standard much more flexible and allowing for experimentation with many novel and complex types of transactions.</p></div>
<div class="paragraph"><p>Note that you are not able to put a P2SH inside a P2SH redeem script, because the P2SH specification is not recursive. You are also still not be able to use OP_RETURN in a redeem script because OP_RETURN cannot be redeemed by definition.</p></div>
<div class="paragraph"><p>Note that since the redeem script is not presented to the network until you attempt to spend a P2SH output, if you lock an output with the hash of an invalid transaction it will be processed regardless. However, you will not be able to spend it as the spending transaction which includes the redeem script will not be accepted, as it is an invalid script. This creates a risk, because you can lock bitcoin in a P2SH which cannot be later spent. The network will accept the P2SH encumbrance even if it corresponds to an invalid redeem script, because the script hash gives no indication of the script it represents.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>P2SH locking scripts contain the hash of a redeem script which gives no clues as to the content of the redeem script itself. The P2SH transaction will be considered valid and accepted even if the redeem script is invalid. You may accidentally lock bitcoin in such a way that it cannot later be spent.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bitcoin_network">The Bitcoin Network</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_peer_to_peer_network_architecture">Peer-to-Peer Network Architecture</h3>
<div class="paragraph"><p>Bitcoin is structured as a peer-to-peer network architecture on top of the Internet. The term peer-to-peer or P2P means that the computers that participate in the network are peers to each other, that they are all equal, that there are no "special" nodes and that all nodes share the burden of providing network services. The network nodes interconnect in a mesh network with a "flat" topology. There is no "server", no centralized service, and no hierarchy within the network. Nodes in a peer-to-peer network both provide and consume services at the same time with reciprocity acting as the incentive for participation. Peer-to-peer networks are inherently resilient, de-centralized, and open. The pre-eminent example of a P2P network architecture was the early Internet itself, where nodes on the IP network were equal. Today&#8217;s Internet architecture is more hierarchical, but the Internet Protocol still retains its flat-topology essence. Beyond bitcoin, the largest and most successful application of P2P technologies is file sharing with Napster as the pioneer and bittorrent as the most recent evolution of the architecture.</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s P2P network architecture is much more than a topology choice. Bitcoin is a peer-to-peer digital cash system by design, and the network architecture is both a reflection and a foundation of that core characteristic. De-centralization of control is a core design principle and that can only be achieved and maintained by a flat, de-centralized P2P consensus network.</p></div>
<div class="paragraph"><p>The term "bitcoin network" refers to the collection of nodes running the bitcoin P2P protocol. In addition to the bitcoin P2P protocol, there are other protocols such as Stratum, which are used for mining and lightweight or mobile wallets. These additional protocols are provided by gateway routing servers that access the bitcoin network using the bitcoin P2P protocol and then extend that network to nodes running other protocols. For example, Stratum servers connect Stratum mining nodes via the Stratum protocol to the main bitcoin network and bridge the Stratum protocol to the bitcoin P2P protocol. We use the term "extended bitcoin network" to refer to the overall network that includes the bitcoin P2P protocol, pool mining protocols, the Stratum protocol, and any other related protocols connecting the components of the bitcoin system.</p></div>
</div>
<div class="sect2">
<h3 id="_nodes_types_and_roles">Nodes Types and Roles</h3>
<div class="paragraph"><p>While nodes in the bitcoin P2P network are equal, they may take on different "roles" depending on the functionality they are supporting. A bitcoin node is a collection of functions: routing, the blockchain database, mining, and wallet services. A full node with all four of these functions is shown below:</p></div>
<div class="imageblock" id="full_node_reference">
<div class="content">
<img src="images/FullNodeReferenceClient_Small.png" alt="FullNodeReferenceClient_Small" />
</div>
<div class="title">Figure 39. A bitcoin network node with all four functions: Wallet, Miner, full Blockchain database, and Network routing</div>
</div>
<div class="paragraph"><p>All nodes include the routing function to participate in the network and may include other functionality. All nodes validate and propagate transactions and blocks, and discover and maintain connections to peers. In the full node example above, the routing function is indicated by an orange circle named "Network Routing Node".</p></div>
<div class="paragraph"><p>Some nodes, called full nodes, also maintain a complete and up-to-date copy of the blockchain. Full nodes can autonomously and authoritatively verify any transaction without external reference. Some nodes maintain only a subset of the blockchain and verify transactions using a method called <em>Simplified Payment Verification</em> or SPV. These nodes are known as SPV or Lightweight nodes. In the full node example above, the full node blockchain database function is indicated by a blue circle named "Full Blockchain". SPV nodes are drawn without the blue circle, showing that they do not have a full copy of the blockchain.</p></div>
<div class="paragraph"><p>Mining nodes compete to create new blocks by running specialized hardware to solve the proof-of-work algorithm. Some mining nodes are also full nodes, maintaining a full copy of the blockchain while others are lightweight nodes participating in pool mining and depending on a pool server to maintain a full node. The mining function is shown in the full node above as a black circle named "Miner".</p></div>
<div class="paragraph"><p>User wallets may be part of a full node, as is usually the case with desktop bitcoin clients. Increasingly many user wallets, especially those running on resource-constrained devices such as smart phones, are SPV nodes. The wallet function is shown above as a green circle named "Wallet".</p></div>
<div class="paragraph"><p>In addition to the main node types on the bitcoin P2P protocol, there are servers and nodes running other protocols, such as specialized mining pool protocols and lightweight client access protocols.</p></div>
<div class="paragraph"><p>Here are the most common node types on the extended bitcoin network:</p></div>
<div class="imageblock" id="node_type_ledgend">
<div class="content">
<img src="images/BitcoinNodeTypes.png" alt="BitcoinNodeTypes" />
</div>
<div class="title">Figure 40. Different types of nodes on the extended bitcoin network</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_extended_bitcoin_network">The Extended Bitcoin Network</h3>
<div class="paragraph"><p>The main bitcoin network, running the bitcoin P2P protocol, consists of between 7,000 to 10,000 nodes running various versions of the bitcoin reference client (Bitcoin Core) and a few hundred nodes running various other implementations of the bitcoin P2P protocol, such as BitcoinJ, Libbitcoin, and btcd. A small percentage of the nodes on the bitcoin P2P network are also mining nodes, competing in the mining process, validating transactions, and creating new blocks. Various large companies interface with the bitcoin network by running full-node clients based on the Bitcoin Core client, with full copies of the blockchain and a network node, but without mining or wallet functions. These nodes act as network edge routers, allowing various other services (exchanges, wallets, block explorers, merchant payment processing) to be built on top.</p></div>
<div class="paragraph"><p>The extended bitcoin network includes the network running the bitcoin P2P protocol, described above, as well as nodes running specialized protocols. Attached to the main bitcoin P2P network are a number of pool servers and protocol gateways that connect nodes running other protocols. These other protocol nodes are mostly pool mining nodes (see <a href="#mining">[mining]</a>) and lightweight wallet clients, which do not carry a full copy of the blockchain.</p></div>
<div class="paragraph"><p>The diagram below shows the extended bitcoin network with the various types of nodes, gateway servers, edge routers, and wallet clients and the various protocols they use to connect to each other.</p></div>
<div class="imageblock" id="bitcoin_network">
<div class="content">
<img src="images/BitcoinNetwork.png" alt="BitcoinNetwork" />
</div>
<div class="title">Figure 41. The extended bitcoin network showing various node types, gateways and protocols</div>
</div>
</div>
<div class="sect2">
<h3 id="_network_discovery">Network Discovery</h3>
<div class="paragraph"><p>When a new node boots up, it must discover other bitcoin nodes on the network in order to participate. To start this process, a new node must discover at least one existing node on the network and connect to it. The geographic location of the other nodes is irrelevant, the bitcoin network topology is not geographically defined. Therefore, any existing bitcoin nodes can be selected at random.</p></div>
<div class="paragraph"><p>To connect to a known peer, nodes establish a TCP connection, usually to port 8333 (the bitcoin "well known" port), or an alternative port if one is provided. Upon establishing a connection, the node will start a "handshake" by transmitting a  <code>version</code> message, which contains basic identifying information, including:</p></div>
<div class="ulist"><ul>
<li>
<p>
PROTOCOL_VERSION, a constant that defines the bitcoin P2P protocol version the client "speaks" (e.g. 70002)
</p>
</li>
<li>
<p>
nLocalServices, a list of local services supported by the node, currently just NODE_NETWORK
</p>
</li>
<li>
<p>
nTime, the current time
</p>
</li>
<li>
<p>
addrYou, the IP address of the remote node as seen from this node
</p>
</li>
<li>
<p>
addrMe, the IP address of the local node, as discovered by the local node
</p>
</li>
<li>
<p>
subver, a sub-version showing the type of software running on this node (e.g. "/Satoshi:0.9.2.1/“)
</p>
</li>
<li>
<p>
BestHeight, the block height of this node&#8217;s blockchain
</p>
</li>
</ul></div>
<div class="paragraph"><p>(See <a href="https://github.com/bitcoin/bitcoin/blob/d3cb2b8acfce36d359262b4afd7e7235eff106b0/src/net.cpp#L562">https://github.com/bitcoin/bitcoin/blob/d3cb2b8acfce36d359262b4afd7e7235eff106b0/src/net.cpp#L562</a> for an example of the <code>version</code> network message)</p></div>
<div class="paragraph"><p>The peer node responds with <code>verack</code> to acknowledge and establish a connection, and optionally sends its own <code>version</code> message if it wishes to reciprocate the connection and connect back as a peer.</p></div>
<div class="imageblock" id="network_handshake">
<div class="content">
<img src="images/NetworkHandshake.png" alt="NetworkHandshake" />
</div>
<div class="title">Figure 42. The initial handshake between peers</div>
</div>
<div class="paragraph"><p>How does a new node find peers? While there are no special nodes in bitcoin, there are some long running stable nodes that are listed in the client as <em>seed nodes</em>. While a new node does not have to connect with the seed nodes, it can use them to quickly discover other nodes in the network. In the Bitcoin Core client, the option to use the seed nodes is controlled by the option switch <code>-dnsseed</code>, which is set to 1, to use the seed nodes, by default. Alternatively, a bootstrapping node that knows nothing of the network must be given the IP address of at least one bitcoin node after which it can establish connections through further introductions. The command line argument <code>-seednode</code> can be used to connect to one node just for introductions, using it as a DNS seed. After the initial seed node is used to form introductions, the client will disconnect from it and use the newly discovered peers.</p></div>
<div class="paragraph"><p>Once one or more connections are established, the new node will send an <code>addr</code> message containing its own IP address, to its neighbors. The neighbors will in turn forward the <code>addr</code> message to their neighbors, ensuring that the newly connected node becomes well known and better connected. Additionally, the newly connected node can send <code>getaddr</code> to the neighbors, asking them to return a list of IP addresses of other peers. That way, a node can find peers to connect to and advertise its existence on the network for other nodes to find it.</p></div>
<div class="imageblock" id="address_propagation">
<div class="content">
<img src="images/AddressPropagation.png" alt="AddressPropagation" />
</div>
<div class="title">Figure 43. Address Propagation and Discovery</div>
</div>
<div class="paragraph"><p>A node must connect to a few different peers in order to establish diverse paths into the bitcoin network. Paths are not reliable, nodes come and go, and so the node must continue to discover new nodes as it loses old connections as well as assist other nodes when they bootstrap. Only one connection is needed to bootstrap, as the first node can offer introductions to its peer nodes and those peers can offer further introductions. It&#8217;s also unnecessary and wasteful of network resources to connect to more than a handful of nodes. After bootstrapping, a node will remember its most recent successful peer connections, so that if it is rebooted it can quickly reestablish connections with its former peer network. If none of the former peers respond to its connection request, the node can use the seed nodes to bootstrap again.</p></div>
<div class="paragraph"><p>On a node running the Bitcoin Core client, you can list the peer connections with the command <code>getpeerinfo</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>To override the automatic management of peers and to specify a list of IP addresses, users can provide the option <code>-connect=&lt;IPAddress&gt;</code> and specify one or more IP addresses. If this option is used, the node will only connect to the selected IP addresses, instead of discovering and maintaining the peer connections automatically.</p></div>
<div class="paragraph"><p>If there is no traffic on a connection, nodes will periodically send a message to maintain the connection. If a node has not communicated on a connection for more than 90 minutes, it is assumed to be disconnected and a new peer will be sought. Thus, the network dynamically adjusts to transient nodes, network problems, and can organically grow and shrink as needed without any central control.</p></div>
</div>
<div class="sect2">
<h3 id="_full_nodes">Full Nodes</h3>
<div class="paragraph"><p>Full nodes are nodes that maintain a full blockchain with all transactions. More accurately they probably should be called "full blockchain nodes". In the early years of bitcoin, all nodes were full nodes and currently the Bitcoin Core client is a full blockchain node. In the last two years, however, new forms of bitcoin clients have been introduced that do not maintain a full blockchain but run as lightweight clients. These are examined in more detail in the next section.</p></div>
<div class="paragraph"><p>Full blockchain nodes maintain a complete and up-to-date copy of the bitcoin blockchain with all the transactions, which they independently build and verify, starting with the very first block (genesis block) and building up to the latest known block in the network. A full blockchain node can independently and authoritatively verify any transaction without recourse or reliance on any other node or source of information. The full blockchain node relies on the network to receive updates about new blocks of transactions, which it then verifies and incorporates into its local copy of the blockchain.</p></div>
<div class="paragraph"><p>Running a full blockchain node gives you the pure bitcoin experience: independent verification of all transactions without the need to rely on, or trust, any other systems. It&#8217;s easy to tell if you&#8217;re running a full node because it requires 20 plus gigabytes of persistent storage (disk space) to store the full blockchain. If you need a lot of disk and it takes 2-3 days to "sync" to the network, you are running a full node. That is the price of complete independence and freedom from central authority.</p></div>
<div class="paragraph"><p>There are a few alternative implementations of full-blockchain bitcoin clients, built using different programming languages and software architectures. However, the most common implementation is the reference client Bitcoin Core, also known as the Satoshi Client. More than 90% of the nodes on the bitcoin network run various versions of Bitcoin Core. It is identified as "Satoshi" in the sub-version string sent in the <code>version</code> message and shown by the command <code>getpeerinfo</code> as we saw above, for example <code>/Satoshi:0.8.6/</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_exchanging_inventory">Exchanging "Inventory"</h3>
<div class="paragraph"><p>The first thing a full node will do once it connects to peers is try to construct a complete blockchain. If it is a brand-new node and has no blockchain at all, then it only knows one block (the genesis block), which is statically embedded in the client software. Starting with block #0, the genesis block, the new node will have to download hundreds of thousands of blocks to synchronize with the network and re-establish the full blockchain.</p></div>
<div class="paragraph"><p>The process of "syncing" the blockchain starts with the <code>version</code> message, as that contains <code>BestHeight</code>, a node&#8217;s current blockchain height (number of blocks). A node will see the <code>version</code> messages from its peers, know how many blocks they each have and be able to compare to how many blocks it has in its own blockchain. Peered nodes will exchange a <code>getblocks</code> message that contains the hash (fingerprint) of the top block on their local blockchain. One of the peers will be able to identify the received hash as belonging to a block that is not at the top, but rather belongs to an older block, thus deducing that its own local blockchain is longer than its peer&#8217;s.</p></div>
<div class="paragraph"><p>The peer that has the longer blockchain has more blocks than the other node and can identify which blocks the other node needs in order to "catch up". It will identify the first 500 blocks to share and transmit their hashes using an <code>inv</code> (inventory) message. The node missing these blocks will then retrieve them, by issuing a series of <code>getdata</code> messages requesting the full block data and identifying the requested blocks using the hashes from the <code>inv</code> message.</p></div>
<div class="paragraph"><p>Let&#8217;s assume for example that a node only has the genesis block. It will then receive an <code>inv</code> message from its peers containing the hashes of the next 500 blocks in the chain. It will start requesting blocks from all of its connected peers, spreading the load and ensuring that it doesn&#8217;t overwhelm any peer with requests. The node keeps track of how many blocks are "in transit" per peer connection, meaning blocks that it has requested but not received, checking that it does not exceed a limit (MAX_BLOCKS_IN_TRANSIT_PER_PEER). This way, if it needs a lot of blocks, it will only request new ones as previous requests are fulfilled, allowing the peers to control the pace of updates and not overwhelming the network. As each block is received, it is added to the blockchain as we will see in the next chapter <a href="#blockchain">[blockchain]</a>. As the local blockchain is gradually built up, more blocks are requested and received and the process continues until the node catches up to the rest of the network.</p></div>
<div class="paragraph"><p>This process of comparing the local blockchain with the peers and retrieving any missing blocks happens any time a node goes offline for any period of time. Whether a node has been offline for a few minutes and is missing a few blocks, or a month and is missing a few thousand blocks, it starts by sending <code>getblocks</code>, gets an <code>inv</code> response, and starts downloading the missing blocks.</p></div>
<div class="imageblock" id="inventory_synchronization">
<div class="content">
<img src="images/InventorySynchronization.png" alt="InventorySynchronization" />
</div>
<div class="title">Figure 44. Node synchronizing the blockchain by retrieving blocks from a peer</div>
</div>
</div>
<div class="sect2">
<h3 id="spv_nodes">Simplified Payment Verification (SPV) Nodes</h3>
<div class="paragraph"><p>Not all nodes have the ability to store the full blockchain. Many bitcoin clients are designed to run on space- and power-constrained devices, such as smartphones, tablets or embedded systems. For such devices, a <em>simplified payment verification</em> (SPV) method is used to allow them to operate without storing the full blockchain. These types of clients are called SPV clients or lightweight clients. As bitcoin adoption surges, the SPV node is becoming the most common form of bitcoin node, especially for bitcoin wallets.</p></div>
<div class="paragraph"><p>SPV nodes download only the block headers and do not download the transactions included in each block. The resulting chain of blocks, without transactions, is 1,000 times smaller than the full blockchain. SPV nodes cannot construct a full picture of all the UTXOs that are available for spending, as they do not know about all the transactions on the network. SPV nodes verify transactions using a slightly different methodology that relies on peers to provide partial views of relevant parts of the blockchain on-demand.</p></div>
<div class="paragraph"><p>As an analogy, a full node is like a tourist in a strange city, equipped with a detailed map of every street and every address. By comparison, an SPV node is like a tourist in a strange city asking random strangers for turn-by-turn directions while knowing only one main avenue. While both tourists can verify the existence of a street by visiting it, the tourist without a map doesn&#8217;t know what lies down any of the side streets and doesn&#8217;t know what other streets exist. Positioned in front of 23 Church Street, the tourist without a map cannot know if there are a dozen other "23 Church Street" addresses in the city and whether this is the right one. The map-less tourist&#8217;s best chance is to ask enough people and hope some of them are not trying to mug the tourist.</p></div>
<div class="paragraph"><p>Simplified Payment Verification verifies transactions by reference to their <em>depth</em> in the blockchain instead of their <em>height</em>. Whereas a full-blockchain node will construct a fully verified chain of thousands of blocks and transactions reaching down the blockchain (back in time) all the way to the genesis block, an SPV node will verify the chain of all blocks and link that chain to the transaction of interest.</p></div>
<div class="paragraph"><p>For example, when examining a transaction in block 300,000, a full node links all 300,000 blocks down to the genesis block and builds a full database of UTXO, establishing the validity of the transaction by confirming that the UTXO remains unspent. An SPV node cannot validate whether the UTXO is unspent. Instead, the SPV node will establish a link between the transaction and the block that contains it, using a Merkle Path (see <a href="#merkle_trees">[merkle_trees]</a>). Then, the SPV node waits until it sees the six blocks 300,001 through 300,006 piled on top of the block containing the transaction and verifies it by establishing its depth under blocks 300,006 to 300,001. The fact that other nodes on the network accepted block 300,000 and then did the necessary work to produce 6 more blocks on top of it is proof, by proxy, that the transaction was not a double-spend.</p></div>
<div class="paragraph"><p>An SPV node cannot be persuaded that a transaction exists in a block, when it does not in fact exist. The SPV node establishes the existence of a transaction in a block by requesting a merkle path proof and by validating the proof-of-work in the chain of blocks. However, a transaction&#8217;s existence can be "hidden" from an SPV node. An SPV node can definitely prove that a transaction exists but cannot verify that a transaction, such as a double-spend of the same UTXO, doesn&#8217;t exist because it doesn&#8217;t have a record of all transactions. This type of attack can be used as a Denial-of-Service attack or as a double-spending attack against SPV nodes. To defend against this, an SPV node needs to connect randomly to several nodes, to increase the probability that it is in contact with at least one honest node. SPV nodes are therefore vulnerable to network partitioning attacks or Sybil attacks, where they are connected to fake nodes or fake networks and do not have access to honest nodes or the real bitcoin network.</p></div>
<div class="paragraph"><p>For most practical purposes, well-connected SPV nodes are secure enough, striking the right balance between resource needs, practicality, and security. For the truly security conscious, however, nothing beats running a full blockchain node.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A full blockchain node verifies a transaction by checking the chain of thousands of blocks below it and checks that the UTXO is not spent, whereas an SPV node checks how deep the block is buried by a handful of blocks above it.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>To get the block headers, SPV nodes use a <code>getheaders</code> message instead of <code>getblocks</code>. The responding peer will send up to 2000 block headers using a single <code>headers</code> message. The process is otherwise the same as that used by a full node to retrieve full blocks. SPV nodes also set a filter on the connection to peers, to filter the stream of future blocks and transactions sent by the peers. Any transactions of interest are retrieved using a <code>getdata</code> request. The peer generates a <code>tx</code> message containing the transactions, in response.</p></div>
<div class="imageblock" id="spv_synchronization">
<div class="content">
<img src="images/SPVSynchronization.png" alt="SPVSynchronization" />
</div>
<div class="title">Figure 45. SPV Node synchronizing the block headers</div>
</div>
<div class="paragraph"><p>Because SPV nodes need to retrieve specific transactions in order to selectively verify them, they also create a privacy risk. Unlike full-blockchain nodes, which collect all transactions within each block, the SPV node&#8217;s requests for specific data can inadvertently reveal the addresses in their wallet. For example, a third party monitoring a network could keep track of all the transactions requested by a wallet on an SPV node and use those to associate bitcoin addresses with the user of that wallet, destroying the user&#8217;s privacy.</p></div>
<div class="paragraph"><p>Shortly after the introduction of SPV/lightweight nodes, the bitcoin developers added a feature called <em>bloom filters</em> to address the privacy risks of SPV nodes. Bloom filters allow SPV nodes to receive a subset of the transactions without revealing precisely which addresses they are interested in, through a filtering mechanism that uses probabilities rather than fixed patterns.</p></div>
</div>
<div class="sect2">
<h3 id="_bloom_filters">Bloom Filters</h3>
<div class="paragraph"><p>A bloom filter is a probabilistic search filter, a way to describe a desired pattern without specifying it exactly. Bloom filters offer an efficient way to express a search pattern while protecting privacy. They are used by SPV nodes to ask their peers for transactions matching a specific pattern, without revealing exactly which addresses they are searching for.</p></div>
<div class="paragraph"><p>In our previous analogy, a tourist without a map is asking for directions to a specific address "23 Church St". If they asks strangers for directions to this street, they inadvertently reveal their destination. A bloom filter is like asking "Are there any streets in this neighborhood whose name ends in R-C-H". A question like that reveals slightly less about the desired destination, than asking for "23 Church St". Using this technique, a tourist could specify the desired address in more detail as "ending in U-R-C-H" or less detail as "ending in H". By varying the precision of the search, the tourist reveals more or less information, at the expense of getting more or less specific results. If they ask a less specific pattern, they get a lot more possible addresses and better privacy but many of the results are irrelevant. If they ask for a very specific pattern then they get fewer results but they lose privacy.</p></div>
<div class="paragraph"><p>Bloom filters serve this function by allowing an SPV node to specify a search pattern for transactions that can be tuned towards precision or privacy. A more specific bloom filter will produce accurate results, but at the expense of revealing what addresses are used in the user&#8217;s wallet. A less specific bloom filter will produce more data about more transactions, many irrelevant to the node, but will allow the node to maintain better privacy.</p></div>
<div class="paragraph"><p>An SPV node will initialize a bloom filter as "empty" and in that state the bloom filter will not match any patterns. The SPV node will then make a list of all the addresses in its wallet and create a search pattern matching the transaction output that corresponds to each address. Usually, the search pattern is a Pay-to-Public-Key-Hash script that is the expected locking script that will be present in any transaction paying to the public-key-hash (address). If the SPV node is tracking the balance of a P2SH address, then the search pattern will be a Pay-to-Script-Hash script, instead. The SPV node then adds each of the search patterns to the bloom filter, so that the bloom filter can recognize the search pattern if it is present in a transaction. Finally, the bloom filter is sent to the peer and the peer uses it to match transactions for transmission to the SPV node.</p></div>
<div class="paragraph"><p>Bloom filters are implemented as a variable-size array of N binary digits (a bit field) and a variable number of M hash functions. The hash functions are designed to always produce an output that is between 1 and N, corresponding to the array of binary digits. The hash functions are generated deterministically, so that any node implementing a bloom filter will always use the same hash functions and get the same results for a specific input. By choosing different length (N) bloom filters and a different number (M) of hash functions, the bloom filter can be tuned, varying the level of accuracy and therefore privacy.</p></div>
<div class="paragraph"><p>In the example below, we use a very small array of 16 bits and a set of 3 hash functions to demonstrate how bloom filters work.</p></div>
<div class="imageblock" id="bloom1">
<div class="content">
<img src="images/Bloom1.png" alt="Bloom1" />
</div>
<div class="title">Figure 46. An example of a simplistic bloom filter, with 16 bit field and 3 hash functions</div>
</div>
<div class="paragraph"><p>The bloom filter is initialized so that the array of bits is all zeros. To add a pattern to the bloom filter, the pattern is hashed by each hash function in turn. Applying the first hash function to the input results in a number between 1 and N. The corresponding bit in the array (indexed from 1 to N) is found and set to <code>1</code>, thereby recording the output of the hash function. Then, the next hash function is used to set another bit and so on and so forth. Once all M hash functions have been applied, the search pattern will be "recorded" in the bloom filter as M bits have been changed from <code>0</code> to <code>1</code>.</p></div>
<div class="paragraph"><p>Here&#8217;s an example of adding a pattern "A" to the simple bloom filter shown above:</p></div>
<div class="imageblock" id="bloom2">
<div class="content">
<img src="images/Bloom2.png" alt="Bloom2" />
</div>
<div class="title">Figure 47. Adding a pattern "A" to our simple bloom filter</div>
</div>
<div class="paragraph"><p>Adding a second pattern is as simple as repeating this process. The pattern is hashed by each hash function in turn and the result is recorded by setting the bits to <code>1</code>. Note that as a bloom filter is filled with more patterns, a hash function result may coincide with a bit that is already set to <code>1</code> in which case the bit is not changed. In essence, as more patterns record on overlapping bits, the bloom filter starts to become saturated with more bits set to <code>1</code> and the accuracy of the filter decreases. This is why the filter is a probabilistic data structure&#8201;&#8212;&#8201;it gets less accurate as more patterns are added. The accuracy depends on the number of patterns added versus the size of the bit array (N) and number of hash functions (M). A larger bit array and more hash functions can record more patterns with higher accuracy. A smaller bit array or fewer hash functions will record fewer patterns and produce less accuracy.</p></div>
<div class="paragraph"><p>Below is an example of adding a second pattern "B" to the simple bloom filter:</p></div>
<div class="imageblock" id="bloom3">
<div class="content">
<img src="images/Bloom3.png" alt="Bloom3" />
</div>
<div class="title">Figure 48. Adding a second pattern "B" to our simple bloom filter</div>
</div>
<div class="paragraph"><p>To test if a pattern is part of a bloom filter, the pattern is hashed by each hash function and the resulting bit pattern is tested against the bit array. If all the bits indexed by the hash functions are set to <code>1</code>, then the pattern is <em>probably</em> recorded in the bloom filter. Since the bits may be set because of overlap from multiple patterns, the answer is not certain, but is rather probabilistic. In simple terms, a bloom filter positive match is a "Maybe, Yes".</p></div>
<div class="paragraph"><p>Below is an example of testing the existence of pattern "X" in the simple bloom filter. The corresponding bits are set to <code>1</code>, so the pattern is probably a match:</p></div>
<div class="imageblock" id="bloom4">
<div class="content">
<img src="images/Bloom4.png" alt="Bloom4" />
</div>
<div class="title">Figure 49. Testing the existence of pattern "X" in the bloom filter. The result is probabilistic positive match, meaning "Maybe"</div>
</div>
<div class="paragraph"><p>On the contrary, if a pattern is tested against the bloom filter and any one of the bits is set to <code>0</code>, then this proves that the pattern was not recorded in the bloom filter. A negative result is not a probability, it is a certainty. In simple terms, a negative match on a bloom filter is a "Definitely No".</p></div>
<div class="paragraph"><p>Below is an example of testing the existence of pattern "Y" in the simple bloom filter. One of the corresponding bits is set to <code>0</code>, so the pattern is definitely not a match:</p></div>
<div class="imageblock" id="bloom5">
<div class="content">
<img src="images/Bloom5.png" alt="Bloom5" />
</div>
<div class="title">Figure 50. Testing the existence of pattern "Y" in the bloom filter. The result is a definitive negative match, meaning "Definitely No"</div>
</div>
<div class="paragraph"><p>Bitcoin&#8217;s implementation of bloom filters is described in Bitcoin Improvement Proposal 37 (BIP0037). See <a href="#bip0037">[bip0037]</a> or visit:
<a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_bloom_filters_and_inventory_updates">Bloom Filters and Inventory Updates</h3>
<div class="paragraph"><p>Bloom filters are used to filter the transactions (and blocks containing them) that an SPV node receives from its peers. SPV nodes will create a filter that matches only the addresses held in the SPV node&#8217;s wallet. The SPV node will then send a <code>filterload</code> message to the peer, containing the bloom filter to use on the connection. After a filter is established, the peer will then test each transaction&#8217;s outputs against the bloom filter. Only transactions which match the filter are sent to the node.</p></div>
<div class="paragraph"><p>In response to a <code>getdata</code> message from the node, peers will send a <code>merkleblock</code> message that contains only block headers for blocks matching the filter and a merkle path (See <a href="#merkle_trees">[merkle_trees]</a>) for each matching transaction. The peer will also then send <code>tx</code> messages containing the transactions matched by the filter.</p></div>
<div class="paragraph"><p>The node setting the bloom filter can interactively add patterns to the filter by sending a <code>filteradd</code> message. To clear the bloom filter, the node can send a <code>filterclear</code> message. Since it is not possible to remove a pattern from a bloom filter, a node has to clear and re-send a new bloom filter if a pattern is no longer desired.</p></div>
</div>
<div class="sect2">
<h3 id="transaction_pools">Transaction Pools</h3>
<div class="paragraph"><p>Almost every node on the bitcoin network maintains a temporary list of unconfirmed transactions called the memory pool or transaction pool. Nodes use this pool to keep track of transactions that are known to the network but are not yet included in the blockchain. For example, a node that holds a user&#8217;s wallet will use the transaction pool to track incoming payments to the user&#8217;s wallet that have been received on the network but are not yet confirmed.</p></div>
<div class="paragraph"><p>As transactions are received and verified, they are added to the transaction pool and relayed to the neighboring nodes to propagate on the network.</p></div>
<div class="paragraph"><p>Some node implementations also maintain a separate pool of orphaned transactions as detailed in <a href="#orphan_transactions">[orphan_transactions]</a>. If a transaction&#8217;s inputs refer to a transaction that is not yet known, a missing parent, then the orphan transaction will be stored temporarily in the orphan pool until the parent transaction arrives.</p></div>
<div class="paragraph"><p>When a transaction is added to the transaction pool, the orphan pool is checked for any orphans that reference this transaction&#8217;s outputs (its children). Any matching orphans are then validated. If valid, they are removed from the orphan pool and added to the transaction pool, completing the chain that started with the parent transaction. In light of the newly added transaction which is no longer an orphan, the process is repeated recursively looking for any further descendants, until no more descendants are found. Through this process, the arrival of a parent transaction triggers a cascade reconstruction of an entire chain of interdependent transactions by re-uniting the orphans with their parents all the way down the chain.</p></div>
<div class="paragraph"><p>Both the transaction pool and orphan pool (where implemented) are stored in local memory and are not saved on persistent storage, rather they are dynamically populated from incoming network messages. When a node starts, both pools are empty and are gradually populated with new transactions received on the network.</p></div>
<div class="paragraph"><p>Some implementations of the bitcoin client also maintain a UTXO database or UTXO pool, which is the set of all unspent outputs on the blockchain. While the name "UTXO pool" sounds similar to the transaction pool, it represents a different set of data. Unlike the transaction and orphan pools, the UTXO pool is not initialized empty but instead contains millions of entries of unspent transaction outputs including some dating back to 2009. The UTXO pool may be housed in local memory or as an indexed database table on persistent storage.</p></div>
<div class="paragraph"><p>Whereas the transaction and orphan pools represent a single node&#8217;s local perspective and may vary significantly from node to node depending upon when the node was started or restarted, the UTXO pool represents the emergent consensus of the network and therefore will vary little between nodes. Furthermore, the transaction and orphan pools only contain unconfirmed transactions, while the UTXO pool only contains confirmed outputs.</p></div>
</div>
<div class="sect2">
<h3 id="_alert_messages">Alert Messages</h3>
<div class="paragraph"><p>Alert messages are a seldom used function, which is nevertheless implemented in most nodes. Alert messages are bitcoin&#8217;s "emergency broadcast system", a means by which the core bitcoin developers can send an emergency text message to all bitcoin nodes. This feature is implemented to allow the core developer team to notify all bitcoin users of a serious problem in the bitcoin network, such as a critical bug that requires user action. The alert system has only been used a handful of times, most notably early 2013 when a critical database bug caused a multi-block fork to occur in the bitcoin blockchain.</p></div>
<div class="paragraph"><p>Alert messages are propagated by the <code>alert</code> message. The alert message contains several fields, including:</p></div>
<div class="ulist"><ul>
<li>
<p>
ID - An alert identified so that duplicate alerts can be detected
</p>
</li>
<li>
<p>
Expiration - a time after which the alert expires
</p>
</li>
<li>
<p>
RelayUntil - a time after which the alert should not be relayed
</p>
</li>
<li>
<p>
MinVer, MaxVer - the range of bitcoin protocol versions that this alert applies to
</p>
</li>
<li>
<p>
subVer - The client software version that this alert applies to
</p>
</li>
<li>
<p>
Priority - An alert priority level, currently unused
</p>
</li>
</ul></div>
<div class="paragraph"><p>Alerts are cryptographically signed by a public key. The corresponding private key is held by a few selected members of the core development team. The digital signature ensures that fake alerts will not be propagated on the network.</p></div>
<div class="paragraph"><p>Each node receiving this alert message will verify it, check for expiration, and propagate it to all its peers, thus ensuring rapid propagation across the entire network. In addition to propagating the alert, each node may implement a user interface function to present the alert to the user.</p></div>
<div class="paragraph"><p>In the Bitcoin Core client, the alert is configured with the command line option <code>-alertnotify</code>, which specifies a command to run when an alert is received. The alert message is passed as a parameter to the alertnotify command. Most commonly, the alertnotify command is set to generate an email message to the administrator of the node, containing the alert message. The alert is also displayed as a pop-up dialog in the graphical user interface (bitcoin-Qt) if it is running.</p></div>
<div class="paragraph"><p>Other implementations of the bitcoin protocol may handle the alert in different ways. Many hardware-embedded bitcoin mining systems do not implement the alert message function, as they have no user interface. It is strongly recommended that miners running such mining systems subscribe to alerts via a mining pool operator or by running a lightweight node just for alert purposes.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="blockchain">The Blockchain</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_2">Introduction</h3>
<div class="paragraph"><p>The blockchain data structure is an ordered back-linked list of blocks of transactions. The blockchain can be stored as a flat file, or in a simple database. The bitcoin core client stores the blockchain metadata using Google&#8217;s LevelDB database. Blocks are linked "back", each referring to the previous block in the chain. The blockchain is often visualized as a vertical stack, with blocks layered on top of each other and the first block ever serving as the foundation of the stack. The visualization of blocks stacked on top of each other results in the use of terms like "height" to refer to the distance from the first block, and "top" or "tip" to refer to the most recently added block.</p></div>
<div class="paragraph"><p>Each block within the blockchain is identified by a hash, generated using the SHA256 cryptographic hash algorithm on the header of the block. Each block also references a previous block, known as the <em>parent</em> block, through the "previous block hash" field in the block header. In other words, each block contains the hash of its parent inside its own header. The sequence of hashes linking each block to its parent, creates a chain going back all the way to the first block ever created, known as the <em>genesis block</em>.</p></div>
<div class="paragraph"><p>While a block has just one parent, it can temporarily have multiple children. Each of the children refers to the same block as its parent and contains the same (parent) hash in the "previous block hash" field. Multiple children arise during a blockchain "fork", a temporary situation that occurs when different blocks are discovered almost simultaneously by different miners (see <a href="#forks">[forks]</a>). Eventually, only one child block becomes part of the blockchain and the "fork" is resolved. Even though a block may have more than one child, each block can have only one parent. This is because a block has one single "previous block hash" field referencing its single parent.</p></div>
<div class="paragraph"><p>The "previous block hash" field is inside the block header and thereby affects the <em>current</em> block&#8217;s hash. The child&#8217;s own identity changes if the parent&#8217;s identity changes. When the parent is modified in any way, the parent&#8217;s hash changes. The parent&#8217;s changed hash necessitates a change in the "previous block hash" pointer of the child. This in turn causes the child&#8217;s hash to change, which requires a change in the pointer of the grandchild, which in turn changes the grandchild and so on. This cascade effect ensures that once a block has many generations following it, it cannot be changed without forcing a recalculation of all subsequent blocks. Because such a recalculation would require enormous computation, the existence of a long chain of blocks makes the blockchain&#8217;s deep history immutable, a key feature of bitcoin&#8217;s security.</p></div>
<div class="paragraph"><p>One way to think about the blockchain is like layers in a geological formation, or glacier core sample. The surface layers may change with the seasons, or even be blown away before they have time to settle. But once you go a few inches deep, geological layers become more and more stable. By the time you look a few hundred feet down, you are looking at a snapshot of the past that has remained undisturbed for millennia or millions of years. In the blockchain, the most recent few blocks may be revised if there is a chain recalculation due to a fork. The top six blocks are like a few inches of topsoil. But once you go deeper into the blockchain, beyond 6 blocks, blocks are less and less likely to change. After 100 blocks back there is so much stability that the "coinbase" transaction, the transaction containing newly-mined bitcoins, can be spent. A few thousand blocks back (a month) and the blockchain is settled history. It will never change.</p></div>
</div>
<div class="sect2">
<h3 id="_structure_of_a_block">Structure of a Block</h3>
<div class="paragraph"><p>A block is a container data structure that aggregates transactions for inclusion in the public ledger, the blockchain. The block is made of a header, containing metadata, followed by a long list of transactions that make up the bulk of its size. The block header is 80 bytes, whereas the average transaction is at least 250 bytes and the average block contains more than 500 transactions. A complete block, with all transactions, is therefore 1000 times larger than the block header.</p></div>
<div class="tableblock" id="block_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 20. The structure of a block</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Block Size</p></td>
<td align="left" valign="top"><p class="table">The size of the block, in bytes, following this field</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">80 bytes</p></td>
<td align="left" valign="top"><p class="table">Block Header</p></td>
<td align="left" valign="top"><p class="table">Several fields form the block header (see below)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Transaction Counter</p></td>
<td align="left" valign="top"><p class="table">How many transactions follow</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Transactions</p></td>
<td align="left" valign="top"><p class="table">The transactions recorded in this block</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="block_header">Block Header</h3>
<div class="paragraph"><p>The block header consists of three sets of block metadata. First, there is a reference to a previous block hash, which connects this block to the previous block in the blockchain. We will examine this in more detail in <a href="#blockchain">[blockchain]</a>. The second set of metadata, namely the difficulty, timestamp and nonce, relate to the mining competition, as detailed in <a href="#mining">[mining]</a>. The third piece of metadata is the Merkle Tree root, a data structure used to efficiently summarize all the transactions in the block.</p></div>
<div class="tableblock" id="block_header_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 21. The structure of the block header</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Version</p></td>
<td align="left" valign="top"><p class="table">A version number to track software/protocol upgrades</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Previous Block Hash</p></td>
<td align="left" valign="top"><p class="table">A reference to the hash of the previous (parent) block in the chain</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Merkle Root</p></td>
<td align="left" valign="top"><p class="table">A hash of the root of the Merkle-Tree of this block&#8217;s transactions</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Timestamp</p></td>
<td align="left" valign="top"><p class="table">The approximate creation time of this block (seconds from Unix Epoch)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Difficulty Target</p></td>
<td align="left" valign="top"><p class="table">The proof-of-work algorithm difficulty target for this block</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Nonce</p></td>
<td align="left" valign="top"><p class="table">A counter used for the proof-of-work algorithm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The Nonce, Difficulty Target, and Timestamp are used in the mining process and will be discussed in more detail in <a href="#mining">[mining]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="block_hash">Block Identifiers - Block Header Hash and Block Height</h3>
<div class="paragraph"><p>The primary identifier of a block is its cryptographic hash, a digital fingerprint, made by hashing the block header twice through the SHA256 algorithm. The resulting 32-byte hash, is called the <em>block hash</em>, but is more accurately the <em>block <strong>header</strong> hash</em>, as only the block header is used to compute it. For example, the block hash of the first bitcoin block ever created is <code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>. The block hash identifies a block uniquely and unambiguously and can be independently derived by any node by simply hashing the block header.</p></div>
<div class="paragraph"><p>Note that the block hash is not actually included inside the block&#8217;s data structure, neither when the block is transmitted on the network, nor when it is stored on a node&#8217;s persistence storage as part of the blockchain. Instead, the block&#8217;s hash is computed by each node as the block is received from the network. The block hash may be stored in a separate database table as part of the block&#8217;s metadata, to facilitate indexing and faster retrieval of blocks from disk.</p></div>
<div class="paragraph"><p>A second way to identify a block is by its position in the blockchain, called the <em>block height</em>. The first block ever created is at block height 0 (zero) and is the same block that was referenced by the block hash <code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code> above. A block can thus be identified two ways, either by referencing the block hash, or by referencing the block height. Each subsequent block added "on top" of that first block is one position "higher" in the blockchain, like boxes stacked one on top of the other. The block height on January 1st 2014 was approximately 278,000, meaning there were 278,000 blocks stacked on top of the first block created in January 2009.</p></div>
<div class="paragraph"><p>Unlike the block hash, the block height is not a unique identifier. While a single block will always have a specific and invariant block height, the reverse is not true - the block height does not always identify a single block. Two or more blocks may have the same block height, competing for the same position in the blockchain. This scenario is discussed in detail in the section on <a href="#forks">[forks]</a>. The block height is also not a part of the block&#8217;s data structure; it is not stored within the block. Each node dynamically identifies a block&#8217;s position (height) in the blockchain when it is received from the bitcoin network. The block height may also be stored as metadata in an indexed database table for faster retrieval.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A block&#8217;s <em>block hash</em> always identifies a single block uniquely. A block also always has a specific <em>block height</em>. However, it is not always the case that a specific block height can identify a single block. Rather, two or more blocks may compete for a single position in the blockchain.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_the_genesis_block">The Genesis Block</h3>
<div class="paragraph"><p>The first block in the blockchain is called the <em>genesis block</em> and was created in 2009. It is the "common ancestor" of all the blocks in the blockchain, meaning that if you start at any block and follow the chain backwards in time, you will eventually arrive at the <em>genesis block</em>.</p></div>
<div class="paragraph"><p>Every node always starts with a blockchain of at least one block because the genesis block is statically encoded within the bitcoin client software, such that it cannot be altered. Every node always "knows" the genesis block&#8217;s hash and structure, the fixed time it was created and even the single transaction within. Thus, every node has the starting point for the blockchain, a secure "root" from which to build a trusted blockchain.</p></div>
<div class="paragraph"><p>See the statically encoded genesis block inside the Bitcoin Core client, in chainparams.cpp:</p></div>
<div class="paragraph"><p><a href="https://github.com/bitcoin/bitcoin/blob/3955c3940eff83518c186facfec6f50545b5aab5/src/chainparams.cpp#L123">https://github.com/bitcoin/bitcoin/blob/3955c3940eff83518c186facfec6f50545b5aab5/src/chainparams.cpp#L123</a></p></div>
<div class="paragraph"><p>The genesis block has the identifier hash <code>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</code>. You can search for that block hash in any block explorer website, such as blockchain.info, and you will find a page describing the contents of this block, with a URL containing that hash:</p></div>
<div class="paragraph"><p><a href="https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a></p></div>
<div class="paragraph"><p><a href="https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a></p></div>
<div class="paragraph"><p>Using the Bitcoin Core reference client on the command-line:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The genesis block contains a hidden message within it. The coinbase transaction input contains the text "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks". This message provides proof of the earliest date this block was created, by referencing the headline of the british newspaper <em>The Times</em>. It also serves as a tongue-in-cheek reminder of the importance of an independent monetary system, with bitcoin&#8217;s launch occurring at the same time as an unprecedented worldwide monetary crisis. The message was embedded in the first block by Satoshi Nakamoto, bitcoin&#8217;s creator.</p></div>
</div>
<div class="sect2">
<h3 id="_linking_blocks_in_the_blockchain">Linking Blocks in the Blockchain</h3>
<div class="paragraph"><p>Bitcoin nodes maintain a local copy of the blockchain, starting at the genesis block. The local copy of the blockchain is constantly updated as new blocks are found and used to extend the chain. As a node receives incoming blocks from the network, it will validate these blocks and then link them to the existing blockchain. To establish a link, a node will examine the incoming block header and look for the "previous block hash".</p></div>
<div class="paragraph"><p>Let&#8217;s assume, for example, that a node has 277,314 blocks in the local copy of the blockchain. The last block the node knows about is block 277,314, with a block header hash of <code>00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249</code>.</p></div>
<div class="paragraph"><p>The bitcoin node then receives a new block from the network, which it parses as follows:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Looking at this new block, the node finds the "previousblockhash" field, which contains the hash of its parent block. It is a hash known to the node, that of the last block on the chain at height 277,314. Therefore, this new block is a child of the last block on the chain and extends the existing blockchain. The node adds this new block to the end of the chain, making the blockchain longer with a new height of 277,315.</p></div>
<div class="imageblock" id="chain_of_blocks">
<div class="content">
<img src="images/ChainOfBlocks.png" alt="chain_of_blocks" />
</div>
<div class="title">Figure 51. Blocks linked in a chain, by reference to the previous block header hash</div>
</div>
</div>
<div class="sect2">
<h3 id="merkle_trees">Merkle Trees</h3>
<div class="paragraph"><p>Each block in the bitcoin blockchain contains a summary of all the transactions in the block, using a <em>Merkle Tree</em>.</p></div>
<div class="paragraph"><p>A <em>Merkle Tree</em>, also known as a <em>Binary Hash Tree</em> is a data structure used for efficiently summarizing and verifying the integrity of large sets of data. Merkle Trees are binary trees containing cryptographic hashes. The term "tree" is used in computer science to describe a branching data structure, but these trees are usually displayed upside down with the "root" at the top and the "leaves" at the bottom of a diagram, as you will see in the examples that follow.</p></div>
<div class="paragraph"><p>Merkle trees are used in bitcoin to summarize all the transactions in a block, producing an overall digital fingerprint of the entire set of transactions, providing a very efficient process to verify if a transaction is included in a block. A merkle tree is constructed by recursively hashing pairs of nodes until there is only one hash, called the <em>root</em>, or <em>merkle root</em>. The cryptographic hash algorithm used in bitcoin&#8217;s merkle trees is SHA256 applied twice, also known as double-SHA256.</p></div>
<div class="paragraph"><p>When N data elements are hashed and summarized in a Merkle Tree, you can check to see if any one data element is included in the tree with at most <code>2*log<sub>2</sub>(N)</code> calculations, making this a very efficient data structure.</p></div>
<div class="paragraph"><p>The merkle tree is constructed bottom-up. In the example below, we start with four transactions A, B, C and D, which form the <em>leaves</em> of the Merkle Tree, shown in the diagram at the bottom. The transactions are not stored in the merkle tree, rather their data is hashed and the resulting hash is stored in each leaf node as H<sub>A</sub>, H<sub>B</sub>, H<sub>C</sub> and H<sub>D</sub>:</p></div>
<div class="paragraph"><p><code>H<sub>A</sub> = SHA256(SHA256(Transaction A))</code></p></div>
<div class="paragraph"><p>Consecutive pairs of leaf nodes are then summarized in a parent node, by concatenating the two hashes and hashing them together. For example, to construct the parent node H<sub>AB</sub>, the two 32-byte hashes of the children are concatenated to create a 64-byte string. That string is then double-hashed to produce the parent node&#8217;s hash:</p></div>
<div class="paragraph"><p><code>H<sub>AB</sub> = SHA256(SHA256(H<sub>A</sub> + H<sub>B</sub>))</code></p></div>
<div class="paragraph"><p>The process continues until there is only one node at the top, the node known as the Merkle Root. That 32-byte hash is stored in the block header and summarizes all the data in all four transactions.</p></div>
<div class="imageblock" id="simple_merkle">
<div class="content">
<img src="images/MerkleTree.png" alt="merkle_tree" />
</div>
<div class="title">Figure 52. Calculating the nodes in a Merkle Tree</div>
</div>
<div class="paragraph"><p>Since the merkle tree is a binary tree, it needs an even number of leaf nodes. If there is an odd number of transactions to summarize, the last transaction hash will be duplicated to create an even number of leaf nodes, also known as a <em>balanced tree</em>. This is shown in the example below, where transaction C is duplicated:</p></div>
<div class="imageblock" id="merkle_tree_odd">
<div class="content">
<img src="images/MerkleTreeOdd.png" alt="merkle_tree_odd" />
</div>
<div class="title">Figure 53. An even number of data elements, by duplicating one data element</div>
</div>
<div class="paragraph"><p>The same method for constructing a tree from four transactions can be generalized to construct trees of any size. In bitcoin it is common to have several hundred to more than a thousand transactions in a single block, which are summarized in exactly the same way producing just 32 bytes of data as the single merkle root. In the diagram below, you will see a tree built from 16 transactions. Note that while the root looks bigger than the leaf nodes in the diagram, it is the exact same size, just 32 bytes. Whether there is one transaction or a hundred thousand transactions in the block, the merkle root always summarizes them into 32 bytes:</p></div>
<div class="imageblock" id="merkle_tree_large">
<div class="content">
<img src="images/MerkleTreeLarge.png" alt="merkle_tree_large" />
</div>
<div class="title">Figure 54. A Merkle Tree summarizing many data elements</div>
</div>
<div class="paragraph"><p>To prove that a specific transaction is included in a block, a node only needs to produce <code>log<sub>2</sub>(N)</code> 32-byte hashes, constituting an <em>authentication path</em> or <em>merkle path</em> connecting the specific transaction to the root of the tree. This is especially important as the number of transactions increases, because the base-2 logarithm of the number of transactions increases much more slowly. This allows bitcoin nodes to efficiently produce paths of ten or twelve hashes (320-384 bytes) which can provide proof of a single transaction out of more than a thousand transactions in a megabyte sized block. In the example below, a node can prove that a transaction K is included in the block by producing a merkle path that is only four 32-byte hashes long (128 bytes total). The path consists of the four hashes (noted in blue in the diagram below) H<sub>L</sub>, H<sub>IJ</sub>, H<sub>MNOP</sub> and H<sub>ABCDEFGH</sub>. With those four hashes provided as an authentication path, any node can prove that H<sub>K</sub> (noted in green in the diagram below) is included in the merkle root by computing four additional pair-wise hashes H<sub>KL</sub>, H<sub>IJKL</sub> and H<sub>IJKLMNOP</sub> (outlined in a dotted line in the diagram below) that lead to the merkle root.</p></div>
<div class="imageblock" id="merkle_tree_path">
<div class="content">
<img src="images/MerkleTreePathToK.png" alt="merkle_tree_path" />
</div>
<div class="title">Figure 55. A Merkle Path used to prove inclusion of a data element</div>
</div>
<div class="paragraph"><p>The code in <a href="#merkle_example">[merkle_example]</a> demonstrates the process of creating a merkle tree from the leaf-node hashes up to the root, using the libbitcoin library for some helper functions:</p></div>
<div class="exampleblock" id="merkle_example">
<div class="title">Example 13. Building a merkle tree</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Compiling and running the merkle code:</p></div>
<div class="exampleblock" id="merkle_example_run">
<div class="title">Example 14. Compiling and running the merkle example code</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The efficiency of merkle trees becomes obvious as the scale increases. For example, proving that a transaction is part of a block requires:</p></div>
<div class="tableblock" id="block_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 22. Merkle Tree Efficiency</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top">Number of Transactions</th>
<th align="left" valign="top"> Approx. Size of Block </th>
<th align="left" valign="top"> Path Size (Hashes) </th>
<th align="left" valign="top"> Path Size (Bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">16 transactions</p></td>
<td align="left" valign="top"><p class="table">4 kilobytes</p></td>
<td align="left" valign="top"><p class="table">4 hashes</p></td>
<td align="left" valign="top"><p class="table">128 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">512 transactions</p></td>
<td align="left" valign="top"><p class="table">128 kilobytes</p></td>
<td align="left" valign="top"><p class="table">9 hashes</p></td>
<td align="left" valign="top"><p class="table">288 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2048 transactions</p></td>
<td align="left" valign="top"><p class="table">512 kilobytes</p></td>
<td align="left" valign="top"><p class="table">11 hashes</p></td>
<td align="left" valign="top"><p class="table">352 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">65,535 transactions</p></td>
<td align="left" valign="top"><p class="table">16 megabytes</p></td>
<td align="left" valign="top"><p class="table">16 hashes</p></td>
<td align="left" valign="top"><p class="table">512 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>As you can see from the table above, while the block size increases rapidly, from 4KB with 16 transactions to a block size of 16 MB to fit 65,535 transactions, the merkle path required to prove the inclusion of a transaction increases much more slowly, from 128 bytes to only 512 bytes. With merkle trees, a node can download just the block headers (80 bytes per block) and still be able to identify a transaction&#8217;s inclusion in a block by retrieving a small merkle path from a full node, without storing or transmitting the vast majority of the blockchain which may be several gigabytes in size. Nodes which do not maintain a full blockchain, called Simplified Payment Verification or SPV nodes use merkle paths to verify transactions without downloading full blocks.</p></div>
</div>
<div class="sect2">
<h3 id="_merkle_trees_and_simplified_payment_verification_spv">Merkle Trees and Simplified Payment Verification (SPV)</h3>
<div class="paragraph"><p>Merkle trees are used extensively by Simplified Payment Verification nodes. SPV nodes don&#8217;t have all transactions and do not download full blocks, just block headers. In order to verify that a transaction is included in a block, without having to download all the transactions in the block, they use an <em>authentication path</em>, or merkle path.</p></div>
<div class="paragraph"><p>Consider for example an SPV node that is interested in incoming payments to an address contained in its wallet. The SPV node will establish a bloom filter on its connections to peers to limit the transactions received to only those containing addresses of interest. When a peer sees a transaction that matches the bloom filter, it will send that block using a <code>merkleblock</code> message. The <code>merkleblock</code> message contains the block header as well as a merkle path that links the transaction of interest to the merkle root in the block. The SPV node can use this merkle path to connect the transaction to the block and verify that the transaction is included in the block. The SPV node also uses the block header to link the block to the rest of the blockchain. The combination of these two links, between the transaction and block, and between the block and blockchain, proves that the transaction is recorded in the blockchain. All in all, the SPV node will have received less than a kilobyte of data for the block header and merkle path, an amount of data that is more than a thousand times less than a full block (about 1 megabyte currently).</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch8">Mining and Consensus</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mining">Introduction</h3>
<div class="paragraph"><p>Mining is the process by which new bitcoin is added to the money supply. Mining also serves to secure the bitcoin system against fraudulent transactions or transactions spending the same amount of bitcoin more than once, known as a double-spend. Miners provide processing power to the bitcoin network in exchange for the opportunity to be rewarded bitcoin.</p></div>
<div class="paragraph"><p>Miners validate new transactions and record them on the global ledger. A new block, containing transactions that occurred since the last block, is "mined" every 10 minutes, thereby adding those transactions to the blockchain. Transactions that become part of a block and added to the blockchain are considered "confirmed", which allows the new owners of bitcoin to spend the bitcoin they received in those transactions.</p></div>
<div class="paragraph"><p>Miners receive two types of reward for mining: new coins created with each new block and transaction fees from all the transactions included in the block. To earn this reward, the miners compete to solve a difficult mathematical problem based on a cryptographic hash algorithm. The solution to the problem, called the Proof-of-Work, is included in the new block and acts as proof that the miner expended significant computing effort. The competition to solve the Proof-of-Work algorithm to earn reward and the right to record transactions on the blockchain is the basis for bitcoin&#8217;s security model.</p></div>
<div class="paragraph"><p>The process of new coin generation is called mining, because the reward is designed to simulate diminishing returns, just like mining for precious metals. Bitcoin&#8217;s money supply is created through mining, similar to how a central bank issues new money by printing bank notes. The amount of newly created bitcoin a miner can add to a block decreases approximately every four years (or precisely every 210,000 blocks). It started at 50 bitcoin per block in January of 2009 and halved to 25 bitcoin per block in November of 2012. It will halve again to 12.5 bitcoin per block sometime in 2016. Based on this formula, bitcoin mining rewards decrease exponentially until approximately the year 2140 when all bitcoin (20.99999998 million) will have been issued. After 2140, no new bitcoins will be issued.</p></div>
<div class="paragraph"><p>Bitcoin miners also earn fees from transactions. Every transaction may include a transaction fee, in the form of a surplus of bitcoin between the transaction&#8217;s inputs and outputs. The winning bitcoin miner gets to "keep the change" on the transactions included in the winning block. Today, the fees represent 0.5% or less of a bitcoin miner&#8217;s income, the vast majority coming from the newly minted bitcoins. However, as the reward decreases over time and the number of transactions per block increases, a greater proportion of bitcoin mining earnings will come from fees. After 2140, all bitcoin miner earnings will be in the form of transaction fees.</p></div>
<div class="paragraph"><p>The word "mining" is somewhat misleading. By evoking the extraction of precious metals, it focuses our attention on the reward for mining, the new bitcoins in each block. While mining is incentivized by this reward, the primary purpose of mining is not the reward or the generation of new coins. If you view mining only as the process by which coins are created you are mistaking the means (incentives) as a goal of the process. Mining is the main process of the de-centralized clearinghouse, by which transactions are validated and cleared. Mining secures the bitcoin system and enables the emergence of network-wide consensus without a central authority.</p></div>
<div class="paragraph"><p>Mining is the invention that makes bitcoin special, a de-centralized security mechanism that is the basis for peer-to-peer digital cash. The reward of newly minted coins and transaction fees is an incentive scheme that aligns the actions of miners with the security of the network, while simultaneously implementing the monetary supply.</p></div>
<div class="paragraph"><p>In this chapter, we will first examine mining as a monetary supply mechanism and then look at the most important function of mining, the de-centralized emergent consensus mechanism that underpins bitcoin&#8217;s security.</p></div>
<div class="sect3">
<h4 id="_bitcoin_economics_and_currency_creation">Bitcoin Economics and Currency Creation</h4>
<div class="paragraph"><p>Bitcoins are "minted" during the creation of each block at a fixed and diminishing rate. Each block, generated on average every 10 minutes, contains entirely new bitcoins, created from nothing. Every 210,000 blocks or approximately every four years the currency issuance rate is decreased by 50%. For the first four years of operation of the network, each block contained 50 new bitcoin.</p></div>
<div class="paragraph"><p>In November of 2012, the new bitcoin issuance rate was decreased to 25 bitcoin per block and it will decrease again to 12.5 bitcoin at block 420,000, which will be mined sometime in 2016. The rate of new coins decreases like this exponentially over 64 "halvings", until block 13,230,000 (mined approximately in year 2137) when it reaches the minimum currency unit of 1 satoshi. Finally, after 13.44 million blocks, in approximately 2140, all 2,099,999,997,690,000 satoshis, or almost 21 million bitcoin will be issued. Thereafter, blocks will contain no new bitcoin, and miners will be rewarded solely through the transaction fees.</p></div>
<div class="paragraph"><p>In the example code in <a href="#max_money_">[max_money_]</a>, we calculate the total amount of bitcoin that will be issued:</p></div>
<div class="exampleblock" id="max_money">
<div class="title">Example 15. A script for calculating how much total bitcoin will be issued</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Running the script:</p></div>
<div class="exampleblock" id="max_money_run">
<div class="title">Example 16. Running the max_money.py script</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="imageblock" id="bitcoin_money_supply">
<div class="content">
<img src="images/BitcoinMoneySupply.png" alt="BitcoinMoneySupply" />
</div>
<div class="title">Figure 56. Supply of bitcoin currency over time based on a geometrically decreasing issuance rate</div>
</div>
<div class="paragraph"><p>The finite and diminishing issuance creates a fixed monetary supply that resists inflation. Unlike a fiat currency, which can be printed in infinite numbers by a central bank, bitcoin can never be inflated by printing.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Deflationary Money</div>
<div class="paragraph"><p>The most important and debated consequence of a fixed and diminishing monetary issuance is that the currency will tend to be inherently <em>deflationary</em>. Deflation is the phenomenon of appreciation of value due to a mismatch in supply and demand that drives up the value (and exchange rate) of a currency. The opposite of inflation, price deflation means that the money has more purchasing power over time.</p></div>
<div class="paragraph"><p>Many economists argue that a deflationary economy is a disaster that should be avoided at all costs. That is because in a period of rapid deflation people will tend to hoard money instead of spending it, hoping that prices will fall. Such a phenomenon unfolded during Japan&#8217;s "Lost Decade", when a complete collapse of demand pushed the currency into a deflationary spiral.</p></div>
<div class="paragraph"><p>Bitcoin experts argue that deflation is not bad <strong>per se</strong>. Rather, deflation is associated with a collapse in demand because that is the only example of deflation we have to study. In a fiat currency with the possibility of unlimited printing, it is very difficult to enter a deflationary spiral unless there is a complete collapse in demand and an unwillingness to print money. Deflation in bitcoin is not caused by a collapse in demand, but by a predictably constrained supply.</p></div>
<div class="paragraph"><p>In practice, it has become evident that the hoarding instinct caused by a deflationary currency can be overcome by discounting from vendors, until the discount overcomes the hoarding instinct of the buyer. Since the seller is also motivated to hoard, the discount becomes the equilibrium price at which the two hoarding instincts are matched. With discounts of 30% on the bitcoin price, most bitcoin retailers are not experiencing difficulty overcoming the hoarding instinct and generating revenue. It remains to be seen whether the deflationary aspect of the currency is really a problem when it is not driven by rapid economic retraction.</p></div>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_de_centralized_consensus">De-centralized Consensus</h3>
<div class="paragraph"><p>In the previous chapter we looked at the blockchain, the global public ledger (list) of all transactions, which everyone in the bitcoin network accepts as the authoritative record of ownership.</p></div>
<div class="paragraph"><p>But how can everyone in the network agree on a single universal "truth" about who owns what, without having to trust anyone? All traditional payment systems depend on a trust model that has a central authority providing a clearinghouse service, basically verifying and clearing all transactions. Bitcoin has no central authority, yet somehow every node has a complete copy of a public ledger that it can trust as the authoritative record. The blockchain is not created by a central authority, but is assembled independently by every node in the network. Somehow, every node in the network, acting on information transmitted across insecure network connections can arrive at the same conclusion and assemble a copy of the same public ledger as everyone else. This chapter examines the process by which the bitcoin network achieves global consensus without central authority.</p></div>
<div class="paragraph"><p>Satoshi Nakamoto&#8217;s main invention is the decentralized mechanism for <em>emergent consensus</em>. Emergent, because consensus is not achieved explicitly&#8201;&#8212;&#8201;there is no election or fixed moment when consensus occurs. Instead, consensus is an emergent artifact of the asynchronous interaction of thousands of independent nodes, all following simple rules. All the properties of bitcoin, including currency, transactions, payments, and the security model that does not depend on central authority or trust, derive from this invention.</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s de-centralized consensus emerges from the interplay of four processes that occur independently on nodes across the network:</p></div>
<div class="ulist"><ul>
<li>
<p>
Independent verification of each transaction, by every full node, based on a comprehensive list of criteria
</p>
</li>
<li>
<p>
Independent aggregation of those transactions into new blocks by mining nodes, coupled with demonstrated computation through a Proof-of-Work algorithm
</p>
</li>
<li>
<p>
Independent verification of the new blocks by every node and assembly into a chain
</p>
</li>
<li>
<p>
Independent selection, by every node, of the chain with the most cumulative computation demonstrated through Proof-of-Work
</p>
</li>
</ul></div>
<div class="paragraph"><p>In the next few sections we will examine these processes and how they interact to create the emergent property of network-wide consensus that allows any bitcoin node to assemble its own copy of the authoritative, trusted, public, global ledger.</p></div>
</div>
<div class="sect2">
<h3 id="tx_verification">Independent Verification of Transactions</h3>
<div class="paragraph"><p>In a previous chapter we saw how wallet software creates transactions by collecting UTXO, providing the appropriate unlocking scripts, and then constructing new outputs assigned to a new owner. The resulting transaction is then sent to the neighboring nodes in the bitcoin network so that it may be propagated across the entire bitcoin network.</p></div>
<div class="paragraph"><p>However, before forwarding transactions to its neighbors, every bitcoin node that receives a transaction will first verify the transaction. This ensures that only valid transactions are propagated across the network, while invalid transactions are discarded at the first node that encounters them.</p></div>
<div class="paragraph"><p>Each node verifies every transaction against a long checklist of criteria:</p></div>
<div class="ulist"><ul>
<li>
<p>
The transaction&#8217;s syntax and data structure must be correct
</p>
</li>
<li>
<p>
Neither lists of inputs or outputs are empty
</p>
</li>
<li>
<p>
The transaction size in bytes is less than MAX_BLOCK_SIZE
</p>
</li>
<li>
<p>
Each output value, as well as the total, must be within the allowed range of values (less than 21m coins, more than 0)
</p>
</li>
<li>
<p>
None of the inputs have hash=0, N=-1 (coinbase transactions should not be relayed)
</p>
</li>
<li>
<p>
nLockTime is less than or equal to INT_MAX
</p>
</li>
<li>
<p>
The transaction size in bytes is greater than or equal to 100
</p>
</li>
<li>
<p>
The number of signature operations contained in the transaction is less than the signature operation limit
</p>
</li>
<li>
<p>
The unlocking script (scriptSig) can only push numbers on the stack, and the locking script (scriptPubkey) must match isStandard forms (this rejects "nonstandard" transactions)
</p>
</li>
<li>
<p>
A matching transaction in the pool, or in a block in the main branch, must exist
</p>
</li>
<li>
<p>
For each input, if the referenced output exists in any other transaction in the pool, reject this transaction
</p>
</li>
<li>
<p>
For each input, look in the main branch and the transaction pool to find the referenced output transaction. If the output transaction is missing for any input, this will be an orphan transaction. Add to the orphan transactions pool, if a matching transaction is not already in the pool
</p>
</li>
<li>
<p>
For each input, if the referenced output transaction is a coinbase output, it must have at least COINBASE_MATURITY (100) confirmations
</p>
</li>
<li>
<p>
For each input, the referenced output must exist and cannot already be spent
</p>
</li>
<li>
<p>
Using the referenced output transactions to get input values, check that each input value, as well as the sum, are in the allowed range of values (less than 21m coins, more than 0)
</p>
</li>
<li>
<p>
Reject if the sum of input values &lt; sum of output values
</p>
</li>
<li>
<p>
Reject if transaction fee would be too low to get into an empty block
</p>
</li>
<li>
<p>
The unlocking scripts for each input must validate against the corresponding output locking scripts
</p>
</li>
</ul></div>
<div class="paragraph"><p>These conditions can be seen in detail in the functions <code>AcceptToMemoryPool</code>, <code>CheckTransaction</code>, and <code>CheckInputs</code> in the bitcoin reference client. Note that the conditions change over time, to address new types of Denial-of-Service attacks or sometimes to relax the rules so as to include more types of transactions.</p></div>
<div class="paragraph"><p>By independently verifying each transaction as it is received and before propagating it, every node builds a pool of valid new transactions (the transaction pool), roughly in the same order.</p></div>
</div>
<div class="sect2">
<h3 id="_mining_nodes">Mining Nodes</h3>
<div class="paragraph"><p>Some of the nodes on the bitcoin network are specialized nodes called <em>miners</em>. In Chapter 1 we introduced Jing, a computer engineering student in Shanghai, China, who is a bitcoin miner. Jing earns bitcoin by running a "mining rig", which is a specialized computer-hardware system designed to mine bitcoins. Jing&#8217;s specialized mining hardware is connected to a server running a full bitcoin node. Unlike Jing, some miners mine without a full node as we will see in <a href="#mining pools">[mining pools]</a>. Like every other full node, Jing&#8217;s node receives and propagates unconfirmed transactions on the bitcoin network. Jing&#8217;s node, however, also aggregates these transactions into new blocks.</p></div>
<div class="paragraph"><p>Jing&#8217;s node is listening for new blocks, propagated on the bitcoin network, as do all nodes. However, the arrival of a new block has special significance for a mining node. The competition among miners effectively ends with the propagation of a new block which acts as an announcement of a winner. To a miner, receiving a new block means someone else won the competition and they lost. However, the end of one round of a competition is also the beginning of the next round. The new block is not just a checkered flag, marking the end of the race, it is also the starting pistol starting the race for the next block.</p></div>
</div>
<div class="sect2">
<h3 id="_aggregating_transactions_into_blocks">Aggregating Transactions into Blocks</h3>
<div class="paragraph"><p>After validating transactions, a bitcoin node will add them to the <em>memory pool</em>, or <em>transaction pool</em>, where transactions await until they can be included (mined) into a block. Jing&#8217;s node collects, validates and relays new transactions just like any other node. Unlike other nodes, however, Jing&#8217;s node will then aggregate these transactions into a <em>candidate block</em>.</p></div>
<div class="paragraph"><p>Let&#8217;s follow the blocks that were created during the time Alice bought a cup of coffee from Bob&#8217;s Cafe (see <a href="#cup_of_coffee">[cup_of_coffee]</a>). Alice&#8217;s transaction was included in block 277,316. For the purpose of demonstrating the concepts in this chapter let&#8217;s assume that block was mined by Jing&#8217;s mining system and follow Alice&#8217;s transaction as it becomes part of this new block.</p></div>
<div class="paragraph"><p>Jing&#8217;s mining node maintains a local copy of the blockchain, the list of all blocks created since the beginning of the bitcoin system in 2009. By the time Alice buys the cup of coffee, Jing&#8217;s node has assembled a chain up to block 277,314. Jing&#8217;s node is listening for transactions, trying to mine a new block and also listening for blocks discovered by other nodes. As Jing&#8217;s node is mining, it receives block 277,315 through the bitcoin network. The arrival of this block signifies the end of the competition for block 277,315 and the beginning of the competition to create block 277,316.</p></div>
<div class="paragraph"><p>During the previous 10 minutes, while Jing&#8217;s node was searching for a solution to block 277,315, it was also collecting transactions in preparation for the next block. By now it has collected a few hundred transactions in the memory pool. Upon receiving block 277,315 and validating it, Jing&#8217;s node will also check all the transactions in the memory pool and remove any that were included in block 277,315. Whatever transaction remain in the memory pool are unconfirmed and are waiting to be recorded in a new block.</p></div>
<div class="paragraph"><p>Jing&#8217;s node immediately constructs a new empty block, a candidate for block 277,316. This block is called a candidate block because it is not yet a valid block, as it does not contain a valid proof-of-work. The block becomes valid only if the miner succeeds in finding a solution to the Proof-of-Work algorithm.</p></div>
<div class="sect3">
<h4 id="_transaction_age_fees_and_priority">Transaction Age, Fees, and Priority</h4>
<div class="paragraph"><p>To construct the candidate block Jing&#8217;s bitcoin node selects transactions from the memory pool, by applying a priority metric to each transaction and adding the highest priority transactions first. Transactions are prioritized based on the "age" of the UTXO that is being spent in their inputs, allowing for old and high-value inputs to be prioritized over newer and smaller inputs. Prioritized transactions can be sent without any fees, if there is enough space in the block.</p></div>
<div class="paragraph"><p>The priority of a transaction is calculated as the sum of the value and age of the inputs divided by the total size of the transaction:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Priority = Sum (Value of input * Input Age) / Transaction Size</code></pre>
</div></div>
<div class="paragraph"><p>In the equation above, the value of an input is measured in the base unit, satoshis (1/100m of a bitcoin). The age of a UTXO is the number of blocks that have elapsed since the UTXO was recorded on the blockchain, measuring how many blocks "deep" into the blockchain it is. The size of the transaction is measured in bytes.</p></div>
<div class="paragraph"><p>For a transaction to be considered "high priority" its priority must be greater than 57,600,000, which corresponds to one bitcoin (100m satoshis), aged one day (144 blocks) in a transaction of 250 bytes total size.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>High Priority &gt; 100,000,000 satoshis * 144 blocks / 250 bytes = 57,600,000</code></pre>
</div></div>
<div class="paragraph"><p>The first 50 kilobytes of transaction space in a block are set aside for high priority transactions. Jing&#8217;s node will fill the first 50 kilobytes, prioritizing the highest priority transactions first, regardless of fee. This allows high-priority transactions to be processed even if they carry zero fees.</p></div>
<div class="paragraph"><p>Jing&#8217;s mining node then fills the rest of the block up to the maximum block size (MAX_BLOCK_SIZE in the code), with transactions that carry at least the minimum fee, prioritizing those with the highest fee per kilobyte of transaction.</p></div>
<div class="paragraph"><p>If there is any space remaining in the block, Jing&#8217;s mining node may choose to fill it with no-fee transactions. Some miners choose to mine transactions without fees on a best-effort basis. Other miners may choose to ignore transactions without fees.</p></div>
<div class="paragraph"><p>Any transactions left in the memory pool, after the block is filled, will remain in the pool for inclusion in the next block. As transactions remain in the memory pool, their inputs "age", as the UTXO they spend get deeper into the blockchain with new blocks added on top. Since a transaction&#8217;s priority depends on the age of its inputs, transactions remaining in the pool will age and therefore increase in priority. Eventually a transaction without fees may reach a high enough priority to be included in the block for free.</p></div>
<div class="paragraph"><p>Bitcoin transactions do not have an expiration time-out. A transaction that is valid now will be valid in perpetuity. However, if a transaction is only propagated across the network once it will persist only as long as it is held in a mining node memory pool. When a mining node is restarted, its memory pool is wiped clear, as it is a transient non-persistent form of storage. While a valid transaction may have been propagated across the network, if it is not executed it may eventually not reside in the memory pool of any miner. Wallet software are expected to retransmit such transactions or reconstruct them with higher fees if they are not successfully executed within a reasonable amount of time.</p></div>
<div class="paragraph"><p>When Jing&#8217;s node aggregates all the transactions from the memory pool, the new candidate block has 418 transactions with total transaction fees of 0.09094928 bitcoin. You can see this block in the blockchain using the Bitcoin Core client command line interface:</p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="exampleblock" id="block277316">
<div class="title">Example 17. Block 277,316</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_the_generation_transaction">The Generation Transaction</h4>
<div class="paragraph"><p>The first transaction added to the block is a special transaction, called a <em>generation transaction</em> or <em>coinbase transaction</em>. This transaction is constructed by Jing&#8217;s node and is his reward for the mining effort. Jing&#8217;s node creates the generation transaction as a payment to his own wallet: "Pay Jing&#8217;s address 25.09094928 bitcoin". The total amount of reward that Jing collects for mining a block is the sum of the coinbase reward (25 new bitcoins) and the transaction fees (0.09094928) from all the transactions included in the block.</p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="exampleblock" id="generation_tx_example">
<div class="title">Example 18. Generation Transaction</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Unlike regular transactions, the generation transaction does not consume (spend) UTXO as inputs. Instead, it has only one input, called the <em>coinbase</em>, which creates bitcoin from nothing. The generation transaction has one output, payable to the miner&#8217;s own bitcoin address. The output of the generation transaction sends the value of 25.09094928 bitcoins to the miner&#8217;s bitcoin address, in this case <code>1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N</code>.</p></div>
</div>
<div class="sect3">
<h4 id="_coinbase_reward_and_fees">Coinbase Reward and Fees</h4>
<div class="paragraph"><p>To construct the generation transaction, Jing&#8217;s node first calculates the total amount of transaction fees by adding all the inputs and outputs of the 418 transactions that were added to the block. The fees are calculated as:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Total Fees = Sum(Inputs) - Sum(Outputs)</code></pre>
</div></div>
<div class="paragraph"><p>In block 277,316 the total transaction fees are 0.09094928 bitcoin.</p></div>
<div class="paragraph"><p>Next, Jing&#8217;s node calculates the correct reward for the new block. The reward is calculated based on the block height, starting at 50 bitcoin per block and reduced by half every 210,000 blocks. Since this block is at height 277,316, the correct reward is 25 bitcoin.</p></div>
<div class="paragraph"><p>The calculation can be seen in function <code>GetBlockValue</code> in the Bitcoin Core client:</p></div>
<div class="exampleblock" id="getblockvalue_source">
<div class="title">Example 19. Calculating the block reward - Function GetBlockValue, Bitcoin Core Client, main.cpp, line 1305</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The initial subsidy is calculated in satoshis by multiplying 50 with the <code>COIN</code> constant (100,000,000 satoshis). This sets the initial reward (<code>nSubsidy</code>) at 5 billion satoshis.</p></div>
<div class="paragraph"><p>Next, the function calculates the number of <code>halvings</code> that have occurred by dividing the current block height by the halving interval (<code>SubsidyHalvingInterval</code>). In the case of block 277,316, with a halving interval every 210,000 blocks, the result is 1 halving.</p></div>
<div class="paragraph"><p>The maximum number of halvings allowed is 64, so the code imposes a zero reward (return only the fees) if the 64 halvings is exceeded.</p></div>
<div class="paragraph"><p>Next, the function uses the binary-right-shift operator to divide the reward (<code>nSubsidy</code>) by 2 for each round of halving. In the case of block 277,316 this would binary-right-shift the reward of 5 billion satoshis once (one halving) and result in 2.5 billion satoshis, or 25 bitcoin. The binary-right-shift operator is used because it is more efficient for division by 2 than integer or floating point division.</p></div>
<div class="paragraph"><p>Finally, the coinbase reward (<code>nSubsidy</code>) is added to the transaction fees (<code>nFees</code>), and the sum is returned.</p></div>
</div>
<div class="sect3">
<h4 id="_structure_of_the_generation_transaction">Structure of the Generation Transaction</h4>
<div class="paragraph"><p>With these calculations, Jing&#8217;s node then constructs the generation transaction to pay himself 25.09094928 bitcoin. The generation transaction is the first transaction in the block, so we can see it in more detail using the Bitcoin Core command-line interface:</p></div>
<div class="paragraph"><p>As you can see in <a href="#generation_tx_example">[generation_tx_example]</a>, the generation transaction has a special format. Instead of a transaction input specifying a previous UTXO to spend, it has a "coinbase" input. We examined transaction inputs in <a href="#tx_in_structure">[tx_in_structure]</a>. Let&#8217;s compare a regular transaction input with a generation transaction input. A regular transaction looks like this:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 23. The structure of a "normal" transaction input</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Transaction Hash</p></td>
<td align="left" valign="top"><p class="table">Pointer to the transaction containing the UTXO to be spent</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Output Index</p></td>
<td align="left" valign="top"><p class="table">The index number of the UTXO to be spent, first one is 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script Size</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script length in bytes, to follow</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script</p></td>
<td align="left" valign="top"><p class="table">A script that fulfills the conditions of the UTXO locking-script.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Sequence Number</p></td>
<td align="left" valign="top"><p class="table">Currently-disabled Tx-replacement feature, set to 0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The generation transaction input, however, looks like this:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 24. The structure of a generation transaction input</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Transaction Hash</p></td>
<td align="left" valign="top"><p class="table">All bits are zero: Not a transaction hash reference</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Output Index</p></td>
<td align="left" valign="top"><p class="table">All bits are ones: 0xFFFFFFFF</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Coinbase Data Size</p></td>
<td align="left" valign="top"><p class="table">Length of the Coinbase Data, from 2 to 100 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Coinbase Data</p></td>
<td align="left" valign="top"><p class="table">Arbitrary Data used for extra nonce and mining tags
In v2 blocks, must begin with block height</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Sequence Number</p></td>
<td align="left" valign="top"><p class="table">Set to 0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>In a generation transaction, the first two fields are set to values that do not represent a UTXO reference. Instead of a "Transaction Hash", the first field is filled with 32 bytes all set to zero. The "Output Index" is filled with 4 bytes all set to 0xFF (255 decimal). The "Unlocking Script" is replaced by coinbase data, an arbitrary data field used by the miners.</p></div>
</div>
<div class="sect3">
<h4 id="_coinbase_data">Coinbase Data</h4>
<div class="paragraph"><p>Generation transactions do not have an unlocking script (a.k.a. scriptSig) field. Instead, this field is replaced by coinbase data, which must be between 2 and 100 bytes. Except for the first few bytes (see below) the rest of the coinbase data can be used by miners in any way they want; it is arbitrary data.</p></div>
<div class="paragraph"><p>In the genesis block, for example, Satoshi Nakamoto added the text "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks" in the coinbase data, using it as a proof of the date and to convey a message. Currently, miners use the coinbase data to include extra nonce values and strings identifying the mining pool, as we will see in the following sections.</p></div>
<div class="paragraph"><p>The first few bytes of the coinbase used to be arbitrary, but that is no longer the case. As per Bitcoin Improvement Proposal 34 (BIP0034), version-2 blocks (blocks with the version field set to 2) must contain the block height index as a script "push" operation in the beginning of the coinbase field.</p></div>
<div class="paragraph"><p>In block 277,316 we see that the coinbase (see <a href="#generation_tx_example">[generation_tx_example]</a>), which is in the "Unlocking Script" or scriptSig field of the transaction input, contains the hexadecimal value <code>03443b0403858402062f503253482f</code>. Let&#8217;s decode this value.</p></div>
<div class="paragraph"><p>The first byte, <code>03</code> instructs the script execution engine to push the next 3 bytes onto the script stack (see <a href="#tx_script_ops_table_pushdata">[tx_script_ops_table_pushdata]</a>). The next 3 bytes, <code>0x443b04</code>, are the block height encoded in little-endian format (backwards, least significant byte first). Reverse the order of the bytes and the result is <code>0x043b44</code> which is 277,316 in decimal.</p></div>
<div class="paragraph"><p>The next few hexadecimal digits (<code>03858402062</code>) are used to encode an extra <em>nonce</em> (See <a href="#extra_nonce_">[extra_nonce_]</a>), or random value, used to find a suitable Proof-of-Work solution.</p></div>
<div class="paragraph"><p>The final part of the coinbase data (<code>2f503253482f</code>) is the ASCII-encoded string "/P2SH/", which indicates that the mining node that mined this block supports the Pay-to-Script-Hash (P2SH) improvement defined in BIP0016. The introduction of the P2SH capability required a "vote" by miners to endorse either BIP0016 or BIP0017. Those endorsing the BIP0016 implementation were to include "/P2SH/" in their coinbase data. Those endorsing the BIP0017 implementation of P2SH were to include the string "p2sh/CHV" in their coinbase data. The BIP0016 was elected as the winner, and many miners continued including the string "/P2SH/" in their coinbase to indicate support for this feature.</p></div>
<div class="paragraph"><p>The code example <a href="#satoshi_words">[satoshi_words]</a> uses the libbitcoin library introduced in <a href="#alt_libraries">[alt_libraries]</a> to extract the coinbase data from the genesis block, displaying Satoshi&#8217;s message. Note that the libbitcoin library contains a static copy of the genesis block, so the example code below can use retrieve the genesis block directly from the library.</p></div>
<div class="exampleblock" id="satoshi_words">
<div class="title">Example 20. Extract the coinbase data from the genesis block</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>We compile the code with the GNU C++ compiler and run the resulting executable:</p></div>
<div class="exampleblock" id="satoshi_words_run">
<div class="title">Example 21. Compiling and running the satoshi-words example code</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_the_block_header">Constructing the Block Header</h3>
<div class="paragraph"><p>To construct the block header, the mining node needs to fill in six fields:</p></div>
<div class="tableblock" id="block_header_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 25. The structure of the block header</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Size</th>
<th align="left" valign="top"> Field </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Version</p></td>
<td align="left" valign="top"><p class="table">A version number to track software/protocol upgrades</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Previous Block Hash</p></td>
<td align="left" valign="top"><p class="table">A reference to the hash of the previous (parent) block in the chain</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Merkle Root</p></td>
<td align="left" valign="top"><p class="table">A hash of the root of the Merkle-Tree of this block&#8217;s transactions</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Timestamp</p></td>
<td align="left" valign="top"><p class="table">The approximate creation time of this block (seconds from Unix Epoch)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Difficulty Target</p></td>
<td align="left" valign="top"><p class="table">The Proof-of-Work algorithm difficulty target for this block</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Nonce</p></td>
<td align="left" valign="top"><p class="table">A counter used for the Proof-of-Work algorithm</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>At the time block 277,316 was mined, the version number describing the block structure is version "2", which is encoded in little-endian format in 4 bytes as <code>0x02000000</code>.</p></div>
<div class="paragraph"><p>Next, the mining node needs to add the "Previous Block Hash". That is the hash of the block header of block 277,315, the previous block received from the network, which Jing&#8217;s node has accepted and selected as the parent of the candidate block 277,316. The block header hash for block 277,315 is <code>0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</code>.</p></div>
<div class="paragraph"><p>The next step is to summarize all the transactions with a Merkle Tree, in order to add the Merkle Root to the block header. The generation transaction is listed as the first transaction in the block. Then, 418 more transactions are added after it, for a total of 419 transactions in the block. As we saw in the <a href="#merkle_trees">[merkle_trees]</a>, there must be an even number of "leaf" nodes in the tree, so the last transaction is duplicated, creating 420 nodes, each containing the hash of one transaction. The transaction hashes are then combined, in pairs, creating each level of the tree, until all the transactions are summarized into one node at the "root" of the tree. The root of the merkle tree summarizes all the transactions into a single 32 byte value <code>c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e</code> which you can see listed as "merkle root" in <a href="#block277316">[block277316]</a></p></div>
<div class="paragraph"><p>The mining node will then add a 4-byte timestamp, encoded as a Unix "Epoch" timestamp, which is based on the number of seconds elapsed from January 1st, 1970, midnight UTC/GMT. The time <code>1388185914</code> is equal to Friday, 27 Dec 2013, 23:11:54 UTC/GMT.</p></div>
<div class="paragraph"><p>The node then fills in the difficulty target, which defines the required Proof-of-Work difficulty to make this a valid block. The difficulty is stored in the block as a "difficulty bits" metric, which is a mantissa-exponent encoding of the target. The encoding has a one-byte exponent, followed by a 3 byte mantissa (coefficient). In block 277,316, for example, the difficulty bits value is <code>0x1903a30c</code>. The first part <code>0x19</code> is a hexadecimal exponent, while the next part <code>0x03a30c</code> is the coefficient. The concept of a difficulty target is explained in <a href="#difficulty_target">[difficulty_target]</a> and the "difficulty bits" representation is explained in <a href="#difficulty_bits">[difficulty_bits]</a>.</p></div>
<div class="paragraph"><p>The final field is the nonce, which is initialized to zero.</p></div>
<div class="paragraph"><p>With all the other fields filled, the block header is now complete and the process of mining can begin. The goal is now to find a value for the nonce that results in a block header hash that is less than the difficulty target. The mining node will need to test billions or trillions of nonce values before a nonce is found that satisfies the requirement.</p></div>
</div>
<div class="sect2">
<h3 id="_mining_the_block">Mining the Block</h3>
<div class="paragraph"><p>Now that a candidate block has been constructed by Jing&#8217;s node, it is time for Jing&#8217;s hardware mining rig to "mine" the block, to find a solution to the Proof-of-Work algorithm that makes the block valid. Throughout this book we have studied cryptographic hash functions as used in various aspects of the bitcoin system. The hash function SHA-256 is the function used in bitcoin&#8217;s mining process.</p></div>
<div class="paragraph"><p>In the simplest terms, mining is the process of hashing the block header repeatedly, changing one parameter, until the resulting hash matches a specific target. The hash function&#8217;s result cannot be determined in advance, nor can a pattern be created that will produce a specific hash value. This feature of hash functions means that the only way to produce a hash result matching a specific target, is to try again and again, randomly modifying the input until the desired hash result appears by chance.</p></div>
<div class="sect3">
<h4 id="_proof_of_work_algorithm">Proof-of-Work Algorithm</h4>
<div class="paragraph"><p>A hash algorithm takes an arbitrary-length data input and produces a fixed-length deterministic result, a digital fingerprint of the input. For any specific input, the resulting hash will always be the same and can be easily calculated and verified by anyone implementing the same hash algorithm. The key characteristic of a cryptographic hash algorithm is that it is virtually impossible to find two different inputs that produce the same fingerprint. As a corollary, it is also virtually impossible to select an input in such a way as to produce a desired fingerprint, other than trying random inputs.</p></div>
<div class="paragraph"><p>With SHA-256, the output is always 256 bits long, regardless of the size of the input. In the example below, we will use the Python interpreter to calculate the SHA256 hash of the phrase "I am Satoshi Nakamoto".</p></div>
<div class="exampleblock" id="sha256_example1">
<div class="title">Example 22. SHA256 Example</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The example shows that if we calculate the hash of the phrase <code>"I am Satoshi Nakamoto"</code>, it will produce <code>5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e</code>. This 256-bit number is the <em>hash</em> or <em>digest</em> of the phrase and depends on every part of the phrase. Adding a single letter, punctuation mark or any character will produce a different hash.</p></div>
<div class="paragraph"><p>Now, if we change the phrase, we will expect to see completely different hashes. Let&#8217;s try that by adding a number to the end of our phrase, using this simple Python script</p></div>
<div class="exampleblock" id="sha256_example_generator">
<div class="title">Example 23. SHA256 A script for generating many hashes by iterating on a nonce</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Running this will produce the hashes of several phrases, made different by adding a number at the end of the text. By incrementing the number, we can get different hashes.</p></div>
<div class="paragraph"><p></p></div>
<div class="exampleblock" id="sha256_example_generator_output">
<div class="title">Example 24. SHA256 Output of a script for generating many hashes by iterating on a nonce</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content">
<pre><code>I am Satoshi Nakamoto0 =&gt; a80a81401765c8eddee25df36728d732...
I am Satoshi Nakamoto1 =&gt; f7bc9a6304a4647bb41241a677b5345f...
I am Satoshi Nakamoto2 =&gt; ea758a8134b115298a1583ffb80ae629...
I am Satoshi Nakamoto3 =&gt; bfa9779618ff072c903d773de30c99bd...
I am Satoshi Nakamoto4 =&gt; bce8564de9a83c18c31944a66bde992f...
I am Satoshi Nakamoto5 =&gt; eb362c3cf3479be0a97a20163589038e...
I am Satoshi Nakamoto6 =&gt; 4a2fd48e3be420d0d28e202360cfbaba...
I am Satoshi Nakamoto7 =&gt; 790b5a1349a5f2b909bf74d0d166b17a...
I am Satoshi Nakamoto8 =&gt; 702c45e5b15aa54b625d68dd947f1597...
I am Satoshi Nakamoto9 =&gt; 7007cf7dd40f5e933cd89fff5b791ff0...
I am Satoshi Nakamoto10 =&gt; c2f38c81992f4614206a21537bd634a...
I am Satoshi Nakamoto11 =&gt; 7045da6ed8a914690f087690e1e8d66...
I am Satoshi Nakamoto12 =&gt; 60f01db30c1a0d4cbce2b4b22e88b9b...
I am Satoshi Nakamoto13 =&gt; 0ebc56d59a34f5082aaef3d66b37a66...
I am Satoshi Nakamoto14 =&gt; 27ead1ca85da66981fd9da01a8c6816...
I am Satoshi Nakamoto15 =&gt; 394809fb809c5f83ce97ab554a2812c...
I am Satoshi Nakamoto16 =&gt; 8fa4992219df33f50834465d3047429...
I am Satoshi Nakamoto17 =&gt; dca9b8b4f8d8e1521fa4eaa46f4f0cd...
I am Satoshi Nakamoto18 =&gt; 9989a401b2a3a318b01e9ca9a22b0f3...
I am Satoshi Nakamoto19 =&gt; cda56022ecb5b67b2bc93a2d764e75f...</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>Each phrase produces a completely different hash result. They seem completely random, but you can re-produce the exact results in this example on any computer with Python and see the same exact hashes.</p></div>
<div class="paragraph"><p>The number used as a variable in such a scenario is called a <em>nonce</em>. The nonce is used to vary the output of a cryptographic function, in this case to vary the SHA-256 fingerprint of the phrase.</p></div>
<div class="paragraph"><p>To make a challenge out of this algorithm, let&#8217;s set an arbitrary target: find a phrase that produces a hexadecimal hash that starts with a zero. Fortunately, this isn&#8217;t so difficult! If you notice above, we can see that the phrase "I am Satoshi Nakamoto13" produces the hash 0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5, which fits our criteria. It took 13 attempts to find it. In terms of probabilities, if the output of the hash function is evenly distributed we would expect to find a result with a 0 as the hexadecimal prefix once every 16 hashes (one out of 16 hexadecimal digits 0 through F). In numerical terms, that means finding a hash value that is less than <code>0x1000000000000000000000000000000000000000000000000000000000000000</code>. We call this threshold the <em>target</em> and the goal is to find a hash that is numerically <em>less than the target</em>. If we decrease the target, the task of finding a hash that is less than the target becomes more and more difficult.</p></div>
<div class="paragraph"><p>To give a simple analogy, imagine a game where players throw a pair of dice repeatedly, trying to throw less than a specified target. In the first round, the target is 12. Unless you throw double-six, you win. In the next round the target is 11. Players must throw 10 or less to win, again an easy task. Let&#8217;s say a few rounds later the target is down to 5. Now, more than half the dice throws will add up to more than 5 and therefore be invalid. It takes exponentially more dice throws to win, the lower the target gets. Eventually, when the target is 2 (the minimum possible), only one throw out of every 36, or 2% of them will produce a winning result.</p></div>
<div class="paragraph"><p>In the hashing example above, the winning "nonce" is 13 and this result can be confirmed by anyone independently. Anyone can add the number 13 as a suffix to the phrase "I am Satoshi Nakamoto" and compute the hash, verifying that it is less than the target. The successful result is also proof-of-work, as it proves we did the work to find that nonce. While it only takes one hash computation to verify, it took us 13 hash computations to find a nonce that worked. If we had a lower target (higher difficulty) it would take many more hash computations to find a suitable nonce, but only one hash computation for anyone to verify. Furthermore, by knowing the target, anyone can estimate the difficulty using statistics and therefore know how much work was needed to find such a nonce.</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s Proof-of-Work is very similar to the problem above. The miner constructs a candidate block filled with transactions. Next, the miner calculates the hash of this block&#8217;s header and see if it is smaller than the current <em>target</em>. If the hash is not less than the target, the miner will modify the nonce (usually just incrementing it by one) and try again. At the current difficulty in the bitcoin network, miners have to try quadrillions of times before finding a nonce that results in a low enough block header hash.</p></div>
<div class="paragraph"><p>A very simplified Proof-of-Work algorithm is implemented in Python here:</p></div>
<div class="exampleblock" id="pow_example1">
<div class="title">Example 25. Simplified Proof-Of-Work Implementation</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Running the code above, you can set the desired difficulty (in bits, how many of the leading bits must be zero) and see how long it takes for your computer to find a solution. In the following examples, you can see how it works on an average laptop:</p></div>
<div class="exampleblock" id="pow_example_outputs">
<div class="title">Example 26. Running the Proof-of-Work example for various difficulties</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content">
<pre><code>Difficulty: 1 (0 bits)

[...]

Difficulty: 8 (3 bits)
Starting search...
Success with nonce 9
Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1
Elapsed Time: 0.0004 seconds
Hashing Power: 25065 hashes per second
Difficulty: 16 (4 bits)
Starting search...
Success with nonce 25
Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148
Elapsed Time: 0.0005 seconds
Hashing Power: 52507 hashes per second
Difficulty: 32 (5 bits)
Starting search...
Success with nonce 36
Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903
Elapsed Time: 0.0006 seconds
Hashing Power: 58164 hashes per second

[...]

Difficulty: 4194304 (22 bits)
Starting search...
Success with nonce 1759164
Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3
Elapsed Time: 13.3201 seconds
Hashing Power: 132068 hashes per second
Difficulty: 8388608 (23 bits)
Starting search...
Success with nonce 14214729
Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3
Elapsed Time: 110.1507 seconds
Hashing Power: 129048 hashes per second
Difficulty: 16777216 (24 bits)
Starting search...
Success with nonce 24586379
Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95
Elapsed Time: 195.2991 seconds
Hashing Power: 125890 hashes per second

[...]

Difficulty: 67108864 (26 bits)
Starting search...
Success with nonce 84561291
Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a
Elapsed Time: 665.0949 seconds
Hashing Power: 127141 hashes per second</code></pre>
</div></div>
</div></div>
<div class="paragraph"><p>As you can see, increasing the difficulty by 1 bit causes an exponential increase in the time it takes to find a solution. If you think of the entire 256-bit number space, each time you constrain one more bit to zero, you decrease the search space by half. In the example above, it takes 84 million hash attempts to find a nonce that produces a hash with 26 leading bits as zero. Even at a speed of more than 120 thousand hashes per second, it still requires ten minutes on a consumer laptop to find this solution.</p></div>
<div class="paragraph"><p>At the time of writing this, the network is attempting to find a block whose header hash is less than <code>000000000000004c296e6376db3a241271f43fd3f5de7ba18986e517a243baa7</code>. As you can see, there are a lot of zeroes at the beginning of that hash, meaning that the acceptable range of hashes is much smaller, hence more difficult to find a valid hash. It will take on average more than 150 quadrillion hash calculations per second for the network to discover the next block. That seems like an impossible task, but fortunately the network is bringing 100 Peta Hashes per second of processing power to bear, which will be able to find a block in about 10 minutes on average.</p></div>
</div>
<div class="sect3">
<h4 id="difficulty_bits">Difficulty Representation</h4>
<div class="paragraph"><p>In <a href="#block277316">[block277316]</a> we saw that the block contains the difficulty target, in a notation called "difficulty bits" or just "bits", which in block 277,316 has the value of <code>0x1903a30c</code>. This notation expresses the difficulty target as a coefficient/exponent format, with the first two hexadecimal digits for the exponent and the next six hex digits as the coefficient. In this block, therefore, the exponent is <code>0x19</code> and the coefficient is <code>0x03a30c</code>.</p></div>
<div class="paragraph"><p>The formula to calculate the difficulty target from this representation is:</p></div>
<div class="paragraph"><p>target = coefficient * 2^(8 * (exponent - 3))</p></div>
<div class="paragraph"><p>Using that formula, and the difficulty bits value 0x1903a30c, we get:</p></div>
<div class="paragraph"><p>target = 0x03a30c * 2<sup>(0x08 * (0x19 - 0x03))</sup></p></div>
<div class="paragraph"><p>&#8658; target = 0x03a30c * 2<sup>(0x08 * 0x16)</sup></p></div>
<div class="paragraph"><p>&#8658; target = 0x03a30c * 2<sup>0xB0</sup></p></div>
<div class="paragraph"><p>which in decimal is:</p></div>
<div class="paragraph"><p>&#8658; target = 238,348 * 2<sup>176</sup></p></div>
<div class="paragraph"><p>&#8658; target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</p></div>
<div class="paragraph"><p>switching back to hexadecimal:</p></div>
<div class="paragraph"><p>&#8658; target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</p></div>
<div class="paragraph"><p>This means that a valid block for height 277,316 is one that has a block header hash that is less than the target. In binary that number would have more than the first 60 bits set to zero. With this level of difficulty, a single miner processing 1 trillion hashes per second (1 tera-hash per second or 1 TH/sec) would only find a solution once every 8,496 blocks or once every 59 days, on average.</p></div>
</div>
<div class="sect3">
<h4 id="difficulty_target">Difficulty Target and Re-Targeting</h4>
<div class="paragraph"><p>As we saw above the target determines the difficulty and therefore affects how long it takes to find a solution to the Proof-of-Work algorithm. This leads to the obvious questions: Why is the difficulty adjustable, who adjusts it and how?</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s blocks are generated every 10 minutes, on average. This is bitcoin&#8217;s heartbeat and underpins the frequency of currency issuance and the speed of transaction settlement. It has to remain constant not just over the short term, but over a period of many decades. Over this time, it is expected that computer power will continue to increase at a rapid pace. Furthermore, the number of participants in mining and the computers they use will also constantly change. To keep the block generation time at 10 minutes, the difficulty of mining must be adjusted to account for these changes. In fact, difficulty is a dynamic parameter that will be periodically adjusted to meet a 10-minute block target. In simple terms, the difficulty target is set to whatever mining power will result in a 10-minute block interval.</p></div>
<div class="paragraph"><p>How then is such an adjustment made in a completely de-centralized network? Difficulty re-targeting occurs automatically and on every full node independently. Every 2016 blocks, all nodes re-target the Proof-of-Work difficulty. The equation for retargeting difficulty measures the time it took to find the last 2016 blocks and compares that to the expected time of 20160 minutes (two weeks based upon a desired 10 minute block time). The ratio between the actual timespan and desired timespan is calculated and a corresponding adjustment (up or down) is made to the difficulty. In simple terms: If the network is finding blocks faster than every 10 minutes, the difficulty increases. If block discovery is slower than expected, the difficulty decreases.</p></div>
<div class="paragraph"><p>The equation can be summarized as:</p></div>
<div class="paragraph"><p>New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)</p></div>
<div class="paragraph"><p>Here&#8217;s the code used in the Bitcoin Core client</p></div>
<div class="exampleblock" id="retarget_difficulty_code">
<div class="title">Example 27. Re-targeting the Proof-of-Work difficulty - <code>GetNextWorkRequired()</code> in <code>pow.cpp</code>, line 43</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>The parameters Interval (2016 blocks) and TargetTimespan (two weeks as 1,209,600 seconds) are defined in <code>chainparams.cpp</code></p></div>
<div class="paragraph"><p>To avoid extreme volatility in the difficulty, the retargeting adjustment must be less than a factor of four (4) per cycle. If the required difficulty adjustment is greater than a factor of four, it will be adjusted by the maximum and not more. Any further adjustment will be accomplished in the next retargeting period as the imbalance will persist through the next 2016 blocks. Therefore, large discrepancies between hashing power and difficulty may take several 2016 block cycles to balance out.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>The difficulty of finding a bitcoin block is approximately <em>10 minutes of processing</em> for the entire network, based on the time it took to find the previous 2016 blocks, adjusted every 2016 blocks.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Note that the target difficulty is independent of the number of transactions or the value of transactions. This means that the amount of hashing power and therefore electricity expended to secure bitcoin is also entirely independent of the number of transactions. Bitcoin can scale up, achieve broader adoption and remain secure without any increase in hashing power from today&#8217;s level. The increase in hashing power represents market forces as new miners enter the market to compete for the reward. As long as enough hashing power is under the control of miners acting honestly in pursuit of the reward, it is enough to prevent "takeover" attacks and therefore it is enough to secure bitcoin.</p></div>
<div class="paragraph"><p>The target difficulty is closely related to the cost of electricity and the exchange rate of bitcoin vis-a-vis the currency used to pay for electricity. High performance mining systems are about as efficient as possible with the current generation of silicon fabrication, converting electricity into hashing computation at the highest rate possible. The primary influence on the mining market is the price of one kilowatt-hour in bitcoin, as that determines the profitability of mining and therefore the incentives to enter or exit the mining market.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_successfully_mining_the_block">Successfully Mining the Block</h3>
<div class="paragraph"><p>As we saw earlier, Jing&#8217;s node has constructed a candidate block and prepared it for mining. Jing has several hardware mining rigs with Application Specific Integrated Circuits, where hundreds of thousands of integrated circuits run the SHA-256 algorithm in parallel at incredible speeds. These specialized machines are connected to his mining node over USB. Next, the mining node running on Jing&#8217;s desktop transmits the block header to his mining hardware, which start testing trillions of nonces per second.</p></div>
<div class="paragraph"><p>Almost eleven minutes after starting to mine block 277,316, one of the hardware mining machines finds a solution and sends it back to the mining node. The nonce 4,215,469,401 when inserted into the block header produces a block hash of <code>0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569</code>, which is less than the target of <code>0000000000000003A30C00000000000000000000000000000000000000000000</code>.</p></div>
<div class="paragraph"><p>Immediately, Jing&#8217;s mining node transmits the block to all its peers. They receive, validate and then propagate the new block. As the block ripples out across the network, each node adds it to its own copy of the blockchain, extending it to a new height of 277,316 blocks. As mining nodes receive and validate the block, they abandon their efforts to find a block at the same height and immediately start computing the next block in the chain.</p></div>
<div class="paragraph"><p>In the next section we&#8217;ll look at the process each node uses to validate a block and select the longest chain, creating the consensus that forms the de-centralized blockchain.</p></div>
</div>
<div class="sect2">
<h3 id="_validating_a_new_block">Validating a New Block</h3>
<div class="paragraph"><p>The third step in bitcoin&#8217;s consensus mechanism is independent validation of each new block by every node on the network. As the newly solved block moves across the network, each node performs a series of tests to validate it before propagating it to its peers. This ensures that only valid blocks are propagated on the network. The independent validation also ensures that miners who act honestly get their blocks incorporated in the blockchain, thus earning the reward. Those miners who act dishonestly have their blocks rejected and not only lose the reward but also waste the effort expended to find a Proof-of-Work solution, thus incurring the cost of electricity without compensation.</p></div>
<div class="paragraph"><p>When a node receives a new block, it will validate the block by checking it against a long list of criteria that must all be met; otherwise the block is rejected. These criteria can be seen in the Bitcoin Core client in the functions <code>CheckBlock</code> and <code>CheckBlockHeader</code> and include:</p></div>
<div class="ulist"><ul>
<li>
<p>
The block data structure is syntactically valid
</p>
</li>
<li>
<p>
The block header hash is less than the target difficulty (enforces the Proof-of-Work)
</p>
</li>
<li>
<p>
The block timestamp is less than two hours in the future (allowing for time errors)
</p>
</li>
<li>
<p>
The block size is within acceptable limits
</p>
</li>
<li>
<p>
The first transaction (and only the first) is a coinbase generation transaction
</p>
</li>
<li>
<p>
All transactions within the block are valid using the transaction checklist discussed in <a href="#tx_verification">[tx_verification]</a>
</p>
</li>
</ul></div>
<div class="paragraph"><p>The independent validation of each new block by every node on the network ensures that the miners can&#8217;t cheat. In previous sections we saw how the miners get to write a transaction that awards them the new bitcoins created within the block and claim the transaction fees. Why doesn&#8217;t the miner write themselves a transaction for a thousand bitcoin instead of the correct reward? Because every node validates blocks according to the same rules. An invalid coinbase transaction would make the entire block invalid, which would result in the block being rejected and therefore that transaction would never become part of the ledger. The miner has to construct a perfect block, based on the shared rules that all nodes follow and mine it with a correct solution to the Proof-of-Work. To do so they expend a lot of electricity in mining and if they cheat all the electricity and effort is wasted. This is why independent validation is a key component of decentralized consensus.</p></div>
</div>
<div class="sect2">
<h3 id="_assembling_and_selecting_chains_of_blocks">Assembling and Selecting Chains of Blocks</h3>
<div class="paragraph"><p>The final step in bitcoin&#8217;s de-centralized consensus mechanism is the assembly of blocks into chains and the selection of the chain with the most Proof-of-Work. Once a node has validated a new block, it will then attempt to assemble a chain, by connecting the block to the existing blockchain.</p></div>
<div class="paragraph"><p>Nodes maintain three sets of blocks: those connected to the main blockchain, those that form branches off the main blockchain (secondary chains) and finally blocks that do not have a known parent in the known chains (orphans). Invalid blocks are rejected as soon as any one of the validation criteria fails and are therefore not included in any chain.</p></div>
<div class="paragraph"><p>The "main chain" at any time is whichever chain of blocks has the most cumulative difficulty associated with it. Under most circumstances this is also the chain with the most blocks in it, unless there are two equal length chains and one has more proof-of-work. The main chain will also have branches with blocks that are "siblings" to the blocks on the main chain. These blocks are valid but not part of the main chain. They are kept for future reference, in case one of those chains is extended to exceed the main chain in difficulty. In the next section (<a href="#forks">[forks]</a>), we will see how secondary chains occur as a result of an almost simultaneous mining of blocks at the same height.</p></div>
<div class="paragraph"><p>When a new block is received, a node will try to slot it into the existing blockchain. The node will look at the block&#8217;s "previous block hash" field, which is the reference to the new block&#8217;s parent. Then, the node will attempt to find that parent in the existing blockchain. Most of the time, the parent will be the "tip" of the main chain, meaning this new block extends the main chain. For example, the new block 277,316 has a reference to the hash of its parent block 277,315. Most nodes that receive 277,316 will already have block 277,315 as the tip of their main chain and will therefore link the new block and extend that chain.</p></div>
<div class="paragraph"><p>Sometimes, as we will see in <a href="#forks">[forks]</a>, the new block extends a chain that is not the main chain. In that case, the node will attach the new block to the secondary chain it extends and then compare the difficulty of the secondary chain to the main chain. If the secondary chain has more cumulative difficulty than the main chain, the node will <em>reconverge</em> on the secondary chain, meaning it will select the secondary chain as its new main chain, making the old main chain a secondary chain. If the node is a miner, it will now construct a block extending this new, longer, chain.</p></div>
<div class="paragraph"><p>If a valid block is received and no parent is found in the existing chains, then that block is considered an "orphan". Orphan blocks are saved in the orphan block pool where they will stay until their parent is received. Once the parent is received and linked into the existing chains, the orphan can be pulled out of the orphan pool and linked to the parent, making it part of a chain. Orphan blocks usually occur when two blocks that were mined within a short time of each other are received in reverse order (child before parent).</p></div>
<div class="paragraph"><p>By selecting the greatest-difficulty chain, all nodes eventually achieve network-wide consensus. Temporary discrepancies between chains are resolved eventually as more Proof-of-Work is added, extending one of the possible chains. Mining nodes "vote" with their mining power by choosing which chain to extend by mining the next block. When they mine a new block and extend the chain, the new block itself represents their vote.</p></div>
<div class="paragraph"><p>In the next section we will look at how discrepancies between competing chains (forks) are resolved by the independent selection of the longest difficulty chain.</p></div>
<div class="sect3">
<h4 id="forks">Blockchain Forks</h4>
<div class="paragraph"><p>Because the blockchain is a decentralized data structure, different copies of it are not always consistent. Blocks may arrive at different nodes at different times, causing the nodes to have different perspectives of the blockchain. To resolve this, each node always selects and attempts to extend the chain of blocks that represents the most Proof-of-Work, also known as the longest chain or greatest cumulative difficulty chain. By summing the difficulty recorded in each block in a chain, a node can calculate the total amount of Proof-of-Work that has been expended to create that chain. As long as all nodes select the longest cumulative difficulty chain, the global bitcoin network eventually converges to a consistent state. Forks occur as temporary inconsistencies between versions of the blockchain, which are resolved by eventual re-convergence as more blocks are added to one of the forks.</p></div>
<div class="paragraph"><p>In the next few diagrams, we follow the progress of a "fork" event across the network. The diagram is a simplified representation of bitcoin as a global network. In reality, the bitcoin network&#8217;s topology is not organized geographically. Rather, it forms a mesh network of interconnected nodes, which may be located very far from each other geographically. The representation of a geographic topology is a simplification used for the purposes of illustrating a fork. In the real bitcoin network, the "distance" between nodes is measured in "hops" from node to node, not in terms of their physical location. For illustration purposes, different blocks are shown as different colors, spreading across the network and coloring the connections they traverse.</p></div>
<div class="paragraph"><p>In the first diagram below, the network has a unified perspective of the blockchain, with the blue block as the tip of the main chain.</p></div>
<div class="imageblock" id="fork1">
<div class="content">
<img src="images/GlobalFork1.png" alt="globalfork1" />
</div>
<div class="title">Figure 57. Visualization of a blockchain fork event - Before the Fork</div>
</div>
<div class="paragraph"><p>A "fork" occurs whenever there are two candidate blocks competing to form the longest blockchain. This occurs under normal conditions whenever two miners solve the Proof-of-Work algorithm within a short period of time from each other. As both miners discover a solution for their respective candidate blocks, they immediately broadcast their own "winning" block to their immediate neighbors who begin propagating the block across the network. Each node that receives a valid block will incorporate it into their blockchain, extending the blockchain by one block. If that node later sees another candidate block extending the same parent, they connect the second candidate on a secondary chain. As a result, some nodes will "see" one candidate block first, while other nodes will see the other candidate block and two competing versions of the blockchain will emerge.</p></div>
<div class="paragraph"><p>In the diagram below, we see two miners who mine two different blocks almost simultaneously. Both of these blocks are children of the blue block, meant to extend the chain by building on top of the blue block. To help us track it, one is visualized as a red block originating from Canada, and the other is marked as a green block originating from Australia.</p></div>
<div class="imageblock" id="fork2">
<div class="content">
<img src="images/GlobalFork2.png" alt="globalfork2" />
</div>
<div class="title">Figure 58. Visualization of a blockchain fork event - Two blocks found simultaneously</div>
</div>
<div class="paragraph"><p>Let&#8217;s assume for example that a miner in Canada finds a Proof-of-Work solution for a block "red" that extends the blockchain, building on top of the parent block "blue". Almost simultaneously, an Australian miner who was also extending block "blue", finds a solution for block "green", their candidate block. Now, there are two possible blocks, one we call "red", originating in Canada and one we call "green", originating in Australia. Both blocks are valid, both blocks contain a valid solution to the proof of work, both blocks extend the same parent. Both blocks likely contain most of the same transactions, with only perhaps a few differences in the order of transactions.</p></div>
<div class="paragraph"><p>As the two blocks propagate, some nodes receive block "red" first and some receive block "green" first. The network splits into two different perspectives of the blockchain, one side topped with a red block, the other with a green block.</p></div>
<div class="imageblock" id="fork2">
<div class="content">
<img src="images/GlobalFork3.png" alt="globalfork3" />
</div>
<div class="title">Figure 59. Visualization of a blockchain fork event - Two blocks propagate, splitting the network</div>
</div>
<div class="paragraph"><p>From that moment, the bitcoin network nodes closest (topologically, not geographically) to the Canadian node will hear about block "red" first and will create a new greatest-cumulative-difficulty blockchain with "red" as the last block in the chain (e.g. blue-red), ignoring the candidate block "green" that arrives a bit later. Meanwhile, nodes closer to the Australian node will take that block as the winner and extend the blockchain with "green" as the last block (e.g. blue-green), ignoring "red" when it arrives a few seconds later. Any miners that saw "red" first will immediately build candidate blocks that reference "red" as the parent and start trying to solve the PoW for these candidate blocks. The miners that accepted "green" instead, will start building on top of "green" and extending that chain.</p></div>
<div class="imageblock" id="fork4">
<div class="content">
<img src="images/GlobalFork4.png" alt="globalfork4" />
</div>
<div class="title">Figure 60. Visualization of a blockchain fork event - A new block extends one fork</div>
</div>
<div class="paragraph"><p>Forks are almost always resolved within one block. As part of the network&#8217;s hashing power is dedicated to building on top of "red" as the parent, another part of the hashing power is focused on building on top of "green". Even if the hashing power is almost evenly split, it is likely that one set of miners will find a solution and propagate it before the other set of miners have found any solutions. Let&#8217;s say for example that the miners building on top of "green" find a new block "pink" that extends the chain (e.g. blue-green-pink). They immediately propagate this new block and the entire network sees it as a valid solution.</p></div>
<div class="imageblock" id="fork5">
<div class="content">
<img src="images/GlobalFork5.png" alt="globalfork5" />
</div>
<div class="title">Figure 61. Visualization of a blockchain fork event - The network re-converges on a new longest chain</div>
</div>
<div class="paragraph"><p>All nodes that had chosen "green" as the winner in the previous round will simply extend the chain one more block. The nodes that chose "red" as the winner, however, will now see two chains: blue-green-pink and blue-red. The chain blue-green-pink is now longer (more cumulative difficulty) than the chain blue-red. As a result, those nodes will set the chain blue-green-pink as main chain and change the blue-red chain to being a secondary chain. This is a chain re-convergence, as those nodes are forced to revise their view of the blockchain to incorporate the new evidence of a longer chain. Any miners working on extending the chain blue-red will now stop that work because their candidate block is an "orphan", as its parent "red" is no longer on the longest chain. The transactions within "red" are queued up again for processing in the next block, as that block is no longer in the main chain. The entire network re-converges on a single blockchain blue-green-pink, with "pink" as the last block in the chain. All miners immediately start working on candidate blocks that reference "pink" as their parent to extend the blue-green-pink chain.</p></div>
<div class="paragraph"><p>It is theoretically possible for a fork to extend to two blocks, if two blocks are found almost simultaneously by miners on opposite "sides" of a previous fork. However, the chance of that happening is very low. Whereas a one-block fork may occur every week, a two-block fork is exceedingly rare.</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s block interval of 10 minutes is a design compromise between fast confirmation times (settlement of transactions) and the probability of a fork. A faster block time would make transactions clear faster but lead to more frequent blockchain forks, whereas a slower block time would decrease the number of forks but make settlement slower.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_mining_and_the_hashing_race">Mining and the Hashing Race</h3>
<div class="paragraph"><p>Bitcoin mining is an extremely competitive industry. The hashing power has increased exponentially, every year of bitcoin&#8217;s existence. Some years the growth has reflected a complete change of technology, such as in 2010 and 2011 when many miners switched from using CPU mining to Graphical Processing Unit (GPU) mining and Field Programmable Gate Array (FPGA) mining. In 2013 the introduction of Application Specific Integrated Circuit (ASIC) mining lead to another giant leap in mining power, by placing the SHA-256 function directly on silicon chips specialized for the purpose of mining. The first such chips could deliver more mining power in a single box than the entire bitcoin network in 2010.</p></div>
<div class="ulist"><ul>
<li>
<p>
2009 - 0.5 MH/sec to 8 MH/sec (x 16 growth)
</p>
</li>
<li>
<p>
2010 - 8 MH/sec to 116 GH/sec (x 14,500 growth)
</p>
</li>
<li>
<p>
2011 - 16 GH/sec - 9 TH/sec (x 562 growth)
</p>
</li>
<li>
<p>
2012 - 9 TH/sec - 23 TH/sec (x 2.5 growth)
</p>
</li>
<li>
<p>
2013 - 23 TH/sec - 10 PH/sec (x 450 growth)
</p>
</li>
<li>
<p>
2014 - 10 PH/sec - 150 PH/sec in August (x 15 growth)
</p>
</li>
</ul></div>
<div class="paragraph"><p>In the chart below, we see the bitcoin network&#8217;s hashing power increase over the past two years. As you can see, the competition between miners and the growth of bitcoin has resulted in an exponential increase in the hashing power (total hashes per second across the network):</p></div>
<div class="imageblock" id="network_hashing_power">
<div class="content">
<img src="images/NetworkHashingRate.png" alt="NetworkHashingRate" />
</div>
<div class="title">Figure 62. Total hashing power, giga-hashes per second, over two years</div>
</div>
<div class="paragraph"><p>As the amount of hashing power applied to mining bitcoin has exploded, the difficulty has risen to match it. The difficulty metric in the following chart is measured as a ratio of current difficulty over minimum difficulty (the difficulty of the first block):</p></div>
<div class="imageblock" id="bitcoin_difficulty">
<div class="content">
<img src="images/BitcoinDifficulty.png" alt="BitcoinDifficulty" />
</div>
<div class="title">Figure 63. Bitcoin&#8217;s mining difficulty metric, over two years</div>
</div>
<div class="paragraph"><p>In the last two years, the ASIC mining chips have become denser and denser, approaching the cutting edge of silicon fabrication with a feature size (resolution) of 22 nanometers (nm). Currently, ASIC manufacturers are aiming to overtake general purpose CPU chip manufacturers, designing chips with a feature size of 16nm, because the profitability of mining is driving this industry even faster than general computing. There are no more giant leaps left in bitcoin mining, because the industry has reached the forefront of "Moore&#8217;s Law". Still, the mining power of the network continues to advance at an exponential pace as the race for higher density chips is matched with a race for higher density data centers where thousands of these chips can be deployed. It&#8217;s no longer about how much mining can be done with one chip but how many chips can be squeezed into a building, while still dissipating the heat and providing adequate power.</p></div>
<div class="sect3">
<h4 id="extra_nonce">The Extra Nonce Solution</h4>
<div class="paragraph"><p>Since 2012 bitcoin mining has evolved to resolve a fundamental limitation in the structure of the block header. In the early days of bitcoin, a miner could find a block by iterating through the nonce until the resulting hash was below the target. As difficulty increased, miners often cycled through all 4 billion values of the nonce without finding a block. However, this was easily resolved by updating the block timestamp to account for the elapsed time. Since the timestamp is part of the header, the change would allow miners to iterate through the values of the nonce again with different results.  Once mining hardware exceeded 4 GH/sec however, this approach became increasingly difficult as the nonce values were exhausted in less than a second. As ASIC mining equipment started pushing and then exceeding the TH/sec hash rate, the mining software needed more space for nonce values in order to find valid blocks. The timestamp could be stretched a bit, but moving it too far into the future would cause the block to become invalid. A new source of "change" was needed in the block header. The solution was to use the coinbase transaction as a source of extra nonce values. Since the coinbase script can store between 2 and 100 bytes of data, miners started using that space as extra nonce space, allowing them to explore a much larger range of block header values to find valid blocks. The coinbase transaction is included in the merkle tree, which means that any change in the coinbase script causes the merkle root to change. Eight bytes of extra nonce, plus the 4 bytes of "standard" nonce allow miners to explore a total 2<sup>96</sup> (8 followed by 28 zeroes) possibilities <strong>per second</strong> without having to modify the timestamp. If, in the future, a miner could run through all these possibilities, they could then modify the timestamp. There is also more space in the coinbase script for future expansion of the extra nonce space.</p></div>
</div>
<div class="sect3">
<h4 id="mining_pools">Mining Pools</h4>
<div class="paragraph"><p>In this highly competitive environment, individual miners working alone (also known as solo miners) don&#8217;t stand a chance. The likelihood of them finding a block to offset their electricity and hardware costs is so low that it represents a gamble, like playing the lottery. Even the fastest consumer ASIC mining system cannot keep up with commercial systems that stack tens of thousands of these chips in giant warehouses near hydro-electric power stations. Miners now collaborate to form mining pools, pooling their hashing power and sharing the reward among thousands of participants. By participating in a pool, miners get a smaller share of the overall reward, but typically get rewarded every day, reducing uncertainty.</p></div>
<div class="paragraph"><p>Let&#8217;s look at a specific example. Assume a miner has purchased mining hardware with a combined hashing rate of 6,000 giga-hashes per second (GH/s) or 6 TH/s. In August of 2014 this equipment costs approximately $10,000 USD. The hardware also consumes 3 kilowatts (kW) of electricity when running, 72 kW-hours a day, at a cost of $7 or $8 per day on average. At current bitcoin difficulty, the miner will be able to solo-mine a block approximately once every 155 days, or every 5 months. If the miner does find a single block in that timeframe, the payout of 25 bitcoin, at approximately $600 per bitcoin will result in a single payout of $15,000 which will cover the entire cost of the hardware and the electricity consumed over the time period, leaving a net profit of approximately $3,000. However, the chance of finding a block in a 5-month period depends on the miner&#8217;s luck. They might find two blocks in 5 months and make a very large profit. Or they might not find a block for 10 months and suffer a financial loss. Even worse, the difficulty of the bitcoin proof-of-work algorithm is likely to go up significantly over that period, at the current rate of growth of hashing power, meaning the miner has at most 6 months to break-even before the hardware is effectively obsolete and must be replaced by more powerful mining hardware. If this miner participates in a mining pool, instead of waiting for a once-in-5-month $15,000 windfall, they will be able to earn approximately $500 to $750 per week. The regular payouts from a mining pool will help them amortize the cost of hardware and electricity over time without taking an enormous risk. The hardware will still be obsolete in 6-9 months and the risk is still high, but the revenue is at least regular and reliable over that period.</p></div>
<div class="paragraph"><p>Mining pools coordinate many hundreds or thousands of miners, over specialized pool mining protocols. The individual miners configure their mining equipment to connect to a pool server, after creating an account with the pool. Their mining hardware remains connected to the pool server while mining, synchronizing their efforts with the other miners. Thus, the pool miners share the effort to mine a block and then share in the rewards.</p></div>
<div class="paragraph"><p>Successful blocks pay the reward to a pool bitcoin address, rather than individual miners. The pool server will periodically make payments to the miners' bitcoin addresses, once their share of the rewards has reached a certain threshold. Typically, the pool server charges a percentage fee of the rewards for providing the pool mining service.</p></div>
<div class="paragraph"><p>Miners participating in a pool, split the work of searching for a solution to a candidate block, earning "shares" for their mining contribution. The mining pool sets a lower difficulty target for earning a share, typically more than 1,000 times easier than the bitcoin network&#8217;s difficulty. When someone in the pool successfully mines a block, the reward is earned by the pool and then shared with all miners in proportion to the number of shares they contributed to the effort.</p></div>
<div class="paragraph"><p>Pools are open to any miner, big or small, professional or amateur. A pool will therefore have some participants with a single small mining machine, others with a garage-full of high-end mining hardware. Some will be mining with a few tens of a kilowatt of electricity, others will be running a data center consuming a megawatt of power. How does a mining pool measure the individual contributions, so as to fairly distribute the rewards, without the possibility of cheating? The answer is to use bitcoin&#8217;s Proof-of-Work algorithm to measure each pool miner&#8217;s contribution, but set at a lower difficulty so that even the smallest pool miners win a share frequently enough to make it worthwhile to contribute to the pool. By setting a lower difficulty for earning shares, the pool measures the amount of work done by each miner. Each time a pool miner finds a block header hash that is less than the pool difficulty, they prove they have done the hashing work to find that result. More importantly, the work to find shares contributes, in a statistically measurable way, to the overall effort to find a hash lower than the bitcoin network&#8217;s target. Thousands of miners trying to find low-value hashes will eventually find one low enough to satisfy the bitcoin network target.</p></div>
<div class="paragraph"><p>Let&#8217;s return to the analogy of a dice game. If the dice players are throwing dice with a goal of throwing less than four (the overall network difficulty), a pool would set an easier target, counting how many times the pool players managed to throw less than eight. When a pool player throws less than eight (the pool share target), they earn shares, but they don&#8217;t win the game because they don&#8217;t achieve the game target (less than four). The pool players will achieve the easier pool target much more often, earning them shares very regularly, even when they don&#8217;t achieve the harder target of winning the game. Every now and then, one of the pool players will throw a combined dice throw of less than four and the pool wins. Then, the earnings can be distributed to the pool players based on the shares they earned. Even though the target of eight-or-less wasn&#8217;t winning, it was a fair way to measure dice throws for the players and occasionally produces a less-than-four throw.</p></div>
<div class="paragraph"><p>Similarly, a mining pool will set a pool difficulty that will ensure that an individual pool miner can find block header hashes that are less than the pool difficulty quite often, earning shares. Every now and then, one of these attempts will produce a block header hash that is less than the bitcoin network target, making it a valid block and the whole pool wins.</p></div>
<div class="sect4">
<h5 id="_managed_pools">Managed Pools</h5>
<div class="paragraph"><p>Most mining pools are "managed", meaning that there is a company or individual running a pool server. The owner of the pool server is called the <em>pool operator</em> and they charge pool miners a percentage fee of the earnings.</p></div>
<div class="paragraph"><p>The pool server runs specialized software and a pool-mining protocol that coordinates the activities of the pool miners. The pool server is also connected to one or more full bitcoin nodes and has direct access to a full copy of the blockchain database. This allows the pool server to validate blocks and transactions on behalf of the pool miners, relieving them of the burden of running a full node. For pool miners, this is an important consideration, as a full node requires a dedicated computer with at least 15-20 gigabytes of persistent storage (disk) and at least 2 gigabytes of memory (RAM). Furthermore, the bitcoin software running on the full node needs to be monitored, maintained and upgraded frequently. Any downtime caused by a lack of maintenance or lack of resources will impact the miner&#8217;s profitability. For many miners the ability to mine without running a full node is another big benefit of joining a managed pool.</p></div>
<div class="paragraph"><p>Pool miners connect to the pool server using a mining protocol such as Stratum (STM) or GetBlockTemplate (GBT). An older standard called GetWork (GWK) is now mostly obsolete since late 2012, as it does not easily support mining at hash rates above 4 GH/s. Both the STM and GBT protocols create block <em>templates</em> that contain a template of a candidate block header. The pool server constructs a candidate block by aggregating transactions, adding a coinbase transaction (with extra nonce space), calculating the merkle root and linking to the previous block hash. The header of the candidate block is then sent to each of the pool miners as a template. Each pool miner then mines using the block template, at a lower difficulty than the bitcoin network difficulty and sends any successful results back to the pool server to earn shares.</p></div>
</div>
<div class="sect4">
<h5 id="_p2pool">P2Pool</h5>
<div class="paragraph"><p>Managed pools create the possibility of cheating by the pool operator, who might direct the pool effort to double-spend transactions or invalidate blocks (see <a href="#51pct">[51pct]</a>). Furthermore, centralized pool servers represent a single-point-of-failure. If the pool server is down or is attacked by Denial-of-Service, the pool miners cannot mine. In 2011, to resolve these issues of centralization, a new pool mining method was proposed and implemented: P2Pool is a peer-to-peer mining pool, without a central operator.</p></div>
<div class="paragraph"><p>P2Pool works by de-centralizing the functions of the pool server, implementing a parallel blockchain-like system called a <em>sharechain</em>. A sharechain is a blockchain running at a lower difficulty than the bitcoin blockchain. The sharechain allows pool miners to collaborate in a de-centralized pool, by mining shares on the sharechain at a rate of one share block every 30 seconds. Each of the blocks on the sharechain records a proportionate share reward for the pool miners who contribute work, carrying the shares forward from the previous share block. When one of the share blocks also achieves the difficulty target of the bitcoin network it is propagated and included on the bitcoin blockchain, rewarding all the pool miners who contributed to the all the shares that preceded the winning share block. Essentially, instead of a pool server keeping track of pool miner shares and rewards, the sharechain allows all pool miners to keep track of all shares using a de-centralized consensus mechanism like bitcoin&#8217;s blockchain consensus mechanism.</p></div>
<div class="paragraph"><p>P2Pool mining is more complex than pool mining, as it requires that the pool miners run a dedicated computer with enough disk space, memory and internet bandwidth to support a full bitcoin node and the p2pool node software. P2Pool miners connect their mining hardware to their local p2pool node, which simulates the functions of a pool server by sending block templates to the mining hardware. On P2Pool, individual pool miners construct their own candidate blocks, aggregating transactions much like solo-miners but then mine collaboratively on the sharechain. P2Pool is a hybrid approach that has the advantage of much more granular payouts than solo mining, but without giving too much control to a pool operator like managed pools.</p></div>
<div class="paragraph"><p>Recently, participation in P2Pool has increased significantly as mining concentration in mining pools has approached levels that create concerns of a 51% attack (see <a href="#51pct">[51pct]</a>). Further development of the P2Pool protocol continues with the expectation of removing the need for running a full node and therefore making de-centralized mining even easier to use.</p></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="consensus_attacks">Consensus Attacks</h3>
<div class="paragraph"><p>Bitcoin&#8217;s consensus mechanism is, at least theoretically, vulnerable to attack by miners (or pools) that attempt to use their hashing power to dishonest or destructive ends. As we saw, the consensus mechanism depends on having a majority of the miners acting honestly out of self-interest. However, if a miner or group of miners can achieve a significant share of the mining power, they can attack the consensus mechanism so as to disrupt the security and availability of the bitcoin network.</p></div>
<div class="paragraph"><p>It is important to note that consensus attacks can only affect future consensus, or at best the most recent past (tens of blocks). Bitcoin&#8217;s ledger becomes more and more immutable as time passes. Beyond a certain "depth", blocks are absolutely immutable, even under a sustained consensus attack that causes a fork. Consensus attacks also do not affect the security of the private keys and signing algorithm (ECDSA). A consensus attack cannot steal bitcoins, spend bitcoins without signatures, redirect bitcoins or otherwise change past transactions or ownership records. Consensus attacks can only affect the most recent blocks and cause denial-of-service disruptions on the creation of future blocks.</p></div>
<div class="paragraph"><p>One attack scenario against the consensus mechanism is called the "51% attack". In this scenario a group of miners, controlling a majority (51%) of the total network&#8217;s hashing power, collude to attack bitcoin. With the ability to mine the majority of the blocks, the attacking miners can cause deliberate "forks" in the blockchain and double-spend transactions or execute denial-of-service attacks against specific transactions or addresses. A fork/double-spend attack is one where the attacker causes previously confirmed blocks to be invalidated by forking below them and re-converging on an alternate chain. With sufficient power, an attacker can invalidate six or more blocks in a row, causing transactions that were considered immutable (6 confirmations) to be invalidated. Note that a double-spend can only be done on the attacker&#8217;s own transactions, for which the attacker can produce a valid signature. Double-spending one&#8217;s own transactions is profitable if by invalidating a transaction the attacker can get a non-reversible exchange payment or product without paying for it.</p></div>
<div class="paragraph"><p>Let&#8217;s examine a practical example of a 51% attack. In the first chapter we looked at a transaction between Alice and Bob for a cup of coffee. Bob, the cafe owner, is willing to accept payment for cups of coffee without waiting for confirmation (mining in a block), because the risk of a double-spend on a cup of coffee is low in comparison to the convenience of rapid customer service. This is similar to the practice of coffee shops that accept credit card payments without a signature for amounts below $25, as the risk of a credit-card chargeback is low while the cost of delaying the transaction to obtain a signature is comparatively larger. In contrast, selling a more expensive item for bitcoin runs the risk of a double-spend attack, where the buyer broadcasts a competing transaction that spends the same inputs (UTXO) and cancels the payment to the merchant. A double-spend attack can happen in two ways: either before a transaction is confirmed, or if the attacker takes advantage of a blockchain fork to undo several blocks. A 51% attack allows an attacker to double-spend their own transactions in the new chain, thus undoing the corresponding transaction in the old chain.</p></div>
<div class="paragraph"><p>In our example, malicious attacker Mallory goes to Carol&#8217;s gallery and purchases a beautiful triptych painting depicting Satoshi Nakamoto as Prometheus. Carol sells "The Great Fire" paintings for $250,000 in bitcoin, to Mallory. Instead of waiting for six or more confirmations on the transaction, Carol wraps and hands the paintings to Mallory after only one confirmation. Mallory works with an accomplice, Paul, who operates a large mining pool and the accomplice launches a 51% attack as soon as Mallory&#8217;s transaction is included in a block. Paul directs the mining pool to re-mine the same block height as the block containing Mallory&#8217;s transaction replacing Mallory&#8217;s payment to Carol with a transaction that double-spends the same input as Mallory&#8217;s payment. The double-spend transaction consumes the same UTXO and pays it back to Mallory&#8217;s wallet, instead of paying it to Carol, essentially allowing Mallory to keep the bitcoin. Paul then directs the mining pool to mine an additional block, so as to make the chain containing the double-spend transaction longer than the original chain (causing a fork below the block containing Mallory&#8217;s transaction). When the blockchain fork resolves in favor of the new (longer) chain, the double-spent transaction replaces the original payment to Carol. Carol is now missing the three paintings and also has no bitcoin payment. Throughout all this activity, Paul&#8217;s mining pool participants may remain blissfully unaware of the double-spend attempt, as they mine with automated miners and cannot monitor every transaction or block.</p></div>
<div class="paragraph"><p>To protect against this kind of attack, a merchant selling large-value items must wait at least six confirmations before giving the product to the buyer. Alternatively, the merchant should use an escrow multi-signature account, again waiting for several confirmations after the escrow account is funded. The more confirmations elapse, the harder it becomes to invalidate a transaction with a 51% attack. For large-value items, payment by bitcoin will still be convenient and efficient even if the buyer has to wait 24 hours for delivery, which would ensure 144 confirmations.</p></div>
<div class="paragraph"><p>In addition to a double-spend attack, the other scenario for a consensus attack is to deny service to specific bitcoin participants (specific bitcoin addresses). An attacker with a majority of the mining power can simply ignore specific transactions. If they are included in a block mined by another miner the attacker can deliberately fork and re-mine that block, again excluding the specific transactions. This type of attack can result in a sustained denial of service against a specific address or set of addresses for as long as the attacker controls the majority of the mining power.</p></div>
<div class="paragraph"><p>Despite its name, the 51% attack scenario doesn&#8217;t actually require 51% of the hashing power. In fact, such an attack can be attempted with a smaller percentage of the hashing power. The 51% threshold is simply the level at which such an attack is almost guaranteed to succeed. A consensus attack is essentially a tug-of-war for the next block and the "stronger" group is more likely to win. With less hashing power, the probability of success is reduced, as other miners control the generation of some blocks with their "honest" mining power. One way to look at it is that the more hashing power an attacker has, the longer the fork they can deliberately create, the more blocks in the recent past they can invalidate, or the more blocks in the future they can control. Security research groups have used statistical modeling to claim that various types of consensus attacks are possible with as little as 30% of the hashing power.</p></div>
<div class="paragraph"><p>The massive increase of total hashing power has arguably made bitcoin impervious to attacks by a single miner. There is no possible way for a solo miner to control even 1% of the total mining power. However, the centralization of control caused by mining pools has introduced the risk of for-profit attack by a mining pool operator. The pool operator in a managed pool controls the construction of candidate blocks and also controls which transactions are included. This gives the pool operator the power to exclude transactions or introduce double-spend transactions. If such abuse of power is done in a limited and subtle way, a pool operator could conceivably profit from a consensus attack without being noticed.</p></div>
<div class="paragraph"><p>Not all attackers will be motivated by profit, however. One potential attack scenario is where an attacker intends to disrupt the bitcoin network without the possibility of profiting from such disruption. A malicious attack aimed at crippling bitcoin would require enormous investment and covert planning, but could conceivably be launched by a well funded, most likely state-sponsored attacker. Alternatively, a well-funded attacker could attack bitcoin&#8217;s consensus by simultaneously amassing mining hardware, compromising pool operators and attacking other pools with denial-of-service. All of these scenarios are theoretically possible, but increasingly impractical as the bitcoin network&#8217;s overall hashing power continues to grow exponentially. Recent advancements in bitcoin, such as P2Pool mining, aim to further de-centralize mining control, making bitcoin consensus even harder to attack.</p></div>
<div class="paragraph"><p>Undoubtedly, a serious consensus attack would erode confidence in bitcoin in the short term, possibly causing a significant price decline. However, the bitcoin network and software is constantly evolving, so consensus attacks would be met with immediate counter-measures by the bitcoin community, making bitcoin hardier, stealthier, and more robust.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ch9">Alternative Chains, Currencies, and Applications</h2>
<div class="sectionbody">
<div class="paragraph"><p>Bitcoin was the result of twenty years of research in distributed systems and currencies and brought a revolutionary new technology into the space: the de-centralized consensus mechanism based on Proof-of-Work. This invention at the heart of bitcoin has ushered a wave of innovation in currencies, financial services, economics, distributed systems, voting systems, corporate governance, and contracts.</p></div>
<div class="paragraph"><p>In this chapter we&#8217;ll examine the many offshoots of the bitcoin and blockchain inventions, the alternative chains, currencies, and applications built since the introduction of this technology in 2009. Mostly, we will look at <em>alt-coins</em>, which are digital currencies implemented using the same design pattern as bitcoin, but with a completely separate blockchain and network.</p></div>
<div class="paragraph"><p>For every alt-coin mentioned in this chapter, 50 or more will go unmentioned, eliciting howls of anger from their creators and fans. The purpose of this chapter is not to evaluate or qualify alt-coins, or to mention the most "significant" ones based on some subjective assessment. Instead, we will highlight a few examples that show the breadth and variety of the ecosystem, noting the first-of-a-kind for each innovation or significant differentiation. Some of the most interesting examples of alt-coins are in fact complete failures from a monetary perspective. That perhaps makes them even more interesting for study and highlights the fact that this chapter is not to be used as an investment guide.</p></div>
<div class="paragraph"><p>With new coins introduced every day, it would be impossible not to miss some important coin, perhaps the one that changes history. The rate of innovation is what makes this space so exciting and guarantees this chapter will be incomplete and out-of-date as soon as it is published.</p></div>
<div class="sect2">
<h3 id="_a_taxonomy_of_alternative_currencies_and_chains">A taxonomy of alternative currencies and chains</h3>
<div class="paragraph"><p>Bitcoin is an open source project, and its code has been used as the basis for many other software projects. The most common form of software spawned from bitcoin&#8217;s source code are alternative de-centralized currencies, or <em>alt-coins</em>, which use the same basic building blocks to implement digital currencies.</p></div>
<div class="paragraph"><p>There are a number of protocol layers implemented on top of bitcoin&#8217;s blockchain. These <em>meta-coins</em>, <em>meta-chains</em>, or <em>blockchain apps</em> use the blockchain as an application platform or extend the bitcoin protocol by adding protocol layers. Examples include Colored Coins, Mastercoin, and Counterparty.</p></div>
<div class="paragraph"><p>In the next section we will examine a few notable alt-coins, such as Litecoin, Dogecoin, Freicoin, Primecoin, Peercoin, Darkcoin, and Zerocoin. These alt-coins are notable for historical reasons or because they are good examples for a specific type of alt-coin innovation, not because they are the most valuable or "best" alt-coins.</p></div>
<div class="paragraph"><p>In addition to the alt-coins, there are also a number of alternative blockchain implementations that are not really "coins", which I call <em>alt-chains</em>. These alt-chains implement a consensus algorithm and distributed ledger as a platform for contracts, name registration, or other applications. Alt-chains use the same basic building blocks and sometimes also use a currency or token as a payment mechanism, but their primary purpose is not currency. We will look at Namecoin, Ethereum, and NXT as examples of alt-chains.</p></div>
<div class="paragraph"><p>In addition to the Proof-of-Work consensus mechanism used in bitcoin, alternatives include experimental protocols based on Proof-of-Resource and Proof-of-Publishing. We will examine Maidsafe and Twister as examples of these consensus mechanisms.</p></div>
<div class="paragraph"><p>Finally, there are a number of bitcoin contenders that offer digital currency or digital payment networks, but without using a de-centralized ledger or consensus mechanism based on Proof-of-Work, such as Ripple and others. These non-blockchain technologies are outside of the scope of this book and will not be covered in this chapter.</p></div>
</div>
<div class="sect2">
<h3 id="_meta_coin_platforms">Meta-Coin Platforms</h3>
<div class="paragraph"><p>Meta-coins and meta-chains are software layers implemented on top of bitcoin, either implementing a currency-inside-a-currency, or a platform/protocol overlay inside the bitcoin system. These function layers extend the core bitcoin protocol and add features and capabilities by encoding additional data inside bitcoin transactions and bitcoin addresses. The first implementations of meta-coins used various "hacks" to add meta-data to the bitcoin blockchain, such as using bitcoin addresses to encode data or using unused transaction fields (e.g. the transaction sequence field) to encode meta-data about the added protocol layer. Since the introduction of the OP_RETURN transaction scripting opcode, the meta-coins have been able to record meta-data more directly in the blockchain, and most are migrating to using that instead.</p></div>
<div class="sect3">
<h4 id="_colored_coins">Colored Coins</h4>
<div class="paragraph"><p>Colored Coins is a meta-protocol that overlays information on small amounts of bitcoin. A "colored" coin is an amount of bitcoin repurposed to express another asset. Imagine for example taking a $1 USD note and putting a stamp on it that said "This is a 1 share certificate of Acme Inc.". Now the $1 serves two purposes: it is a currency note and also a share certificate. Because it is more valuable as a share, you would not want to use it to buy candy, so effectively it is no longer useful as currency. Colored coins work in the same way by converting a specific, very small, amount of bitcoin into a traded certificate that represents another asset. The term "color" refers to the idea of giving special meaning through the addition of an attribute such as a color - it is a metaphor not an actual color association. There are no colors in colored coins.</p></div>
<div class="paragraph"><p>Colored coins are managed by specialized "wallets" that record and interpret the metadata attached to the "colored" bitcoins. Using such a wallet, the user will convert an amount of bitcoins from uncolored currency, into colored coins, by adding a label that has a special meaning. For example, a label could represent stock certificates, coupons, real property, commodities, collectible tokens, etc. It is entirely up to the users of colored coins to assign and interpret the meaning of the "color" associated with specific coins. To color the coins, the user defines the associated metadata, such as the type of issuance, whether it can be subdivided into smaller units, a symbol and description, and other related information. Once colored, these coins can be bought and sold, subdivided, aggregated and receive dividend payments. The colored coins can also be "uncolored" by removing the special association and redeem them for their face-value in bitcoin.</p></div>
<div class="paragraph"><p>To demonstrate the use of colored coins, we have created a set of 20 colored coins with symbol "MasterBTC" that represent coupons for a free copy of this book. Each unit of MasterBTC, represented by these colored coins, can now be sold or given to any bitcoin user with a colored-coin-capable wallet, who can then transfer them to others or redeem them with the issuer for a free copy of the book. This example of colored coins can be seen here: <a href="https://cpr.sm/FoykwrH6UY">https://cpr.sm/FoykwrH6UY</a></p></div>
<div class="exampleblock">
<div class="title">Example 28. The metadata profile of the colored coins recorded as a coupon for a free copy of the book</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_mastercoin">Mastercoin</h4>
<div class="paragraph"><p>Mastercoin is a protocol layer on top of bitcoin that supports a platform for various applications extending the bitcoin system. Mastercoin uses the currency MST as a token for conducting Mastercoin transactions but it is not primarily a currency. Rather it is a platform for building other things, such as user currencies, smart property tokens, de-centralized asset exchanges, contracts, etc. Think of Mastercoin as an application-layer protocol on top of bitcoin&#8217;s financial transaction transport-layer, just like HTTP runs on top of TCP.</p></div>
<div class="paragraph"><p>Mastercoin operates primarily through transactions sent to and from a special bitcoin address called the "exodus" address (<code>1EXoDusjGwvnjZUyKkxZ4UHEf77z6A5S4P</code>), just like HTTP uses a specific TCP port (port 80) to differentiate its traffic from the rest of the TCP traffic. The Mastercoin protocol is gradually transitioning from using the specialized exodus address and multi-signatures to using the OP_RETURN bitcoin operator to encode transaction metadata.</p></div>
</div>
<div class="sect3">
<h4 id="_counterparty">Counterparty</h4>
<div class="paragraph"><p>Counterparty is another protocol layer implemented on top of bitcoin. Counterparty enables user currencies, tradable tokens, financial instruments, de-centralized asset exchanges, and other features. Counterparty is implemented primarily using the OP_RETURN operator in bitcoin&#8217;s scripting language to record metadata enhancing bitcoin transactions with additional meaning. Counterparty uses the currency XCP as a token for conducting Counterparty transactions.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_alt_coins">Alt-coins</h3>
<div class="paragraph"><p>The vast majority of alt-coins are derived from bitcoin&#8217;s source code, also known as "forks". Some are implemented "from scratch" based on the blockchain model but without using any of bitcoin&#8217;s source code. Alt-coins and alt-chains (in the next section) are both separate implementations of blockchain technology and both forms use their own blockchain. The difference in the terms is to indicate that alt-coins are primarily used as currency, whereas alt-chains are used for other purposes, not primarily currency.</p></div>
<div class="paragraph"><p>The first alt-coins appeared in August of 2011 as forks of the bitcoin source code. Strictly speaking, the first major fork of bitcoin&#8217;s code was not an alt-coin but the alt-chain <em>Namecoin</em>, which will be discussed in the next section.</p></div>
<div class="paragraph"><p>Based on the date of announcement, the first alt-coin appears to be <em>IXCoin</em>, launched in August of 2011. IXCoin modified a few of the bitcoin parameters, specifically accelerating the creation of currency by increasing the reward to 96 coins per block.</p></div>
<div class="paragraph"><p>In September of 2011, <em>Tenebrix</em> was launched. Tenebrix was the first crypto-currency to implement an alternative Proof-of-Work algorithm, namely <em>scrypt</em>, an algorithm originally designed for password stretching (brute-force resistance). The stated goal of Tenebrix was to make a coin that was resistant to mining with GPUs and ASICs, by using a memory-intensive algorithm. Tenebrix did not succeed as a currency, but it was the basis for Litecoin, which has enjoyed great success and has spawned hundreds of clones.</p></div>
<div class="paragraph"><p><em>Litecoin</em>, in addition to using scrypt as the Proof-of-Work algorithm, also implemented a faster block generation time, targeted at 2.5 minutes instead of bitcoin&#8217;s 10 minutes. The resulting currency is touted as "silver to bitcoin&#8217;s gold" and is intended as a light-weight alternative currency. Due to the faster confirmation time and the 84 million total currency limit, many adherents of Litecoin believe it is better suited for retail transactions than bitcoin.</p></div>
<div class="paragraph"><p>Alt-coins continued to proliferate in 2011 and 2012, either based on bitcoin or on Litecoin. In the beginning of 2013 there were 20 alt-coins vying for position in the market. By the end of 2013 however, this number had exploded to 200, with 2013 quickly becoming the "year of the alt-coins". The growth of alt-coins continued in 2014 with more than 500 alt-coins now in existence. More than half the alt-coins today are clones of Litecoin.</p></div>
<div class="paragraph"><p>Creating an alt-coin is easy, which is why there are now more than 500 of them. Most of the alt-coins differ very slightly from bitcoin and do not offer anything worth studying. Many are in fact just attempts to enrich their creators. Among the copycats and pump-and-dump schemes, there are however some notable exceptions and very important innovations. These alt-coins take radically different approaches or add significant innovation to bitcoin&#8217;s design pattern. There are three primary areas where alt-coins differentiate from bitcoin:</p></div>
<div class="ulist"><ul>
<li>
<p>
Different monetary policy
</p>
</li>
<li>
<p>
Different Proof-of-Work or consensus mechanism
</p>
</li>
<li>
<p>
Specific features, such as strong anonymity
</p>
</li>
</ul></div>
<div class="paragraph"><p>A graphical timeline of alt-coins and alt-chains can be found at <a href="http://mapofcoins.com">http://mapofcoins.com</a>.</p></div>
<div class="sect3">
<h4 id="_evaluating_an_alt_coin">Evaluating an alt-coin</h4>
<div class="paragraph"><p>With so many alt-coins out there, how does one decide which ones are worthy of attention? Some alt-coins attempt to achieve broad distribution and use as currencies. Others are laboratories for experimenting on different features and monetary models. Many are just get-rich-quick schemes by their creators. To evaluate alt-coins I look at their defining characteristics and their market metrics.</p></div>
<div class="paragraph"><p>Here are some questions to ask about how well an alt-coin differentiates from bitcoin:</p></div>
<div class="ulist"><ul>
<li>
<p>
Is the alt-coin introducing a significant innovation?
</p>
</li>
<li>
<p>
Does the alt-coin differentiate sufficiently from bitcoin?
</p>
</li>
<li>
<p>
Is the difference compelling enough to attract users away from bitcoin?
</p>
</li>
<li>
<p>
Does the alt-coin address an interesting niche market or application?
</p>
</li>
<li>
<p>
Can the alt-coin attract enough miners to be secured against consensus attacks?
</p>
</li>
</ul></div>
<div class="paragraph"><p>Here are some of the key financial and market metrics to examine:</p></div>
<div class="ulist"><ul>
<li>
<p>
What is the total market capitalization of alt-coin?
</p>
</li>
<li>
<p>
How many estimated users/wallets does the alt-coin have?
</p>
</li>
<li>
<p>
How many merchants accept the alt-coin?
</p>
</li>
<li>
<p>
How many transactions (volume) are executed on the alt-coin?
</p>
</li>
<li>
<p>
How much value is transacted daily?
</p>
</li>
</ul></div>
<div class="paragraph"><p>In this chapter we will concentrate primarily on the technical characteristics and innovation potential of alt-coins, focusing on the first set of questions.</p></div>
</div>
<div class="sect3">
<h4 id="_monetary_parameter_alternatives_litecoin_dogecoin_freicoin">Monetary Parameter Alternatives: Litecoin, Dogecoin, Freicoin</h4>
<div class="paragraph"><p>Bitcoin has a few monetary parameters that give it distinctive characteristics of a deflationary fixed-issuance currency. It is limited to 21 million major currency units (or 21 quadrillion minor units), has a geometrically declining issuance rate and a 10-minute block "heartbeat" which controls the speed of transaction confirmation and currency generation. Many alt-coins have tweaked the primary parameters to achieve different monetary policies. Among the hundreds of alt-coins, some of the most notable examples include:</p></div>
<div class="paragraph"><p><strong>Litecoin</strong></p></div>
<div class="paragraph"><p>One of the first alt-coins, released in 2011, Litecoin is the second most successful digital currency after bitcoin. Its primary innovations were the use of <em>scrypt</em> as the Proof-of-Work algorithm (inherited from Tenebrix) and the faster/lighter currency parameters.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation time: 2.5 minutes
</p>
</li>
<li>
<p>
Total currency: 84 million coins by 2140
</p>
</li>
<li>
<p>
Consensus Algorithm: scrypt Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $160 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Dogecoin</strong></p></div>
<div class="paragraph"><p>Dogecoin was released in December of 2013, based on a fork of Litecoin. Dogecoin is notable because it has a monetary policy of rapid issuance and a very high currency cap, to encourage spending and tipping. Dogecoin is also notable because it was started as a joke but became quite popular, with a large and active community, before declining rapidly in 2014.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation time: 60 seconds
</p>
</li>
<li>
<p>
Total currency: 100,000,000,000 (100 billion) Doge by 2015
</p>
</li>
<li>
<p>
Consensus algorithm: scrypt Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $12 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Freicoin</strong></p></div>
<div class="paragraph"><p>Freicoin was introduced in July 2012. It is a <em>demurrage currency</em>, meaning that it has a negative interest rate for stored value. Value stored in Freicoin is assessed a 4.5% APR fee, to encourage consumption and discourage hoarding of money. Freicoin is notable in that it implements a monetary policy that is the exact opposite of Bitcoin&#8217;s deflationary policy. Freicoin has not seen success as a currency, but is an interesting example of the variety of monetary policies that can be expressed by alt-coins.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 10 minutes
</p>
</li>
<li>
<p>
Total currency: 100 million coins by 2140
</p>
</li>
<li>
<p>
Consensus algorithm: SHA256 Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $130,000 USD in mid-2014
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_consensus_innovation_peercoin_myriad_blackcoin_vericoin_nxt">Consensus Innovation: Peercoin, Myriad, Blackcoin, Vericoin, NXT</h4>
<div class="paragraph"><p>Bitcoin&#8217;s consensus mechanism is based on Proof-of-Work using the SHA256 algorithm. The first alt-coins introduced scrypt as an alternative Proof-of-Work algorithms, as a way to make mining more CPU-friendly and less susceptible to centralization with ASICs. Since then, innovation in the consensus mechanism has continued at a frenetic pace. Several alt-coins adopted a variety of algorithms such as scrypt, scrypt-N, Skein, Groestl, SHA3, X11, Blake, and others. Some alt-coins combined multiple algorithms for Proof-of-Work. In 2013 we saw the invention of an alternative to Proof-of-Work, called <em>Proof-of-Stake</em>, which forms the basis of many modern alt-coins.</p></div>
<div class="paragraph"><p>Proof-of-Stake is a system by which existing owners of a currency can "stake" currency as interest-bearing collateral. Somewhat like a Certificate of Deposit (CD), participants can reserve a portion of their currency holdings, while earning an investment return in the form of new currency (issued as interest payments) and transaction fees.</p></div>
<div class="paragraph"><p><strong>Peercoin</strong></p></div>
<div class="paragraph"><p>Peercoin was introduced in August of 2012 and is the first alt-coin to use a hybrid Proof-of-Work and Proof-of-Stake algorithm for issuance of new currency.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 10 minutes
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: (Hybrid) Proof-of-Stake with initial Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $14 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Myriad</strong></p></div>
<div class="paragraph"><p>Myriad was introduced in February 2014 and is notable because it uses five different Proof-of-Work algorithms (SHA256d, Scrypt, Qubit, Skein or Myriad-Groestl) simultaneously, with difficulty varying for each algorithm depending on miner participation. The intent is to make Myriad immune to ASIC specialization and centralization as well as much more resistant to consensus attacks, as multiple mining algorithms would have to be attacked simultaneously.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 30 second average (2.5 minutes target per mining algorithm)
</p>
</li>
<li>
<p>
Total currency: 2 billion by 2024
</p>
</li>
<li>
<p>
Consensus algorithm: Multi-Algorithm Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $120,000 USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Blackcoin</strong></p></div>
<div class="paragraph"><p>Blackcoin was introduced in February 2014 and uses a Proof-of-Stake consensus algorithm. It is also notable for the introduction of "multipools", a type of mining pool that can switch between different alt-coins automatically, depending on profitability.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 1 minute
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Stake
</p>
</li>
<li>
<p>
Market capitalization: $3.7 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>VeriCoin</strong></p></div>
<div class="paragraph"><p>VeriCoin was launched in May 2014. It uses a Proof-of-Stake consensus algorithm with a variable interest rate that dynamically adjusts based on market forces of supply and demand.  It also is the first alt-coin featuring auto-exchange to Bitcoin for payment in Bitcoin from the wallet.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 1 minute
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Stake
</p>
</li>
<li>
<p>
Market capitalization: $1.1 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>NXT</strong></p></div>
<div class="paragraph"><p>NXT (pronounced "Next") is a "pure" Proof-of-Stake alt-coin, in that it does not use Proof-of-Work mining. NXT is a from-scratch implementation of a crypto-currency, not a fork of bitcoin or any other alt-coins. NXT implements many advanced features, such as a name registry (similar to Namecoin), a de-centralized asset exchange (similar to Colored Coins), integrated de-centralized and secure messaging (similar to Bitmessage) and stake delegation (delegate Proof-of-Stake to others). NXT adherents call it a "next-generation" or 2.0 crypto-currency.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 1 minute
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Stake
</p>
</li>
<li>
<p>
Market capitalization: $30 million USD in mid-2014
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_dual_purpose_mining_innovation_primecoin_curecoin_gridcoin">Dual-Purpose Mining Innovation: Primecoin, Curecoin, Gridcoin</h4>
<div class="paragraph"><p>Bitcoin&#8217;s Proof-of-Work algorithm has only one purpose: securing the bitcoin network. Compared to traditional payment system security, the cost of mining is not very high. However, it has been criticized by many as being “wasteful". The next set of alt-coins attempt to address this concern. Dual-purpose Proof-of-Work algorithms solve a specific "useful" problem, while producing Proof-of-Work to secure the network. The risk of adding an external use to the currency&#8217;s security is that it also adds external influence to the supply/demand curve.</p></div>
<div class="paragraph"><p><strong>Primecoin</strong></p></div>
<div class="paragraph"><p>Primecoin was announced in July 2013. Its Proof-of-Work algorithm searches for prime numbers, computing Cunningham and bi-twin prime chains. Prime numbers are useful in a variety of scientific disciplines. The Primecoin blockchain contains the discovered prime numbers, thereby producing a public record of scientific discovery in parallel to the public ledger of transactions.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 1 minute
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Work with prime number chain discovery
</p>
</li>
<li>
<p>
Market capitalization: $1.3 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Curecoin</strong></p></div>
<div class="paragraph"><p>Curecoin was announced in May 2013. It combines a SHA256 Proof-of-Work algorithm with protein folding research through the <a href="mailto:Folding@Home">Folding@Home</a> project. Protein folding is a computationally intensive simulation of biochemical interactions of proteins, used to discover new drug targets for curing diseases.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 10 minutes
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Work with protein folding research
</p>
</li>
<li>
<p>
Market capitalization: $58,000 USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Gridcoin</strong></p></div>
<div class="paragraph"><p>Gridcoin was introduced in October 2013. It supplements scrypt-based Proof-of-Work with subsidies for participation in BOINC open grid-computing. BOINC is an open protocol for scientific research grid-computing, which allows participants to share their spare computing cycles for a broad range of academic research computing. Gridcoin uses BOINC as a general purpose computing platform, rather than to solve specific science problems such as prime numbers or protein folding.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 150 seconds
</p>
</li>
<li>
<p>
Total currency: No limit
</p>
</li>
<li>
<p>
Consensus algorithm: Proof-of-Work with BOINC grid-computing subsidy
</p>
</li>
<li>
<p>
Market capitalization: $122,000 USD in mid-2014
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="_anonymity_focused_alt_coins_cryptonote_bytecoin_monero_zerocash_zerocoin_darkcoin">Anonymity-Focused Alt-Coins: CryptoNote, Bytecoin, Monero, Zerocash/Zerocoin, Darkcoin</h4>
<div class="paragraph"><p>Bitcoin is often mistakenly characterized as "anonymous" currency. In fact, it is relatively easy to connect identities to bitcoin addresses and, using big-data analytics, connect addresses to each other to form a comprehensive picture of someone&#8217;s bitcoin spending habits. Several alt-coins aim to address this issue directly by focusing on strong anonymity. The first such attempt is most likely <em>Zerocoin</em>, a meta-coin protocol for preserving anonymity on top of bitcoin, introduced with a paper in the 2013 IEEE Symposium on Security and Privacy. Zerocoin will be implemented as a completely separate alt-coin called Zerocash, currently in development. An alternative approach to anonymity was launched with <em>CryptoNote</em> in a paper published in October 2013. CryptoNote is a foundational technology that is implemented by a number of alt-coin forks discussed below. In addition to Zerocash and Cryptonotes, there are several other independent anonymous coins, such as Darkcoin that use stealth addresses or transaction re-mixing to deliver anonymity.</p></div>
<div class="paragraph"><p><strong>Zerocoin/Zerocash</strong></p></div>
<div class="paragraph"><p>Zerocoin is a theoretical approach to digital currency anonymity introduced in 2013 by researchers at Johns Hopkins. Zerocash is an alt-coin implementation of Zerocoin that is in development and not yet released.</p></div>
<div class="paragraph"><p><strong>CryptoNote</strong></p></div>
<div class="paragraph"><p>CryptoNote is a reference implementation alt-coin that provides the basis for anonymous digital cash that was introduced in October 2013. It is designed to be "forked" into different implementations and has a built-in periodic reset mechanism that makes it unusable as a currency itself. Several alt-coins have been spawned from CryptoNote, including Bytecoin (BCN), Aeon (AEON), Boolberry (BBR), duckNote (DUCK), Fantomcoin (FCN), Monero (XMR), MonetaVerde (MCN) and Quazarcoin (QCN). CryptoNote is also notable for being a complete ground-up implementation of a crypto-currency, not a fork of bitcoin.</p></div>
<div class="paragraph"><p><strong>Bytecoin</strong></p></div>
<div class="paragraph"><p>Bytecoin was the first implementation spawned from CryptoNote, offering a viable anonymous currency based on the CryptoNote technology. Bytecoin was launched in July of 2012. Note that there was a previous alt-coin named Bytecoin with currency symbol BTE, whereas the CryptoNote-derived Bytecoin has currency symbol BCN.  Bytecoin uses the Cryptonight Proof-of-Work algorithm which requires access to at least 2 MB of RAM per instance, making it unsuitable for GPU or ASIC mining. Bytecoin inherits ring-signatures, unlinkable transactions and blockchain-analysis resistant anonymity from CryptoNote.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 2 minutes
</p>
</li>
<li>
<p>
Total currency: 184 billion BCN
</p>
</li>
<li>
<p>
Consensus algorithm: Cryptonight Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $3 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Monero</strong></p></div>
<div class="paragraph"><p>Monero is another implementation of CryptoNote. It has a slightly flatter issuance curve than Bytecoin, issuing 80% of the currency in the first 4 years. It offers the same anonymity features inherited from CryptoNote.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 1 minute
</p>
</li>
<li>
<p>
Total currency: 18.4 million XMR
</p>
</li>
<li>
<p>
Consensus algorithm: Cryptonight Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $5 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Darkcoin</strong></p></div>
<div class="paragraph"><p>Darkcoin was launched in January of 2014. Darkcoin implements anonymous currency using a re-mixing protocol for all transactions called DarkSend. Darkcoin is also notable for using 11 rounds of different hash functions (blake, bmw, groestl, jh, keccak, skein, luffa, cubehash, shavite, simd, echo) for the Proof-of-Work algorithm.</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 2.5 minutes
</p>
</li>
<li>
<p>
Total currency: maximum 22 million DRK
</p>
</li>
<li>
<p>
Consensus algorithm: Multi-algorithm Multi-round Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $19 million USD in mid-2014
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="_non_currency_alt_chains">Non-currency alt-chains</h3>
<div class="paragraph"><p>Alt-chains are alternative implementations of the blockchain design pattern, which are not primarily used as currency. Many include a currency, but the currency is used as a token for allocating something else, such as a resource or a contract. The currency, in other words, is not the main "point" of the platform, it is a secondary feature.</p></div>
<div class="sect3">
<h4 id="_namecoin">Namecoin</h4>
<div class="paragraph"><p>Namecoin was the first "fork" of the bitcoin code. Namecoin is a de-centralized key-value registration and transfer platform using a blockchain. It supports a global domain name registry similar to the domain-name registration system on the Internet. Namecoin is currently used as an alternative Domain Name Service (DNS) for the root-level domain <code>.bit</code>. Namecoin can also be used to register names and key-value pairs in other namespaces, for storing things like email addresses, encryption keys, SSL certificates, file signatures, voting systems, stock certificates and a myriad of other applications.</p></div>
<div class="paragraph"><p>The Namecoin system includes the namecoin currency (symbol NMC), which is used to pay transaction fees for registration and transfer of names. At current prices, the fee to register a name is 0.01 NMC or approximately 1 US cent. As in bitcoin, the fees are collected by Namecoin miners.</p></div>
<div class="paragraph"><p>Namecoin&#8217;s basic parameters are the same as bitcoin&#8217;s:</p></div>
<div class="ulist"><ul>
<li>
<p>
Block generation: 10 minutes
</p>
</li>
<li>
<p>
Total currency: 21 million NMC by 2140
</p>
</li>
<li>
<p>
Consensus algorithm: SHA256 Proof-of-Work
</p>
</li>
<li>
<p>
Market capitalization: $10 million USD in mid-2014
</p>
</li>
</ul></div>
<div class="paragraph"><p>Namecoin&#8217;s namespaces are not restricted, and anyone can use any namespace in any way. However, certain namespaces have an agreed upon specification so that when it is read from the blockchain, software knows how to read and proceed from there. If it is malformed, then whatever software you used to read from the specific namespace will throw an error. Some of the popular namespaces are:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>d/</code> is the domain-name namespace for <code>.bit</code> domains
</p>
</li>
<li>
<p>
<code>id/</code> is the namespace for storing person identifiers such as email addresses, PGP keys etc.
</p>
</li>
<li>
<p>
<code>u/</code> is an additional, more structured specification to store identities (based on openspecs).
</p>
</li>
</ul></div>
<div class="paragraph"><p>The Namecoin client is very similar to Bitcoin Core, as it is derived from the same source code. Upon installation, the client will download a full copy of the namecoin blockchain and then will be ready to query and register names. There are three main commands:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>name_new</code>: Query or pre-register a name
</p>
</li>
<li>
<p>
<code>name_firstupdate</code>: Register a name and make the registration public
</p>
</li>
<li>
<p>
<code>name_update</code>: Change the details or refresh a name registration
</p>
</li>
</ul></div>
<div class="paragraph"><p>For example, to register the domain <code>mastering-bitcoin.bit</code>, we use the command <code>name_new</code> as follows:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>The <code>name_new</code> command registers a claim on the name, by creating a hash of the name with a random key. The two strings returned by <code>name_new</code> are the hash and the random key (<code>a05555e0fc56c023</code> in the example above) that can be used to make the name registration public.  Once that claim has been recorded on the namecoin blockchain it can be converted to a public registration with the <code>name_firstupdate</code> command, by supplying the random key:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ namecoind name_firstupdate d/mastering-bitcoin a05555e0fc56c023 "{"map": {"www": {"ip":"1.2.3.4"}}}}"
b7a2e59c0a26e5e2664948946ebeca1260985c2f616ba579e6bc7f35ec234b01</code></pre>
</div></div>
<div class="paragraph"><p>The example above will map the domain name <code>www.mastering-bitcoin.bit</code> to IP address 1.2.3.4. The hash returned is the transaction id that can be used to track this registration. You can see what names are registered to you by running the <code>name_list</code> command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ namecoind name_list</code></pre>
</div></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Namecoin registrations need to be updated every 36,000 blocks (approximately 200 to 250 days). The <code>name_update</code> command has no fee and therefore renewing domains in Namecoin is free. Third party providers can handle registration, automatic renewal and updating via a web interface, for a small fee. With a third-party provider you avoid the need to run a namecoin client, but you lose the independent control of a de-centralized name registry offered by Namecoin.</p></div>
</div>
<div class="sect3">
<h4 id="_bitmessage">Bitmessage</h4>
<div class="paragraph"><p>Bitmessage is a bitcoin alt-chain that implements a de-centralized secure messaging service, essentially a server-less encrypted email system. Bitmessage allows users to compose and send messages to each other, using a bitmessage address. The messages operate in much the same way as a bitcoin transaction, but they are transient - they do not persist beyond 2 days and if not delivered to the destination node in that time, they are lost. Senders and recipients are pseudonymous, they have no identifiers other than a bitmessage address, but are strongly authenticated, meaning that messages cannot be "spoofed". Bitmessages are encrypted to the recipient and therefore the bitmessage network is resistant to holistic surveillance - an eavesdropper has to compromise the recipient&#8217;s device in order to intercept messages.</p></div>
</div>
<div class="sect3">
<h4 id="_ethereum">Ethereum</h4>
<div class="paragraph"><p>Ethereum is a Turing-complete contract processing and execution platform based on a blockchain ledger. It is not a clone of bitcoin, but a completely independent design and implementation. Ethereum has a built-in currency, called <em>ether</em>, which is required in order to pay for contract execution. Ethereum&#8217;s blockchain records <em>contracts</em>, which are expressed in a low-level, byte-code like, Turing-complete language. Essentially, a contract is a program that runs on every node in the Ethereum system. Ethereum contracts can store data, send and receive ether payments, store ether and execute an infinite range (hence Turing-complete) of computable actions, acting as de-centralized autonomous software agents.</p></div>
<div class="paragraph"><p>Ethereum can implement quite complex systems that are otherwise implemented as alt-chains themselves. For example, below is a Namecoin-like name registration contract written in Ethereum (or more accurately, written in a high-level language that can be compiled to Ethereum code):</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
</div>
<div class="sect2">
<h3 id="_future_of_currencies">Future of Currencies</h3>
<div class="paragraph"><p>The future of cryptographic currencies overall is even brighter than the future of bitcoin. Bitcoin introduced a completely new form of de-centralized organization and consensus that has spawned hundreds of incredible innovations. These inventions will likely affect broad sectors of the economy, from distributed systems science, to finance, economics, currencies, central banking, and corporate governance. Many human activities that previously required centralized institutions or organizations to function as authoritative or trusted points of control can now be de-centralized. The invention of the blockchain and consensus system will significantly reduce the cost of organization and coordination on large scale systems, while removing opportunities for concentration of power, corruption and regulatory capture.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tx_script_ops">Appendix: Transaction Script Language Operators, Constants and Symbols</h2>
<div class="sectionbody">
<div class="tableblock" id="tx_script_ops_table_pushdata">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 26. Push Value onto Stack</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_0 or OP_FALSE</p></td>
<td align="left" valign="top"><p class="table">0x00</p></td>
<td align="left" valign="top"><p class="table">An empty array is pushed on to the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-75</p></td>
<td align="left" valign="top"><p class="table">0x01-0x4b</p></td>
<td align="left" valign="top"><p class="table">Push the next N bytes onto the stack, where N is 1 to 75 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUSHDATA1</p></td>
<td align="left" valign="top"><p class="table">0x4c</p></td>
<td align="left" valign="top"><p class="table">The next script byte contains N, push the following N bytes onto the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUSHDATA2</p></td>
<td align="left" valign="top"><p class="table">0x4d</p></td>
<td align="left" valign="top"><p class="table">The next two script bytes contain N, push the following N bytes onto the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUSHDATA4</p></td>
<td align="left" valign="top"><p class="table">0x4e</p></td>
<td align="left" valign="top"><p class="table">The next four script bytes contain N, push the following N bytes onto the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_1NEGATE</p></td>
<td align="left" valign="top"><p class="table">0x4f</p></td>
<td align="left" valign="top"><p class="table">Push the value "-1" onto the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_RESERVED</p></td>
<td align="left" valign="top"><p class="table">0x50</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction unless found in an unexecuted OP_IF clause</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_1 or OP_TRUE</p></td>
<td align="left" valign="top"><p class="table">0x51</p></td>
<td align="left" valign="top"><p class="table">Push the value "1" onto the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2 to OP_16</p></td>
<td align="left" valign="top"><p class="table">0x52 to 0x60</p></td>
<td align="left" valign="top"><p class="table">For OP_N, push the value "N" onto the stack. E.g., OP_2 pushes "2"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_control">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 27. Conditional Flow Control</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_NOP</p></td>
<td align="left" valign="top"><p class="table">0x61</p></td>
<td align="left" valign="top"><p class="table">Do nothing</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_VER</p></td>
<td align="left" valign="top"><p class="table">0x62</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction unless found in an unexecuted OP_IF clause</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_IF</p></td>
<td align="left" valign="top"><p class="table">0x63</p></td>
<td align="left" valign="top"><p class="table">Execute the statements following if top of stack is not 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NOTIF</p></td>
<td align="left" valign="top"><p class="table">0x64</p></td>
<td align="left" valign="top"><p class="table">Execute the statements following if top of stack is 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_VERIF</p></td>
<td align="left" valign="top"><p class="table">0x65</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_VERNOTIF</p></td>
<td align="left" valign="top"><p class="table">0x66</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ELSE</p></td>
<td align="left" valign="top"><p class="table">0x67</p></td>
<td align="left" valign="top"><p class="table">Execute only if the previous statements were not executed</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ENDIF</p></td>
<td align="left" valign="top"><p class="table">0x68</p></td>
<td align="left" valign="top"><p class="table">Ends the OP_IF, OP_NOTIF, OP_ELSE block</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_VERIFY</p></td>
<td align="left" valign="top"><p class="table">0x69</p></td>
<td align="left" valign="top"><p class="table">Check the top of the stack, Halt and Invalidate transaction if not TRUE</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_RETURN</p></td>
<td align="left" valign="top"><p class="table">0x6a</p></td>
<td align="left" valign="top"><p class="table">Halt and invalidate transaction</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_stack">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 28. Stack Operations</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_TOALTSTACK</p></td>
<td align="left" valign="top"><p class="table">0x6b</p></td>
<td align="left" valign="top"><p class="table">Pop top item from stack and push to alternative stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_FROMALTSTACK</p></td>
<td align="left" valign="top"><p class="table">0x6c</p></td>
<td align="left" valign="top"><p class="table">Pop top item from alternative stack and push to stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2DROP</p></td>
<td align="left" valign="top"><p class="table">0x6d</p></td>
<td align="left" valign="top"><p class="table">Pop top two stack items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2DUP</p></td>
<td align="left" valign="top"><p class="table">0x6e</p></td>
<td align="left" valign="top"><p class="table">Duplicate top two stack items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_3DUP</p></td>
<td align="left" valign="top"><p class="table">0x6f</p></td>
<td align="left" valign="top"><p class="table">Duplicate top three stack items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2OVER</p></td>
<td align="left" valign="top"><p class="table">0x70</p></td>
<td align="left" valign="top"><p class="table">Copies the third and fourth items in the stack to the top</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2ROT</p></td>
<td align="left" valign="top"><p class="table">0x71</p></td>
<td align="left" valign="top"><p class="table">Moves the fifth and sixth items in the stack to the top</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_2SWAP</p></td>
<td align="left" valign="top"><p class="table">0x72</p></td>
<td align="left" valign="top"><p class="table">Swap the two top pairs of items in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_IFDUP</p></td>
<td align="left" valign="top"><p class="table">0x73</p></td>
<td align="left" valign="top"><p class="table">Duplicate the top item in the stack if it is not 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_DEPTH</p></td>
<td align="left" valign="top"><p class="table">0x74</p></td>
<td align="left" valign="top"><p class="table">Count the items on the stack and push the resulting count</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_DROP</p></td>
<td align="left" valign="top"><p class="table">0x75</p></td>
<td align="left" valign="top"><p class="table">Pop the top item in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_DUP</p></td>
<td align="left" valign="top"><p class="table">0x76</p></td>
<td align="left" valign="top"><p class="table">Duplicate the top item in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NIP</p></td>
<td align="left" valign="top"><p class="table">0x77</p></td>
<td align="left" valign="top"><p class="table">Pop the second item in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_OVER</p></td>
<td align="left" valign="top"><p class="table">0x78</p></td>
<td align="left" valign="top"><p class="table">Copy the second item in the stack and push it on to the top</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PICK</p></td>
<td align="left" valign="top"><p class="table">0x79</p></td>
<td align="left" valign="top"><p class="table">Pop value N from top, then copy the Nth item to the top of the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ROLL</p></td>
<td align="left" valign="top"><p class="table">0x7a</p></td>
<td align="left" valign="top"><p class="table">Pop value N from top, then move the Nth item to the top of the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ROT</p></td>
<td align="left" valign="top"><p class="table">0x7b</p></td>
<td align="left" valign="top"><p class="table">Rotate the top three items in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SWAP</p></td>
<td align="left" valign="top"><p class="table">0x7c</p></td>
<td align="left" valign="top"><p class="table">Swap the top three items in the stack</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_TUCK</p></td>
<td align="left" valign="top"><p class="table">0x7d</p></td>
<td align="left" valign="top"><p class="table">Copy the top item and insert it between the top and second item.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_splice">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 29. String Splice Operations</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_CAT</em></p></td>
<td align="left" valign="top"><p class="table">0x7e</p></td>
<td align="left" valign="top"><p class="table">Disabled (Concatenates top two items)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_SUBSTR</em></p></td>
<td align="left" valign="top"><p class="table">0x7f</p></td>
<td align="left" valign="top"><p class="table">Disabled (Returns substring)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_LEFT</em></p></td>
<td align="left" valign="top"><p class="table">0x80</p></td>
<td align="left" valign="top"><p class="table">Disabled (Returns left substring)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_RIGHT</em></p></td>
<td align="left" valign="top"><p class="table">0x81</p></td>
<td align="left" valign="top"><p class="table">Disabled (Returns right substring)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SIZE</p></td>
<td align="left" valign="top"><p class="table">0x82</p></td>
<td align="left" valign="top"><p class="table">Calculate string length of top item and push the result</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_binmath">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 30. Binary Arithmetic and Conditionals</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_INVERT</em></p></td>
<td align="left" valign="top"><p class="table">0x83</p></td>
<td align="left" valign="top"><p class="table">Disabled (Flip the bits of the top item)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_AND</em></p></td>
<td align="left" valign="top"><p class="table">0x84</p></td>
<td align="left" valign="top"><p class="table">Disabled (Boolean AND of two top items)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_OR</em></p></td>
<td align="left" valign="top"><p class="table">0x85</p></td>
<td align="left" valign="top"><p class="table">Disabled (Boolean OR of two top items)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_XOR</em></p></td>
<td align="left" valign="top"><p class="table">0x86</p></td>
<td align="left" valign="top"><p class="table">Disabled (Boolean XOR of two top items)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_EQUAL</p></td>
<td align="left" valign="top"><p class="table">0x87</p></td>
<td align="left" valign="top"><p class="table">Push TRUE (1) if top two items are exactly equal, push FALSE (0) otherwise</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_EQUALVERIFY</p></td>
<td align="left" valign="top"><p class="table">0x88</p></td>
<td align="left" valign="top"><p class="table">Same as OP_EQUAL, but run OP_VERIFY after to halt if not TRUE</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_RESERVED1</p></td>
<td align="left" valign="top"><p class="table">0x89</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction unless found in an unexecuted OP_IF clause</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_RESERVED2</p></td>
<td align="left" valign="top"><p class="table">0x8a</p></td>
<td align="left" valign="top"><p class="table">Halt - Invalid transaction unless found in an unexecuted OP_IF clause</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_numbers">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 31. Numeric Operators</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_1ADD</p></td>
<td align="left" valign="top"><p class="table">0x8b</p></td>
<td align="left" valign="top"><p class="table">Add 1 to the top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_1SUB</p></td>
<td align="left" valign="top"><p class="table">0x8c</p></td>
<td align="left" valign="top"><p class="table">Subtract 1 from the top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_2MUL</em></p></td>
<td align="left" valign="top"><p class="table">0x8d</p></td>
<td align="left" valign="top"><p class="table">Disabled (Multiply top item by 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><em>OP_2DIV</em></p></td>
<td align="left" valign="top"><p class="table">0x8e</p></td>
<td align="left" valign="top"><p class="table">Disabled (Divide top item by 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NEGATE</p></td>
<td align="left" valign="top"><p class="table">0x8f</p></td>
<td align="left" valign="top"><p class="table">Flip the sign of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ABS</p></td>
<td align="left" valign="top"><p class="table">0x90</p></td>
<td align="left" valign="top"><p class="table">Change the sign of the top item to positive</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NOT</p></td>
<td align="left" valign="top"><p class="table">0x91</p></td>
<td align="left" valign="top"><p class="table">If top item is 0 or 1 boolean flip it, otherwise return 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_0NOTEQUAL</p></td>
<td align="left" valign="top"><p class="table">0x92</p></td>
<td align="left" valign="top"><p class="table">If top item is 0 return 0, otherwise return 1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_ADD</p></td>
<td align="left" valign="top"><p class="table">0x93</p></td>
<td align="left" valign="top"><p class="table">Pop top two items, add them and push result</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SUB</p></td>
<td align="left" valign="top"><p class="table">0x94</p></td>
<td align="left" valign="top"><p class="table">Pop top two items, subtract first form second, push result</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_MUL</p></td>
<td align="left" valign="top"><p class="table">0x95</p></td>
<td align="left" valign="top"><p class="table">Disabled (Multiply top two items)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_DIV</p></td>
<td align="left" valign="top"><p class="table">0x96</p></td>
<td align="left" valign="top"><p class="table">Disabled (Divide second item by first item)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_MOD</p></td>
<td align="left" valign="top"><p class="table">0x97</p></td>
<td align="left" valign="top"><p class="table">Disabled (Remainder divide second item by first item)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_LSHIFT</p></td>
<td align="left" valign="top"><p class="table">0x98</p></td>
<td align="left" valign="top"><p class="table">Disabled (Shift second item left by first item number of bits)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_RSHIFT</p></td>
<td align="left" valign="top"><p class="table">0x99</p></td>
<td align="left" valign="top"><p class="table">Disabled (Shift second item right by first item number of bits)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_BOOLAND</p></td>
<td align="left" valign="top"><p class="table">0x9a</p></td>
<td align="left" valign="top"><p class="table">Boolean AND of top two items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_BOOLOR</p></td>
<td align="left" valign="top"><p class="table">0x9b</p></td>
<td align="left" valign="top"><p class="table">Boolean OR of top two items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NUMEQUAL</p></td>
<td align="left" valign="top"><p class="table">0x9c</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if top two items are equal numbers</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NUMEQUALVERIFY</p></td>
<td align="left" valign="top"><p class="table">0x9d</p></td>
<td align="left" valign="top"><p class="table">Same as NUMEQUAL, then OP_VERIFY to halt if not TRUE</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_NUMNOTEQUAL</p></td>
<td align="left" valign="top"><p class="table">0x9e</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if top two items are not equal numbers</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_LESSTHAN</p></td>
<td align="left" valign="top"><p class="table">0x9f</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if second item is less than top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_GREATERTHAN</p></td>
<td align="left" valign="top"><p class="table">0xa0</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if second item is greater than top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_LESSTHANOREQUAL</p></td>
<td align="left" valign="top"><p class="table">0xa1</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if second item is less than or equal to top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_GREATERTHANOREQUAL</p></td>
<td align="left" valign="top"><p class="table">0xa2</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if second item is great than or equal to top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_MIN</p></td>
<td align="left" valign="top"><p class="table">0xa3</p></td>
<td align="left" valign="top"><p class="table">Return the smaller of the two top items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_MAX</p></td>
<td align="left" valign="top"><p class="table">0xa4</p></td>
<td align="left" valign="top"><p class="table">Return the larger of the two top items</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_WITHIN</p></td>
<td align="left" valign="top"><p class="table">0xa5</p></td>
<td align="left" valign="top"><p class="table">Return TRUE if the third item is between the second item (or equal) and first item</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_crypto">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 32. Cryptographic and Hashing Operations</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_RIPEMD160</p></td>
<td align="left" valign="top"><p class="table">0xa6</p></td>
<td align="left" valign="top"><p class="table">Return RIPEMD160 hash of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SHA1</p></td>
<td align="left" valign="top"><p class="table">0xa7</p></td>
<td align="left" valign="top"><p class="table">Return SHA1 hash of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SHA256</p></td>
<td align="left" valign="top"><p class="table">0xa8</p></td>
<td align="left" valign="top"><p class="table">Return SHA256 hash of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_HASH160</p></td>
<td align="left" valign="top"><p class="table">0xa9</p></td>
<td align="left" valign="top"><p class="table">Return RIPEMD160(SHA256(x)) hash of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_HASH256</p></td>
<td align="left" valign="top"><p class="table">0xaa</p></td>
<td align="left" valign="top"><p class="table">Return SHA256(SHA256(x)) hash of top item</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_CODESEPARATOR</p></td>
<td align="left" valign="top"><p class="table">0xab</p></td>
<td align="left" valign="top"><p class="table">Mark the beginning of signature-checked data</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_CHECKSIG</p></td>
<td align="left" valign="top"><p class="table">0xac</p></td>
<td align="left" valign="top"><p class="table">Pop a public key and signature and validate the signature for the transaction&#8217;s hashed data, return TRUE if matching</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_CHECKSIGVERIFY</p></td>
<td align="left" valign="top"><p class="table">0xad</p></td>
<td align="left" valign="top"><p class="table">Same as CHECKSIG, then OP_VEIRFY to halt if not TRUE</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_CHECKMULTISIG</p></td>
<td align="left" valign="top"><p class="table">0xae</p></td>
<td align="left" valign="top"><p class="table">Run CHECKSIG for each pair of signature and public key provided. All must match. Bug in implementation pops an extra value, prefix with OP_NOP as workaround</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_CHECKMULTISIGVERIFY</p></td>
<td align="left" valign="top"><p class="table">0xaf</p></td>
<td align="left" valign="top"><p class="table">Same as CHECKMULTISIG, then OP_VERIFY to halt if not TRUE</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_nop">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 33. Non-Operators</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_NOP1-OP_NOP10</p></td>
<td align="left" valign="top"><p class="table">0xb0-0xb9</p></td>
<td align="left" valign="top"><p class="table">Does nothing, ignored.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="tx_script_ops_table_internal">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 34. Reserved OP codes for internal use by the parser</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top"> Symbol </th>
<th align="left" valign="top"> Value (hex) </th>
<th align="left" valign="top"> Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">OP_SMALLDATA</p></td>
<td align="left" valign="top"><p class="table">0xf9</p></td>
<td align="left" valign="top"><p class="table">Represents small data field</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_SMALLINTEGER</p></td>
<td align="left" valign="top"><p class="table">0xfa</p></td>
<td align="left" valign="top"><p class="table">Represents small integer data field</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUBKEYS</p></td>
<td align="left" valign="top"><p class="table">0xfb</p></td>
<td align="left" valign="top"><p class="table">Represents public key fields</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUBKEYHASH</p></td>
<td align="left" valign="top"><p class="table">0xfd</p></td>
<td align="left" valign="top"><p class="table">Represents a public key hash field</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_PUBKEY</p></td>
<td align="left" valign="top"><p class="table">0xfe</p></td>
<td align="left" valign="top"><p class="table">Represents a public key field</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OP_INVALIDOPCODE</p></td>
<td align="left" valign="top"><p class="table">0xff</p></td>
<td align="left" valign="top"><p class="table">Represents any OP code not currently assigned</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sx_cmds">Appendix: Available commands with sx tools</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre><code>The sx commands are:

DEPRECATED
  ELECTRUM STYLE DETERMINISTIC KEYS AND ADDRESSES
   genaddr  Generate a Bitcoin address deterministically from a wallet
             seed or master public key.
   genpriv  Generate a private key deterministically from a seed.
   genpub   Generate a public key deterministically from a wallet
             seed or master public key.
   mpk      Extract a master public key from a deterministic wallet seed.
   newseed  Create a new deterministic wallet seed.

EXPERIMENTAL
  APPS
   wallet   Experimental command line wallet.

OFFLINE BLOCKCHAIN
  HEADERS
   showblkhead  Show the details of a block header.

OFFLINE KEYS AND ADDRESSES
  BASIC
   addr          See Bitcoin address of a public or private key.
   embed-addr    Generate an address used for embedding record of data into the blockchain
   get-pubkey    Get the pubkey of an address if available
   newkey        Create a new private key.
   pubkey        See the public part of a private key.
   validaddr     Validate an address.
  BRAIN STORAGE
   brainwallet   Make 256 bit bitcoin private key from an arbitrary passphrase.
   mnemonic      Make 12 word mnemonic out of 128 bit electrum or bip32 seed.
  HD / BIP32
   hd-priv       Create an private HD key from another HD private key.
   hd-pub        Create an HD public key from another HD private or public key.
   hd-seed       Create a random new HD key.
   hd-to-address Convert an HD public or private key to a Bitcoin address.
   hd-to-wif     Convert an HD private key to a WIF private key.
  MULTISIG ADDRESSES
   scripthash    Create BIP 16 script hash address from raw script hex.
  STEALTH
   stealth-addr            See a stealth address from given input.
   stealth-initiate        Initiate a new stealth payment.
   stealth-newkey          Generate new stealth keys and an address.
   stealth-show-addr       Show details for a stealth address.
   stealth-uncover         Uncover a stealth address.
   stealth-uncover-secret  Uncover a stealth secret.

OFFLINE TRANSACTIONS
  SCRIPTING
   mktx          Create an unsigned tx.
   rawscript     Create the raw hex representation from a script.
   set-input     Set a transaction input.
   showscript    Show the details of a raw script.
   showtx        Show the details of a transaction.
   sign-input    Sign a transaction input.
   unwrap        Validates checksum and recovers version byte and original data from hexstring.
   validsig      Validate a transaction input's signature.
   wrap          Adds version byte and checksum to hexstring.

ONLINE (BITCOIN P2P)
  BLOCKCHAIN UPDATES
   sendtx-node     Send transaction to a single node.
   sendtx-p2p      Send tx to bitcoin network.

ONLINE (BLOCKCHAIN.INFO)
  BLOCKCHAIN QUERIES (blockchain.info)
   bci-fetch-last-height    Fetch the last block height using blockchain.info.
   bci-history              Get list of output points, values, and their spends
                             from blockchain.info
  BLOCKCHAIN UPDATES
   sendtx-bci               Send tx to blockchain.info/pushtx.

ONLINE (BLOCKEXPLORER.COM)
  BLOCKCHAIN QUERIES (blockexplorer.com)
   blke-fetch-transaction    Fetches a transaction from blockexplorer.com

ONLINE (OBELISK)
  BLOCKCHAIN QUERIES
   balance              Show balance of a Bitcoin address in satoshis.
   fetch-block-header   Fetch raw block header.
   fetch-last-height    Fetch the last block height.
   fetch-stealth        Fetch a stealth information using a network connection to
                         make requests against the obelisk load balancer backend.
   fetch-transaction    Fetch a raw transaction using a network connection to
                         make requests against the obelisk load balancer backend.
   fetch-transaction-index
                        Fetch block height and index in block of transaction.
   get-utxo             Get enough unspent transaction outputs from a given set of
                         addresses to pay a given number of satoshis
   history              Get list of output points, values, and their spends for an
                         address. grep can filter for just unspent outputs which can
                         be fed into mktx.
   validtx              Validate a transaction.
  BLOCKCHAIN UPDATES
   sendtx-obelisk      Send tx to obelisk server.
  BLOCKCHAIN WATCHING
   monitor        Monitor an address.
   watchtx        Watch transactions from the network searching for a certain hash.
  OBELISK ADMIN
   initchain      Initialize a new blockchain.

UTILITY
  EC MATH
   ec-add-modp      Calculate the result of INTEGER + INTEGER.
   ec-multiply      Multiply an integer and a point together.
   ec-tweak-add     Calculate the result of POINT + INTEGER * G.
  FORMAT (BASE 58)
   base58-decode         Convert from base58 to hex
   base58-encode         Convert from hex to base58
  FORMAT (BASE58CHECK)
   base58check-decode    Convert from base58check to hex
   base58check-encode    Convert from hex to base58check
   decode-addr      Decode a address from base58check form to internal RIPEMD representation
   encode-addr      Encode an address from internal RIPEMD representation to base58check form
  FORMAT (WIF)
   secret-to-wif    Convert a secret exponent value to Wallet Import Format
   wif-to-secret    Convert a Wallet Import Format to secret exponent value.
  HASHES
   ripemd-hash      RIPEMD hash data from STDIN.
   sha256           Perform SHA256 hash of data.
  MISC
   qrcode           Generate Bitcoin QR codes offline.
  SATOSHI MATH
   btc              Convert Satoshis into Bitcoins.
   satoshi          Convert Bitcoins into Satoshis.

See 'sx help COMMAND' for more information on a specific command.</code></pre>
</div></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-10-13 22:50:37 PDT
</div>
</div>
</body>
</html>
